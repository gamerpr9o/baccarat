<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat AI Pro - Strategic Advisor</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800;900&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6C5CE7; /* Modern purple */
            --primary-dark: #5649C0;
            --secondary: #00B894; /* Teal */
            --accent: #FD79A8; /* Pink */
            --dark: #0F0F1A; /* Dark blue */
            --darker: #0A0A12;
            --light: #F5F6FA;
            --light-gray: #E0E0E0;
            --success: #00B894;
            --danger: #D63031;
            --warning: #FDCB6E;
            --info: #0984E3;
            --gold: #FFD700;
            
            --card-bg: rgba(255, 255, 255, 0.1);
            --panel-bg: rgba(20, 20, 30, 0.9);
            --border-color: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0, 0, 0, 0.5);
            --text-light: #F5F6FA;
            --text-medium: #BDC3C7;
            --text-dark: #636E72;
            
            --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            --transition-fast: all 0.2s ease;
            
            /* Particle effects */
            --particle-size: 2px;
            --particle-count: 50;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: var(--dark);
            color: var(--text-light);
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            line-height: 1.6;
            position: relative;
        }

        /* Video Background */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -2;
            opacity: 0.15;
        }

        /* Particle Effect */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            background: var(--primary);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.6;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }

        /* Auth Overlay */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 18, 0.98);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.8s cubic-bezier(0.65, 0.05, 0.36, 1);
        }

        .auth-container {
            background: linear-gradient(145deg, var(--darker), #151525);
            padding: 3rem;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .auth-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(108, 92, 231, 0.1) 0%, rgba(108, 92, 231, 0) 70%);
            animation: rotate 20s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .auth-title {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            color: var(--light);
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
        }

        .auth-title span {
            color: var(--primary);
        }

        .auth-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--primary);
            border-radius: 3px;
        }

        .auth-input-container {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .auth-input {
            width: 100%;
            padding: 1rem 1rem 1rem 3rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            transition: var(--transition);
            outline: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .auth-input:focus {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 2px var(--primary), 0 4px 20px rgba(108, 92, 231, 0.4);
        }

        .auth-input-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-medium);
        }

        .auth-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .auth-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: var(--transition);
        }

        .auth-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.6);
        }

        .auth-btn:active {
            transform: translateY(1px);
        }

        .auth-error, .auth-success {
            margin-top: 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            display: none;
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid;
            animation: fadeIn 0.5s ease-out;
        }

        .auth-error {
            color: var(--danger);
            background-color: rgba(214, 48, 49, 0.15);
            border-color: var(--danger);
        }

        .auth-success {
            color: var(--success);
            background-color: rgba(0, 184, 148, 0.15);
            border-color: var(--success);
        }

        .key-info {
            margin-top: 2rem;
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.6;
            color: var(--text-medium);
        }

        .time-remaining {
            margin-top: 1.5rem;
            color: var(--warning);
            font-weight: 700;
            display: none;
            font-size: 1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; text-shadow: 0 0 10px var(--warning); }
            100% { opacity: 0.8; }
        }

        /* Main Container */
        .container {
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .container.show {
            opacity: 1;
            transform: translateY(0);
            display: block;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .logo {
            font-family: 'Playfair Display', serif;
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--light);
            display: flex;
            align-items: center;
        }

        .logo span {
            color: var(--primary);
            margin-left: 0.5rem;
        }

        .logo-icon {
            margin-right: 0.5rem;
            color: var(--primary);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .time-info {
            background: rgba(255,255,255,0.1);
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 0.9rem;
            font-weight: 600;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(5px);
            transition: var(--transition);
        }

        .time-info:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .time-label {
            opacity: 0.8;
            margin-right: 0.5rem;
            color: var(--text-medium);
        }

        .time-value {
            color: var(--info);
            font-weight: 700;
        }

        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
            flex-wrap: wrap;
            position: relative;
        }

        .tab-btn {
            background: rgba(255,255,255,0.1);
            color: var(--text-light);
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid transparent;
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: var(--transition);
        }

        .tab-btn:hover::before {
            left: 100%;
        }

        .tab-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-color: var(--light);
            box-shadow: 0 6px 20px rgba(108, 92, 231, 0.5);
            transform: translateY(-3px);
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.6s ease-out;
        }

        .tab-content.active {
            display: block;
        }

        /* Panel Styles */
        .panel {
            background: var(--panel-bg);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px var(--shadow-color);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
            transition: var(--transition);
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
        }

        .panel-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
        }

        .panel-title i {
            margin-right: 0.8rem;
            color: var(--primary);
        }

        /* Card Counting Layout */
        .card-counting-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            overflow: hidden;
            min-height: 400px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--light);
        }

        .chart-controls {
            display: flex;
            gap: 0.8rem;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            padding: 0.6rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            font-weight: 600;
        }

        .control-btn:hover {
            background: var(--primary);
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
        }

        .chart-area {
            height: 300px;
            position: relative;
            width: 100%;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 1rem;
        }

        /* Roadmap */
        .roadmap {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 10px;
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
        }

        .cell {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            background-color: rgba(255,255,255,0.1);
            color: white;
            position: relative;
            transition: var(--transition-fast);
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .cell.predicted-player {
            background-color: var(--info);
            box-shadow: 0 0 15px rgba(9, 132, 227, 0.7);
            border: 2px solid rgba(255,255,255,0.6);
        }

        .cell.predicted-banker {
            background-color: var(--danger);
            box-shadow: 0 0 15px rgba(214, 48, 49, 0.7);
            border: 2px solid rgba(255,255,255,0.6);
        }

        .cell.predicted-tie {
            background-color: var(--warning);
            color: var(--dark);
            box-shadow: 0 0 15px rgba(253, 203, 110, 0.7);
            border: 2px solid rgba(255,255,255,0.6);
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* Analysis Panel */
        .analysis-panel {
            display: flex;
            flex-direction: column;
        }

        .bet-recommendation {
            background: rgba(0,0,0,0.3);
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            text-align: center;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: var(--transition);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .bet-recommendation::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.1), transparent);
            z-index: -1;
        }

        .recommendation-text {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 0.8rem;
            animation: fadeIn 0.8s ease-out;
        }

        .no-bet {
            color: var(--text-medium);
        }

        .bet-suggestion {
            color: var(--success);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0% { opacity: 0.9; text-shadow: 0 0 8px rgba(0, 184, 148, 0.5); }
            50% { opacity: 1; text-shadow: 0 0 20px rgba(0, 184, 148, 0.8); }
            100% { opacity: 0.9; text-shadow: 0 0 8px rgba(0, 184, 148, 0.5); }
        }

        .bet-amount {
            font-size: 1.1rem;
            color: var(--warning);
            font-weight: 600;
        }

        /* Count Info */
        .count-info {
            background: rgba(0,0,0,0.3);
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .count-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: var(--primary);
        }

        .count-result-value {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--light);
            margin-bottom: 0.5rem;
            animation: bounceIn 0.8s;
        }

        .count-desc {
            font-size: 0.9rem;
            opacity: 0.9;
            line-height: 1.5;
            color: var(--text-medium);
        }

        /* Stats Grid */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            transition: var(--transition-fast);
        }

        .stat-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            animation: fadeIn 0.5s ease-out;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
            color: var(--text-medium);
        }

        .player-stat .stat-value { color: var(--info); }
        .banker-stat .stat-value { color: var(--danger); }
        .tie-stat .stat-value { color: var(--warning); }

        /* Input Controls */
        .input-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .card-btn {
            padding: 1rem 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .card-btn:hover {
            background: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(108, 92, 231, 0.5);
        }

        /* Clear Button */
        .clear-btn-container {
            text-align: center;
            margin-top: 1.5rem;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        /* History */
        .history-container {
            margin-top: auto;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .history-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
            animation: fadeIn 0.5s ease-out;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-outcome.player { color: var(--info); font-weight: 600; }
        .history-outcome.banker { color: var(--danger); font-weight: 600; }
        .history-outcome.tie { color: var(--warning); font-weight: 600; }

        /* Message Box */
        .message-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
            pointer-events: none;
        }

        .message-box {
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            text-align: left;
            font-weight: 500;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s ease;
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-left: 4px solid;
            transform: translateX(20px);
            backdrop-filter: blur(5px);
            background: rgba(20, 20, 30, 0.9);
        }

        .message-box.show {
            display: block;
            opacity: 1;
            transform: translateX(0);
        }

        .message-box.error {
            border-left-color: var(--danger);
            color: var(--danger);
        }

        .message-box.success {
            border-left-color: var(--success);
            color: var(--success);
        }

        .message-box.info {
            border-left-color: var(--info);
            color: var(--info);
        }

        .message-box.warning {
            border-left-color: var(--warning);
            color: var(--warning);
        }

        /* Pattern Recognition Tab */
        .strategy-content {
            padding: 1.5rem;
        }

        .strategy-content h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
            margin-bottom: 1rem;
            text-align: center;
        }

        .strategy-content p {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-medium);
            margin-bottom: 1.5rem;
            text-align: center;
        }

        /* Dropdown */
        .dropdown-container {
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 300px;
        }

        .dropdown-button {
            background: rgba(255,255,255,0.1);
            color: var(--text-light);
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--border-color);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .dropdown-button:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-3px);
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            background: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            z-index: 10;
            min-width: 100%;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            padding: 0.5rem 0;
            border: 1px solid var(--border-color);
            max-height: 300px;
            overflow-y: auto;
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            padding: 0.8rem 1.2rem;
            color: var(--text-light);
            cursor: pointer;
            transition: var(--transition-fast);
            text-align: left;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background: var(--primary);
            color: white;
        }

        /* Strategy Input Group */
        .strategy-input-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 400px;
            margin: 0 auto 1.5rem;
        }

        .strategy-input {
            padding: 0.8rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: rgba(0,0,0,0.3);
            color: var(--light);
            font-size: 1rem;
            outline: none;
            transition: var(--transition);
        }

        .strategy-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary);
        }

        .strategy-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        .strategy-btn:hover {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(108, 92, 231, 0.6);
        }

        .strategy-result {
            margin-top: 1.5rem;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--success);
            animation: fadeIn 0.8s ease-out;
            text-align: center;
        }

        /* Masaniello Chart */
        .masaniello-chart-container {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
        }

        .masaniello-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 5px;
            width: fit-content;
            margin: 0 auto;
        }

        .masaniello-cell {
            width: 40px;
            height: 40px;
            background-color: rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 6px;
            color: var(--text-medium);
            transition: var(--transition-fast);
            position: relative;
        }

        .masaniello-cell .value {
            font-weight: 700;
            font-size: 0.8rem;
            color: var(--light);
        }

        .masaniello-cell .bet-type {
            font-size: 0.6rem;
            opacity: 0.8;
        }

        .masaniello-cell.active-position {
            border: 2px solid var(--warning);
            box-shadow: 0 0 15px var(--warning);
            transform: scale(1.1);
            z-index: 2;
        }

        .masaniello-cell.player-bg { background-color: var(--info); color: white; }
        .masaniello-cell.banker-bg { background-color: var(--danger); color: white; }
        .masaniello-cell.sit-out-bg { background-color: var(--text-medium); color: var(--dark); }

        .masaniello-legend {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 0.5rem;
        }

        /* Toggle Switch */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            gap: 0.8rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-medium);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        /* Mini-Game Styles */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
            justify-content: center;
        }

        .balance-info {
            background: rgba(0,0,0,0.3);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 300px;
        }

        .balance-label {
            color: var(--text-medium);
            font-size: 0.9rem;
            margin-right: 0.5rem;
        }

        .balance-value {
            color: var(--light);
            font-weight: 700;
            font-size: 1.2rem;
        }

        .game-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            width: 100%;
        }

        .bet-option-btn {
            background: rgba(255,255,255,0.1);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            text-transform: uppercase;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .bet-option-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .bet-option-btn.player-bet:hover { background-color: var(--info); border-color: var(--info); }
        .bet-option-btn.banker-bet:hover { background-color: var(--danger); border-color: var(--danger); }
        .bet-option-btn.tie-bet:hover { background-color: var(--warning); border-color: var(--warning); color: var(--dark); }

        .bet-option-btn.active-bet {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-color: var(--light);
            box-shadow: 0 6px 15px rgba(108, 92, 231, 0.5);
            transform: translateY(-3px);
        }

        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
        }

        .bet-input {
            flex: 1;
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: rgba(0,0,0,0.3);
            color: var(--light);
            font-size: 1rem;
            outline: none;
            text-align: center;
            transition: var(--transition);
        }

        .bet-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary);
        }

        .deal-btn {
            background: linear-gradient(135deg, var(--success), #00a884);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1rem;
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.5);
            margin-top: 1.5rem;
            width: 100%;
            max-width: 300px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .deal-btn:hover {
            background: linear-gradient(135deg, #00a884, var(--success));
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 184, 148, 0.7);
        }

        .cards-display {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .player-hand, .banker-hand {
            background: rgba(0,0,0,0.3);
            padding: 1.5rem;
            border-radius: 15px;
            width: 48%;
            min-width: 280px;
            text-align: center;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
        }

        .player-hand h3, .banker-hand h3 {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .player-hand h3 { color: var(--info); }
        .banker-hand h3 { color: var(--danger); }

        .card-list {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
            flex-wrap: wrap;
            min-height: 50px;
        }

        .card-item {
            background: var(--card-bg);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--light);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            animation: fadeIn 0.4s ease-out forwards;
        }

        .hand-score {
            font-size: 2rem;
            font-weight: 800;
            color: var(--accent);
            margin-top: 1rem;
            animation: bounceIn 0.6s;
        }

        .game-outcome-display {
            margin-top: 1.5rem;
            display: none;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
        }

        .game-result {
            font-size: 1.8rem;
            font-weight: 800;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            margin-bottom: 0.8rem;
        }

        .result-player { color: var(--info); }
        .result-banker { color: var(--danger); }
        .result-tie { color: var(--warning); }
        
        .game-outcome-display p {
            font-size: 1rem;
            color: var(--text-medium);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .card-counting-layout {
                grid-template-columns: 1fr;
            }
            
            .panel {
                padding: 1.5rem;
            }
            
            .chart-area {
                height: 250px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }
            
            .tabs-nav {
                gap: 0.5rem;
            }
            
            .tab-btn {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .input-controls {
                grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
            }
            
            .player-hand, .banker-hand {
                width: 100%;
            }
            
            .message-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 10px;
            }
            
            .auth-container {
                padding: 1.5rem;
            }
            
            .auth-title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .masaniello-cell {
                width: 30px;
                height: 30px;
                font-size: 0.6rem;
            }
            
            .masaniello-cell .value {
                font-size: 0.7rem;
            }
            
            .masaniello-cell .bet-type {
                font-size: 0.5rem;
            }
            
            .bet-option-btn {
                min-width: 100px;
                padding: 0.6rem 1rem;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            70% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        @keyframes slideInRight {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInLeft {
            from { transform: translateX(-50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Particle Animation */
        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-1000px) rotate(720deg); }
        }

        /* Highlight Effect */
        .highlight {
            position: relative;
            z-index: 1;
        }

        .highlight::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary), var(--accent), var(--primary));
            z-index: -1;
            border-radius: inherit;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .highlight:hover::after {
            opacity: 0.6;
        }

        /* Glow Effect */
        .glow {
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px var(--primary);
            }
            to {
                box-shadow: 0 0 20px var(--primary);
            }
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple:after {
            content: "";
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            background-image: radial-gradient(circle, #fff 10%, transparent 10.01%);
            background-repeat: no-repeat;
            background-position: 50%;
            transform: scale(10, 10);
            opacity: 0;
            transition: transform .5s, opacity 1s;
        }

        .ripple:active:after {
            transform: scale(0, 0);
            opacity: 0.3;
            transition: 0s;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: var(--transition);
        }

        .theme-toggle:hover {
            transform: translateY(-3px) rotate(30deg);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        .theme-toggle i {
            font-size: 1.2rem;
            color: var(--text-light);
        }
    </style>
</head>
<body>
    <!-- Optional Video Background -->
    <video autoplay muted loop class="video-background" id="videoBg">
        <source src="https://assets.mixkit.co/videos/preview/mixkit-poker-table-in-a-casino-18932-large.mp4" type="video/mp4">
    </video>
    
    <!-- Particle Effect -->
    <div class="particles" id="particles"></div>

    <!-- Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="auth-container">
            <h1 class="auth-title"><i class="fas fa-robot logo-icon"></i>Baccarat<span>AI</span></h1>
            <div class="auth-input-container">
                <i class="fas fa-key auth-input-icon"></i>
                <input type="text" class="auth-input" id="authKeyInput" placeholder="Enter your access key">
            </div>
            <button class="auth-btn ripple" id="authSubmitBtn">Authenticate</button>
            <div class="auth-error" id="authError"></div>
            <div class="auth-success" id="authSuccess">Authentication successful! Loading...</div>
            <div class="time-remaining" id="timeRemaining"></div>
            <div class="key-info">
                <p>Unlock premium features with an access key. Each key is limited to one device.</p>
                <p>Your key's remaining time will be displayed after successful authentication.</p>
            </div>
        </div>
    </div>

    <!-- Message Box for notifications -->
    <div class="message-container">
        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- Theme Toggle -->
    <div class="theme-toggle" id="themeToggle">
        <i class="fas fa-palette"></i>
    </div>

    <!-- Main Application Content -->
    <div class="container" id="mainContent">
        <header>
            <div class="logo">
                <i class="fas fa-robot logo-icon"></i>Baccarat<span>AI</span>
            </div>
            <div class="header-right">
                <div class="time-info" id="timeContainer">
                    <span class="time-label">Time Left:</span>
                    <span class="time-value" id="timeValue">00:00:00</span>
                </div>
            </div>
        </header>

        <!-- Strategy Tabs -->
        <nav class="tabs-nav" id="strategyTabs">
            <button class="tab-btn active" data-tab="cardCounting">
                <i class="fas fa-calculator"></i> Card Counting
            </button>
            <button class="tab-btn" data-tab="patternRecognition">
                <i class="fas fa-chart-line"></i> Pattern Recognition
            </button>
            <button class="tab-btn" data-tab="miniGame">
                <i class="fas fa-gamepad"></i> Mini-Game
            </button>
        </nav>

        <!-- Card Counting Tab Content -->
        <div id="cardCounting" class="tab-content active">
            <div class="card-counting-layout">
                <div class="panel chart-container">
                    <div class="chart-header">
                        <div class="chart-title">
                            <i class="fas fa-chart-bar"></i> Baccarat Card Sequence & Trend
                        </div>
                        <div class="chart-controls">
                            <button class="control-btn ripple" id="bigRoadBtn">Big Road</button>
                            <button class="control-btn ripple" id="beadPlateBtn">Bead Plate</button>
                            <button class="control-btn ripple" id="derivativeBtn">Derivative</button>
                        </div>
                    </div>
                    <div class="chart-area" id="chartArea"></div>
                    <div class="roadmap" id="roadmap"></div>
                </div>

                <div class="panel analysis-panel">
                    <h2 class="panel-title">
                        <i class="fas fa-chart-pie"></i> Card Counting Analysis
                    </h2>

                    <div class="bet-recommendation" id="betRecommendation">
                        <div class="recommendation-text no-bet">Enter cards to see prediction</div>
                        <div class="bet-amount" id="betAmount"></div>
                    </div>

                    <div class="count-info">
                        <div class="count-title">Current Running Count:</div>
                        <div class="count-result-value" id="countResultValue">0</div>
                        <div class="count-desc" id="countDesc">This is the numerical result from the counting system.</div>
                    </div>

                    <div class="stats-container">
                        <div class="stat-box player-stat">
                            <div class="stat-value" id="playerBets">0</div>
                            <div class="stat-label">Player Bets</div>
                        </div>
                        <div class="stat-box banker-stat">
                            <div class="stat-value" id="bankerBets">0</div>
                            <div class="stat-label">Banker Bets</div>
                        </div>
                        <div class="stat-box tie-stat">
                            <div class="stat-value" id="tieBets">0</div>
                            <div class="stat-label">Tie Bets</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="totalEntries">0</div>
                            <div class="stat-label">Total Cards Entered</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="entriesNeeded">N/A</div>
                            <div class="stat-label">Cards Needed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="decksRemaining">--</div>
                            <div class="stat-label">Decks Remaining (Est.)</div>
                        </div>
                    </div>

                    <div class="input-controls">
                        <button class="card-btn ripple" data-card-value="A">A</button>
                        <button class="card-btn ripple" data-card-value="2">2</button>
                        <button class="card-btn ripple" data-card-value="3">3</button>
                        <button class="card-btn ripple" data-card-value="4">4</button>
                        <button class="card-btn ripple" data-card-value="5">5</button>
                        <button class="card-btn ripple" data-card-value="6">6</button>
                        <button class="card-btn ripple" data-card-value="7">7</button>
                        <button class="card-btn ripple" data-card-value="8">8</button>
                        <button class="card-btn ripple" data-card-value="9">9</button>
                        <button class="card-btn ripple" data-card-value="10">10/F</button>
                    </div>
                    <div class="clear-btn-container">
                        <button class="btn-secondary ripple" id="clearBtn">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>

                    <div class="history-container">
                        <div class="history-title">
                            <i class="fas fa-history"></i> Prediction History
                        </div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition Tab Content -->
        <div id="patternRecognition" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">
                    <i class="fas fa-chart-line"></i> Pattern Recognition & Betting Strategy
                </h2>
                <p>Analyze game outcomes and apply a betting progression based on patterns.</p>

                <div class="dropdown-container">
                    <button id="patternDropdownBtn" class="dropdown-button ripple">
                        <span id="selectedPatternText">Select Pattern Method</span>
                        <i class="fas fa-caret-down"></i>
                    </button>
                    <div id="patternDropdownMenu" class="dropdown-menu">
                        <div class="dropdown-item" data-strategy="patternMethod">
                            <i class="fas fa-project-diagram"></i> Pattern Method
                        </div>
                        <div class="dropdown-item" data-strategy="pbpbpbPattern">
                            <i class="fas fa-exchange-alt"></i> PBPBPB Pattern
                        </div>
                        <div class="dropdown-item" data-strategy="dragonPattern">
                            <i class="fas fa-fire"></i> Dragon Pattern (Streaks)
                        </div>
                        <div class="dropdown-item" data-strategy="twosPattern">
                            <i class="fas fa-layer-group"></i> Two-in-a-row Pattern
                        </div>
                        <div class="dropdown-item" data-strategy="masaniello">
                            <i class="fas fa-table"></i> Masaniello
                        </div>
                    </div>
                </div>

                <!-- Pattern Strategy Details and Input -->
                <div id="patternStrategyDetails" class="mt-4 text-center">
                    <p class="text-medium">Choose a pattern strategy from the dropdown above to see its description and controls.</p>
                </div>

                <div id="patternInputArea" class="hidden mt-6">
                    <h3 class="text-xl font-bold mb-4 text-primary">Record Game Outcome</h3>
                    <div class="grid grid-cols-3 gap-4 max-w-sm mx-auto">
                        <button class="strategy-btn ripple" data-outcome="banker">
                            <i class="fas fa-landmark"></i> Banker
                        </button>
                        <button class="strategy-btn ripple" data-outcome="player">
                            <i class="fas fa-user"></i> Player
                        </button>
                        <button class="strategy-btn ripple" data-outcome="tie">
                            <i class="fas fa-link"></i> Tie
                        </button>
                    </div>
                    <button class="btn-secondary ripple mt-4" id="clearPatternBtn">
                        <i class="fas fa-trash"></i> Clear History
                    </button>
                </div>
                
                <div id="patternAnalysisResult" class="strategy-result hidden">
                    <!-- Pattern specific analysis will be injected here -->
                </div>

                <!-- Toggle for Betting Progression -->
                <div class="switch-container mt-6">
                    <label class="switch">
                        <input type="checkbox" id="enableBettingProgressionToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Enable Betting Progression</span>
                </div>

                <!-- Betting Progression Selection -->
                <div class="betting-simulation-controls hidden" id="patternBettingControls">
                    <h4>Apply Betting Progression</h4>
                    <div class="flex flex-col items-center gap-4 mb-6">
                        <div class="dropdown-container w-full max-w-xs">
                            <button id="bettingProgressionDropdownBtn" class="dropdown-button ripple">
                                <span id="selectedBettingProgressionText">Select System</span>
                                <i class="fas fa-caret-down"></i>
                            </button>
                            <div id="bettingProgressionDropdownMenu" class="dropdown-menu">
                                <div class="dropdown-item" data-system="flatBetting">
                                    <i class="fas fa-equals"></i> Flat Betting
                                </div>
                                <div class="dropdown-item" data-system="martingale">
                                    <i class="fas fa-angle-double-up"></i> Martingale
                                </div>
                                <div class="dropdown-item" data-system="dalembert">
                                    <i class="fas fa-arrows-alt-h"></i> D'Alembert
                                </div>
                                <div class="dropdown-item" data-system="fibonacci">
                                    <i class="fas fa-seedling"></i> Fibonacci
                                </div>
                            </div>
                        </div>
                        <div class="bet-unit-input-group flex items-center gap-2 max-w-xs w-full">
                            <label for="betUnitValueInput" class="text-light text-sm font-semibold">1 Unit = $</label>
                            <input type="number" id="betUnitValueInput" class="strategy-input flex-grow" value="10" min="1" step="10">
                            <button class="strategy-btn ripple px-4 py-2 text-sm" id="setBetUnitValueBtn">Set</button>
                        </div>
                    </div>

                    <div id="patternBettingSystemDetails" class="mt-4 text-center">
                        <p class="text-medium">Choose a betting system to manage your wagers.</p>
                    </div>
                    <div id="patternBettingInputArea" class="hidden mt-6">
                        <p class="mt-4 text-light flex justify-center items-baseline">
                            <span class="highlight-bet-label">Next Recommended Bet:</span>
                            <span id="patternNextBetAmount" class="highlight-bet-amount">0 units</span>
                        </p>
                        <p class="text-sm text-gray-400">Current Theoretical Bankroll: <span id="patternCurrentTheoreticalBankroll">$10,000</span></p>
                        <p class="text-sm text-gray-400">Current Base Bet: <span id="patternCurrentBaseBet"></span></p>
                        <button class="btn-secondary ripple mt-4" id="patternResetBettingBtn">
                            <i class="fas fa-sync-alt"></i> Reset System
                        </button>
                    </div>
                </div>
                <!-- Chart Container for Theoretical Bankroll Evolution -->
                <div id="patternChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title"><i class="fas fa-chart-area"></i> Theoretical Bankroll Evolution</h4>
                    <canvas id="patternAnalysisChart"></canvas>
                </div>
                <!-- Chart Container for Outcome Distribution (Pie Chart) -->
                <div id="patternOutcomeDistributionChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title"><i class="fas fa-chart-pie"></i> Outcome Distribution</h4>
                    <canvas id="patternOutcomeDistributionChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Baccarat Mini-Game Tab Content -->
        <div id="miniGame" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">
                    <i class="fas fa-gamepad"></i> Baccarat Mini-Game
                </h2>
                <p>Place your bet and try your luck against the dealer!</p>

                <!-- Mini-Game Balance Display -->
                <div class="balance-info">
                    <span class="balance-label">Your Balance:</span>
                    <span class="balance-value" id="miniGameBalanceDisplay">$10,000</span>
                </div>

                <div class="game-area">
                    <div class="game-controls">
                        <button class="bet-option-btn player-bet ripple" data-bet-target="player">
                            <i class="fas fa-user"></i> Player
                        </button>
                        <button class="bet-option-btn banker-bet ripple" data-bet-target="banker">
                            <i class="fas fa-landmark"></i> Banker
                        </button>
                        <button class="bet-option-btn tie-bet ripple" data-bet-target="tie">
                            <i class="fas fa-link"></i> Tie
                        </button>
                        <div class="bet-input-group">
                            <label for="betAmountInput" class="text-light">Amount:</label>
                            <input type="number" id="betAmountInput" class="bet-input" value="100" min="10">
                        </div>
                    </div>

                    <button class="deal-btn ripple" id="dealHandBtn">
                        <i class="fas fa-play"></i> Deal Hand
                    </button>

                    <div class="cards-display mt-6">
                        <div class="player-hand">
                            <h3><i class="fas fa-user"></i> Player Hand</h3>
                            <div class="card-list" id="playerCardList"></div>
                            <div class="hand-score" id="playerScore">0</div>
                        </div>
                        <div class="banker-hand">
                            <h3><i class="fas fa-landmark"></i> Banker Hand</h3>
                            <div class="card-list" id="bankerCardList"></div>
                            <div class="hand-score" id="bankerScore">0</div>
                        </div>
                    </div>

                    <div class="game-outcome-display mt-4 hidden" id="gameResultDisplay">
                        <h3 class="game-result" id="gameResultText"></h3>
                        <p class="text-lg mt-2">New Balance: <span id="gameNewBalance" class="font-bold text-warning"></span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Effects -->
    <audio id="clickSound" src="https://assets.mixkit.co/sfx/preview/mixkit-modern-click-box-check-1120.mp3" preload="auto"></audio>
    <audio id="successSound" src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" preload="auto"></audio>
    <audio id="errorSound" src="https://assets.mixkit.co/sfx/preview/mixkit-warning-alarm-688.mp3" preload="auto"></audio>
    <audio id="cardSound" src="https://assets.mixkit.co/sfx/preview/mixkit-playing-card-2022.mp3" preload="auto"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
    <audio id="loseSound" src="https://assets.mixkit.co/sfx/preview/mixkit-sad-game-over-1943.mp3" preload="auto"></audio>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // =============================================
            // Initialize Sound Effects
            // =============================================
            const clickSound = document.getElementById('clickSound');
            const successSound = document.getElementById('successSound');
            const errorSound = document.getElementById('errorSound');
            const cardSound = document.getElementById('cardSound');
            const winSound = document.getElementById('winSound');
            const loseSound = document.getElementById('loseSound');
            
            function playSound(sound) {
                try {
                    sound.currentTime = 0;
                    sound.play();
                } catch(e) {
                    console.log("Sound playback error:", e);
                }
            }

            // =============================================
            // Particle Effect
            // =============================================
            function createParticles() {
                const particlesContainer = document.getElementById('particles');
                const particleCount = 30;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    
                    // Random size
                    const size = Math.random() * 3 + 1;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    
                    // Random position
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = `${Math.random() * 100}%`;
                    
                    // Random animation
                    const duration = Math.random() * 20 + 10;
                    const delay = Math.random() * 5;
                    particle.style.animation = `float ${duration}s linear ${delay}s infinite`;
                    
                    // Random color
                    const colors = ['var(--primary)', 'var(--secondary)', 'var(--accent)', 'var(--info)'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.backgroundColor = color;
                    
                    // Random opacity
                    particle.style.opacity = Math.random() * 0.5 + 0.1;
                    
                    particlesContainer.appendChild(particle);
                }
            }
            
            createParticles();

            // =============================================
            // Theme Toggle
            // =============================================
            const themeToggle = document.getElementById('themeToggle');
            const videoBg = document.getElementById('videoBg');
            let darkMode = true;
            
            themeToggle.addEventListener('click', function() {
                darkMode = !darkMode;
                playSound(clickSound);
                
                if (darkMode) {
                    document.documentElement.style.setProperty('--dark', '#0F0F1A');
                    document.documentElement.style.setProperty('--darker', '#0A0A12');
                    document.documentElement.style.setProperty('--light', '#F5F6FA');
                    document.documentElement.style.setProperty('--text-medium', '#BDC3C7');
                    videoBg.style.opacity = '0.15';
                } else {
                    document.documentElement.style.setProperty('--dark', '#F5F6FA');
                    document.documentElement.style.setProperty('--darker', '#E0E0E0');
                    document.documentElement.style.setProperty('--light', '#0F0F1A');
                    document.documentElement.style.setProperty('--text-medium', '#636E72');
                    videoBg.style.opacity = '0.05';
                }
                
                this.classList.add('animate__animated', 'animate__rubberBand');
                setTimeout(() => {
                    this.classList.remove('animate__rubberBand');
                }, 1000);
            });

            // =============================================
            // Authentication System (Same as before)
            // =============================================
            const authOverlay = document.getElementById('authOverlay');
            const mainContent = document.getElementById('mainContent');
            const authKeyInput = document.getElementById('authKeyInput');
            const authSubmitBtn = document.getElementById('authSubmitBtn');
            const authError = document.getElementById('authError');
            const authSuccess = document.getElementById('authSuccess');
            const timeRemaining = document.getElementById('timeRemaining');
            const timeContainer = document.getElementById('timeContainer');

            // Predefined valid keys with expiration periods (in minutes)
            const validKeys = {
                "BAC-AI-2024-K1X7": { expiresIn: 525600 }, // 1 year
                "DEMO-KEY-1": { expiresIn: 60 },    // 60 minutes (1 hour)
                "DEMO-KEY-2": { expiresIn: 1440 },  // 1440 minutes (24 hours)
                "BAC-AI-GOATED-918X": { expiresIn: 40480 },  // Approx 14 days
                "ULTRA-KEY-B": { expiresIn: 24480 } // Approx 17 days
            };

            // Check if a key is expired
            function isKeyExpired(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return true;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);

                return new Date() > expirationDate;
            }

            // Format time as HH:MM:SS
            function formatTime(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            // Calculate remaining time in seconds
            function getRemainingTime(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return 0;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                const now = new Date();

                return Math.max(0, Math.floor((expirationDate - now) / 1000));
            }

            // Enhanced device fingerprinting for security
            async function getDeviceFingerprint() {
                const components = [
                    navigator.userAgent,
                    navigator.platform,
                    navigator.hardwareConcurrency || 'unknown',
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    navigator.languages.join(','),
                    !!navigator.pdfViewerEnabled,
                    navigator.maxTouchPoints || 'unknown'
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('BaccaratAI', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('BaccaratAI', 4, 17);
                const canvasData = canvas.toDataURL();

                let webglData = 'unsupported';
                try {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        webglData = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + '|' +
                                   gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    }
                } catch (e) { /* console.error("WebGL fingerprinting failed:", e); */ }

                const combined = components.join('|') + '|' + canvasData + '|' + webglData;
                const msgBuffer = new TextEncoder().encode(combined);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                return 'fp-' + hashHex;
            }

            // Authentication handler with expiration check
            authSubmitBtn.addEventListener('click', async function() {
                playSound(clickSound);
                const enteredKey = authKeyInput.value.trim();

                if (!validKeys.hasOwnProperty(enteredKey)) {
                    authError.textContent = "Invalid access key";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                    playSound(errorSound);
                    setTimeout(() => {
                        authKeyInput.classList.remove('animate__shakeX');
                    }, 1000);
                    return;
                }

                let keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const deviceFingerprint = await getDeviceFingerprint();

                if (!keyRegistry[enteredKey]) { // Key is being used for the first time
                    const newKeyInfo = {
                        fingerprint: deviceFingerprint,
                        firstUsed: new Date().toISOString(),
                        lastUsed: new Date().toISOString(),
                        expiresIn: validKeys[enteredKey].expiresIn
                    };
                    keyRegistry[enteredKey] = newKeyInfo;
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else if (keyRegistry[enteredKey].fingerprint === deviceFingerprint) { // Key registered to this device
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyRegistry[enteredKey])) {
                        authError.textContent = "This key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                        playSound(errorSound);
                        setTimeout(() => {
                            authKeyInput.classList.remove('animate__shakeX');
                        }, 1000);
                        return;
                    }
                    keyRegistry[enteredKey].lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else { // Key is registered to a different device
                    authError.textContent = "This key is already in use on another device";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                    playSound(errorSound);
                    setTimeout(() => {
                        authKeyInput.classList.remove('animate__shakeX');
                    }, 1000);
                    return;
                }

                // Store successful authentication
                localStorage.setItem('baccaratAuthKey', enteredKey);
                localStorage.setItem('baccaratAuthFingerprint', deviceFingerprint);

                // Show success and remaining time
                const keyInfo = keyRegistry[enteredKey];
                const remainingTimeSeconds = getRemainingTime(keyInfo);

                timeRemaining.textContent = `Expires in: ${formatTime(remainingTimeSeconds)}`;
                timeRemaining.style.display = 'block';

                authError.style.display = 'none';
                authSuccess.style.display = 'block';
                this.disabled = true;
                playSound(successSound);

                // Animate out the auth overlay and show main content
                setTimeout(() => {
                    authOverlay.style.opacity = '0';
                    setTimeout(() => {
                        authOverlay.style.display = 'none';
                        mainContent.style.display = 'block';
                        mainContent.classList.add('show');
                        initApp(enteredKey);
                    }, 500);
                }, 1500);
            });

            // Check for existing auth on page load
            async function checkExistingAuth() {
                const savedKey = localStorage.getItem('baccaratAuthKey');
                const savedFingerprint = localStorage.getItem('baccaratAuthFingerprint');

                if (!savedKey || !savedFingerprint) {
                    authKeyInput.focus();
                    return false;
                }

                const currentFingerprint = await getDeviceFingerprint();
                if (savedFingerprint !== currentFingerprint) {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');
                    authError.textContent = "Authentication required: Device mismatch.";
                    authError.style.display = 'block';
                    authKeyInput.focus();
                    return false;
                }

                const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const keyInfo = keyRegistry[savedKey];

                if (keyInfo && keyInfo.fingerprint === currentFingerprint) {
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyInfo)) {
                        localStorage.removeItem('baccaratAuthKey');
                        localStorage.removeItem('baccaratAuthFingerprint');
                        authError.textContent = "Your access key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.value = savedKey;
                        authKeyInput.focus();
                        return false;
                    }

                    keyInfo.lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));

                    authOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                    mainContent.classList.add('show');
                    initApp(savedKey);
                    return true;
                }

                authKeyInput.focus();
                return false;
            }

            // =============================================
            // Baccarat Core Application Functionality
            // =============================================
            function initApp(activeKey) {
                const gameState = {
                    entries: [], // Stores the raw card values entered (e.g., 'A', '2', '10') for Card Counting
                    predictionHistory: [], // Stores the results of predictions for Card Counting
                    miniGameBalance: 10000, // ONLY for Mini-Game
                    chart: null, // Chart.js instance for Card Counting
                    activeKey: activeKey,
                    timer: null,
                    totalDecks: 8, // Assuming 8 decks in a Baccarat shoe
                    cardsDealt: 0, // Track total cards dealt to estimate decks remaining
                    
                    patternBetting: {
                        currentSystem: null,
                        bettingUnitValue: 10, // Default unit value in dollars for theoretical bankroll
                        martingaleBet: 1, // units
                        dalembertBet: 1, // units
                        fibonacciSequence: [1, 1],
                        fibonacciIndex: 0,
                        flatBetAmount: 1, // units
                        theoreticalBankroll: 10000, // ONLY for Pattern Recognition betting simulation
                        isEnabled: false // New state for betting progression toggle
                    },

                    // Pattern Recognition State
                    currentPatternStrategy: null,
                    patternHistory: [], // Stores 'player', 'banker', 'tie' outcomes
                    currentPatternRecommendation: null, // What the pattern strategy suggests to bet on
                    outcomeCounts: { player: 0, banker: 0, tie: 0 }, // For "Pattern Method" prediction
                    masanielloState: {
                        grid: [], // 2D array for the Masaniello chart
                        gridRows: 10, // Max row based on screenshot
                        gridCols: 10, // Max col based on screenshot
                        currentRow: 0, // Current position Y
                        currentCol: 0, // Current position X
                        unitIncrement: 10 // How much each unit represents in betting (e.g., 1 unit = $10)
                    },
                    patternAnalysisChartInstance: null, // Existing Chart.js instance for theoretical bankroll
                    bankrollTimeline: [], // Stores {outcomeIndex: number, bankroll: number, actualOutcome: string}
                    patternOutcomeDistributionChartInstance: null, // NEW Chart.js instance for pattern outcome distribution
                    lastPatternStrategyRendered: null, // To optimize updatePatternDetails
                    patternChartUpdateTimer: null // For debouncing chart updates
                };

                // Hardcoded Masaniello grid values and suggested bet types based on the screenshot
                const masanielloGridConfig = [
                    // Row 0 (Losses up to 9)
                    [{value: 0, bet: 'sit-out'}, {value: 1, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 1, bet: 'banker'}, {value: 0, bet: 'banker'}],
                    // Row 1
                    [{value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 1, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}],
                    // Row 2
                    [{value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 2, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 6, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}],
                    // Row 3
                    [{value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 6, bet: 'player'}, {value: 4, 'bet': 'player'}],
                    // Row 4
                    [{value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 7, bet: 'player'}, {value: 9, bet: 'player'}, {value: 11, bet: 'player'}, {value: 8, bet: 'player'}],
                    // Row 5
                    [{value: 5, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 3, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}],
                    // Row 6
                    [{value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    // Row 7
                    [{value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 9, bet: 'player'}, {value: 8, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    // Row 8
                    [{value: 1, bet: 'player'}, {value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 8, bet: 'player'}, {value: 11, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}],
                    // Row 9
                    [{value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 1, bet: 'sit-out'}, {value: 2, bet: 'sit-out'}, {value: 4, bet: 'sit-out'}, {value: 8, bet: 'sit-out'}, {value: 15, bet: 'sit-out'}, {value: 30, bet: 'sit-out'}, {value: 61, bet: 'sit-out'}]
                ];

                const elements = {
                    // General UI
                    roadmap: document.getElementById('roadmap'),
                    chartArea: document.getElementById('chartArea'),
                    messageBox: document.getElementById('messageBox'),
                    strategyTabs: document.getElementById('strategyTabs'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    timeValue: document.getElementById('timeValue'),

                    // Card Counting Tab Elements
                    betRecommendation: document.getElementById('betRecommendation'),
                    betAmount: document.getElementById('betAmount'),
                    countResultValue: document.getElementById('countResultValue'),
                    countDesc: document.getElementById('countDesc'),
                    playerBets: document.getElementById('playerBets'),
                    bankerBets: document.getElementById('bankerBets'),
                    tieBets: document.getElementById('tieBets'),
                    totalEntries: document.getElementById('totalEntries'),
                    entriesNeeded: document.getElementById('entriesNeeded'),
                    decksRemaining: document.getElementById('decksRemaining'),
                    cardButtons: document.querySelectorAll('.card-btn'),
                    clearBtn: document.getElementById('clearBtn'),
                    historyList: document.getElementById('historyList'),

                    // Pattern Recognition Tab Elements
                    patternDropdownBtn: document.getElementById('patternDropdownBtn'),
                    selectedPatternText: document.getElementById('selectedPatternText'),
                    patternDropdownMenu: document.getElementById('patternDropdownMenu'),
                    patternStrategyDetails: document.getElementById('patternStrategyDetails'),
                    patternInputArea: document.getElementById('patternInputArea'),
                    patternOutcomeButtons: document.querySelectorAll('#patternInputArea .strategy-btn'),
                    clearPatternBtn: document.getElementById('clearPatternBtn'),
                    patternAnalysisResult: document.getElementById('patternAnalysisResult'),
                    patternBettingControls: document.getElementById('patternBettingControls'),
                    enableBettingProgressionToggle: document.getElementById('enableBettingProgressionToggle'),
                    patternCurrentTheoreticalBankroll: document.getElementById('patternCurrentTheoreticalBankroll'),

                    // Betting Progression within Pattern Recognition
                    bettingProgressionDropdownBtn: document.getElementById('bettingProgressionDropdownBtn'),
                    selectedBettingProgressionText: document.getElementById('selectedBettingProgressionText'),
                    bettingProgressionDropdownMenu: document.getElementById('bettingProgressionDropdownMenu'),
                    patternBettingSystemDetails: document.getElementById('patternBettingSystemDetails'),
                    patternBettingInputArea: document.getElementById('patternBettingInputArea'),
                    patternNextBetAmount: document.getElementById('patternNextBetAmount'),
                    patternCurrentBaseBet: document.getElementById('patternCurrentBaseBet'),
                    patternResetBettingBtn: document.getElementById('patternResetBettingBtn'),
                    betUnitValueInput: document.getElementById('betUnitValueInput'),
                    setBetUnitValueBtn: document.getElementById('setBetUnitValueBtn'),
                    patternAnalysisChartCanvas: document.getElementById('patternAnalysisChart'),
                    patternChartContainer: document.getElementById('patternChartContainer'),
                    patternOutcomeDistributionChartCanvas: document.getElementById('patternOutcomeDistributionChart'),
                    patternOutcomeDistributionChartContainer: document.getElementById('patternOutcomeDistributionChartContainer'),

                    // Mini-Game Tab Elements
                    miniGameBalanceDisplay: document.getElementById('miniGameBalanceDisplay'),
                    betOptionBtns: document.querySelectorAll('.bet-option-btn'),
                    betAmountInput: document.getElementById('betAmountInput'),
                    dealHandBtn: document.getElementById('dealHandBtn'),
                    playerCardList: document.getElementById('playerCardList'),
                    bankerCardList: document.getElementById('bankerCardList'),
                    playerScore: document.getElementById('playerScore'),
                    bankerScore: document.getElementById('bankerScore'),
                    gameResultDisplay: document.getElementById('gameResultDisplay'),
                    gameResultText: document.getElementById('gameResultText'),
                    gameNewBalance: document.getElementById('gameNewBalance')
                };

                // Initialize mini-game balance display
                elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;

                // Display a temporary message
                function displayMessage(message, type) {
                    elements.messageBox.textContent = message;
                    elements.messageBox.className = `message-box show ${type}`;

                    // Play appropriate sound
                    if (type === 'error') playSound(errorSound);
                    else if (type === 'success') playSound(successSound);
                    else playSound(clickSound);

                    // Hide the message after 3 seconds
                    setTimeout(() => {
                        elements.messageBox.classList.remove('show');
                        setTimeout(() => {
                            elements.messageBox.textContent = '';
                        }, 500);
                    }, 3000);
                }

                // Start the countdown timer
                function startTimer() {
                    if (gameState.timer) clearInterval(gameState.timer);

                    updateTimerDisplay(); // Initial update

                    gameState.timer = setInterval(() => {
                        const remaining = updateTimerDisplay();
                        if (remaining <= 0) {
                            clearInterval(gameState.timer);
                            handleKeyExpiration();
                        }
                    }, 1000);
                }

                // Update the timer display and return remaining seconds
                function updateTimerDisplay() {
                    const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                    const keyInfo = keyRegistry[gameState.activeKey];
                    if (!keyInfo) return 0;

                    const expirationDate = new Date(keyInfo.firstUsed);
                    expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                    const now = new Date();
                    const remaining = Math.max(0, Math.floor((expirationDate - now) / 1000));
                    
                    elements.timeValue.textContent = formatTime(remaining);

                    if (remaining <= 300) { // 5 minutes or less
                        elements.timeValue.style.color = 'var(--danger)';
                        timeContainer.classList.add('animate__animated', 'animate__pulse');
                    } else if (remaining <= 900) { // 15 minutes or less
                        elements.timeValue.style.color = 'var(--warning)';
                        timeContainer.classList.remove('animate__pulse');
                    } else {
                        elements.timeValue.style.color = 'var(--info)';
                        timeContainer.classList.remove('animate__pulse');
                    }
                    return remaining;
                }

                // Handle key expiration
                function handleKeyExpiration() {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');

                    mainContent.style.display = 'none';
                    authOverlay.style.display = 'flex';
                    authOverlay.style.opacity = '1';
                    authError.textContent = "Your access key has expired. Please renew your subscription.";
                    authError.style.display = 'block';
                    authKeyInput.value = gameState.activeKey;
                    timeRemaining.style.display = 'none';
                    authSubmitBtn.disabled = false;
                    displayMessage('Your session has expired. Please authenticate again.', 'error');
                }

                // =============================================
                // Card Counting Functions
                // =============================================
                function getCardCountContribution(cardValue) {
                    switch (cardValue) {
                        case 'A': return -1;
                        case '2':
                        case '3': return -1;
                        case '4':
                        case '5': return -5;
                        case '6':
                        case '7': return +5;
                        case '8':
                        case '9': return +1;
                        case '10':
                        case 'J':
                        case 'Q':
                        case 'K': return 0;
                        default: return 0;
                    }
                }

                function calculateRunningCount() {
                    let totalCount = 0;
                    gameState.entries.forEach(card => {
                        totalCount += getCardCountContribution(card);
                    });
                    return totalCount;
                }

                function getPrediction() {
                    const currentCount = calculateRunningCount();
                    if (gameState.entries.length === 0) {
                        return { prediction: "no prediction", countResult: 0 };
                    }
                    let prediction = "";
                    if (currentCount === 0) {
                        prediction = "tie";
                    } else if (currentCount % 2 !== 0) {
                        prediction = "banker";
                    } else {
                        prediction = "player";
                    }
                    return { prediction: prediction, countResult: currentCount };
                }

                // Chart and UI updates for Card Counting
                function initChart() {
                    elements.chartArea.innerHTML = '<canvas id="myChart"></canvas>';
                    const ctx = document.getElementById('myChart');

                    const style = getComputedStyle(document.documentElement);
                    const primaryColor = style.getPropertyValue('--primary').trim();
                    const primaryColorRgba = `rgba(${parseInt(primaryColor.slice(1,3), 16)}, ${parseInt(primaryColor.slice(3,5), 16)}, ${parseInt(primaryColor.slice(5,7), 16)}, 0.1)`;

                    gameState.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Running Count',
                                data: [],
                                borderColor: primaryColor,
                                backgroundColor: primaryColorRgba,
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: primaryColor
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: '#fff',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return `Count: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: '#fff' }
                                },
                                y: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: '#fff' }
                                }
                            },
                            animation: {
                                duration: 1200,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updateChart() {
                    const labels = [];
                    const countData = [];
                    let tempCount = 0;
                    gameState.entries.forEach((card, index) => {
                        labels.push(`Card ${index + 1}`);
                        tempCount += getCardCountContribution(card);
                        countData.push(tempCount);
                    });

                    gameState.chart.data.labels = labels;
                    gameState.chart.data.datasets[0].data = countData;
                    gameState.chart.update();
                }

                function updateRoadmap() {
                    elements.roadmap.innerHTML = '';
                    gameState.entries.forEach((card, index) => {
                        const cell = document.createElement('div');
                        cell.className = `cell flex-shrink-0`;
                        cell.textContent = card === '10' ? '10/F' : card;
                        cell.style.animationDelay = `${index * 0.03}s`;

                        // Only apply prediction styling to the most recently added card's cell
                        if (index === gameState.entries.length - 1) {
                            const predictionResult = getPrediction();
                            if (predictionResult && predictionResult.prediction !== "no prediction") {
                                const prediction = predictionResult.prediction;
                                if (prediction === 'player') {
                                    cell.classList.add('predicted-player');
                                } else if (prediction === 'banker') {
                                    cell.classList.add('predicted-banker');
                                } else if (prediction === 'tie') {
                                    cell.classList.add('predicted-tie');
                                }
                                cell.title = `Card ${index + 1}: ${card} (Current Prediction: ${prediction.toUpperCase()})`;
                            }
                        } else {
                            cell.title = `Card ${index + 1}: ${card}`;
                        }
                        elements.roadmap.appendChild(cell);
                    });
                }

                function updateStats() {
                    const playerBets = gameState.predictionHistory.filter(p => p.prediction === 'player').length;
                    const bankerBets = gameState.predictionHistory.filter(p => p.prediction === 'banker').length;
                    const tieBets = gameState.predictionHistory.filter(p => p.prediction === 'tie').length;

                    elements.playerBets.textContent = playerBets;
                    elements.bankerBets.textContent = bankerBets;
                    elements.tieBets.textContent = tieBets;
                    elements.totalEntries.textContent = gameState.entries.length;

                    const totalCardsInShoe = gameState.totalDecks * 52;
                    const cardsRemaining = totalCardsInShoe - gameState.entries.length;
                    const decksRemaining = (cardsRemaining / 52).toFixed(2);
                    elements.decksRemaining.textContent = Math.max(0, parseFloat(decksRemaining));

                    elements.entriesNeeded.textContent = gameState.entries.length > 0 ? gameState.entries.length : 'N/A';
                    elements.countResultValue.textContent = calculateRunningCount();
                }

                function updateHistory() {
                    elements.historyList.innerHTML = '';
                    gameState.predictionHistory.slice().reverse().forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item';

                        const predictionNum = document.createElement('span');
                        predictionNum.textContent = `Hand ${gameState.predictionHistory.length - index}`;

                        const result = document.createElement('span');
                        result.className = `history-outcome ${item.prediction}`;
                        let outcomeText = item.prediction.charAt(0).toUpperCase() + item.prediction.slice(1);
                        if (item.countResult !== null) {
                            outcomeText += ` (Count: ${item.countResult})`;
                        }
                        result.textContent = outcomeText;

                        historyItem.appendChild(predictionNum);
                        historyItem.appendChild(result);
                        elements.historyList.appendChild(historyItem);
                    });
                }

                function updateRecommendation() {
                    const recommendationTextElement = elements.betRecommendation.querySelector('.recommendation-text');
                    const betAmountElement = elements.betAmount;
                    const countResultValueElement = elements.countResultValue;
                    const countDescElement = elements.countDesc;

                    if (gameState.entries.length === 0) {
                        recommendationTextElement.textContent = "Enter cards to see prediction";
                        recommendationTextElement.className = "recommendation-text no-bet";
                        betAmountElement.textContent = "";
                        countResultValueElement.textContent = "0";
                        countDescElement.textContent = "This is the numerical result from the counting system.";
                        elements.betRecommendation.classList.remove('animate-glow');
                        return;
                    }

                    const predictionResult = getPrediction();
                    const countResult = predictionResult.countResult;
                    const absCount = Math.abs(countResult);

                    let betMessage = `Bet ${predictionResult.prediction.charAt(0).toUpperCase() + predictionResult.prediction.slice(1)}`;
                    if (predictionResult.prediction !== "no prediction") {
                        betMessage += ` (Count: ${countResult})`;
                    } else {
                        betMessage = `No clear prediction yet. (Count: ${countResult})`;
                    }

                    recommendationTextElement.textContent = betMessage;
                    if (predictionResult.prediction === "no prediction") {
                        recommendationTextElement.className = "recommendation-text no-bet";
                    } else {
                        recommendationTextElement.className = "recommendation-text bet-suggestion";
                    }

                    // Fixed recommended bet for card counter section
                    const recommendedBet = 500;
                    betAmountElement.textContent = `Suggested Bet: $${recommendedBet.toLocaleString()}`;

                    countResultValueElement.textContent = countResult;

                    let description = "This is the numerical result from the counting system.";
                    if (countResult === 0) {
                        description = "Count is 0: Consider betting Tie, or wait for a clearer edge.";
                    } else if (absCount === 1) {
                        description = "Count is 1 (or -1): Slight edge, proceed with caution.";
                    } else if (absCount >= 2 && absCount <= 5) {
                        description = "Count is 2-5 (or -2 to -5): Moderate edge, increased bet suggested.";
                    } else if (absCount >= 6 && absCount <= 9) {
                        description = "Count is 6-9 (or -6 to -9): Significant edge, higher bets recommended.";
                    } else if (absCount >= 10 && absCount <= 14) {
                        description = "Count is 10-14 (or -10 to -14): Strong edge, significant bets advisable.";
                    } else if (absCount >= 15) {
                        description = "Count is 15+ (or -15+): Very strong edge, maximum bets recommended!";
                    }
                    countDescElement.textContent = description;

                    elements.betRecommendation.classList.add('animate-glow');
                    setTimeout(() => {
                        elements.betRecommendation.classList.remove('animate-glow');
                    }, 2000);

                    // Only add to history if there's a valid prediction (not "no prediction") and it's a new final state
                    if (predictionResult.prediction !== "no prediction" &&
                        (gameState.predictionHistory.length === 0 || 
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].prediction !== predictionResult.prediction ||
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].countResult !== predictionResult.countResult)) {
                        gameState.predictionHistory.push({
                            prediction: predictionResult.prediction,
                            countResult: predictionResult.countResult,
                            timestamp: new Date().toLocaleTimeString()
                        });
                        updateHistory();
                    }
                    updateChart();
                }

                // Add new card entry
                function addCardEntry(cardValue) {
                    gameState.entries.push(cardValue);
                    gameState.cardsDealt++;
                    updateStats();
                    updateRoadmap();
                    updateRecommendation();
                    displayMessage(`Card '${cardValue}' added.`, 'success');
                    playSound(cardSound);
                }

                // Clear all history and reset state for Card Counting
                function clearAllCardCounting() {
                    gameState.entries = [];
                    gameState.predictionHistory = [];
                    gameState.cardsDealt = 0;

                    updateRoadmap();
                    updateChart();
                    updateStats();
                    updateHistory();

                    elements.betRecommendation.querySelector('.recommendation-text').textContent = "Enter cards to see prediction";
                    elements.betRecommendation.querySelector('.recommendation-text').className = "recommendation-text no-bet";
                    elements.betAmount.textContent = "";
                    elements.countResultValue.textContent = "0";
                    elements.countDesc.textContent = "This is the numerical result from the counting system.";

                    displayMessage('Card Counting data cleared.', 'info');
                    playSound(clickSound);
                }

                // =============================================
                // Pattern Recognition Functions
                // =============================================
                function toggleDropdown(dropdownMenu) {
                    dropdownMenu.classList.toggle('show');
                    playSound(clickSound);
                }

                function selectPatternStrategy(strategy) {
                    if (gameState.currentPatternStrategy === strategy) {
                        elements.patternDropdownMenu.classList.remove('show');
                        return;
                    }

                    gameState.currentPatternStrategy = strategy;
                    elements.selectedPatternText.textContent = patternStrategies[strategy].name;
                    elements.patternDropdownMenu.classList.remove('show');
                    
                    elements.patternInputArea.classList.remove('hidden');
                    elements.patternAnalysisResult.classList.add('hidden');
                    elements.patternAnalysisResult.innerHTML = '';
                    
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;

                    gameState.bankrollTimeline = [];
                    updatePatternAnalysisChart();
                    elements.patternChartContainer.classList.add('hidden'); // Hide until progression is enabled

                    initMasanielloGrid(); // Always initialize Masaniello, even if not selected, for consistency
                    updatePatternDetails(); // This will show/hide Masaniello grid drawing
                    
                    initPatternOutcomeDistributionChart(); // Initialize and update pie chart
                    updatePatternOutcomeDistributionChart();
                    elements.patternOutcomeDistributionChartContainer.classList.remove('hidden'); // Show pie chart

                    playSound(clickSound);
                }

                function updatePatternDetails() {
                    let detailsHtml = '';
                    const currentStrategy = gameState.currentPatternStrategy;

                    // Only regenerate the full details HTML if the strategy has changed
                    if (currentStrategy !== gameState.lastPatternStrategyRendered) {
                        switch (currentStrategy) {
                            case 'patternMethod':
                                detailsHtml = `<p class="text-medium">This "General Pattern Method" provides an intuitive suggestion for your next bet. It adapts to the flow of the game to guide your decisions by tracking the overall win/loss ratio of Player and Banker outcomes.</p>`;
                                break;
                            case 'pbpbpbPattern':
                                detailsHtml = `<p class="text-medium">This strategy looks for a repeating Player-Banker-Player-Banker (PBPBPB) sequence. If identified, it suggests betting on the continuation of this alternating pattern. If the pattern is broken, it recommends a "sit-out".</p>
                                               <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="pbpbpbHistory" class="font-normal text-gray-300"></span></p>`;
                                break;
                            case 'dragonPattern':
                                detailsHtml = `<p class="text-medium">The Dragon Pattern strategy identifies streaks of three or more consecutive Player or Banker wins. It recommends betting on the continuation of the current streak. If no clear streak is found, it suggests a "sit-out".</p>
                                               <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="dragonHistory" class="font-normal text-gray-300"></span></p>`;
                                break;
                            case 'twosPattern':
                                detailsHtml = `<p class="text-medium">The Two-in-a-row Pattern strategy looks for sequences where an outcome appears twice, then switches (e.g., P P B, B B P). It anticipates a continuation of the *single* outcome (e.g., B for PPB, P for BBP). Otherwise, it suggests 'sit-out'.</p>
                                               <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="twosHistory" class="font-normal text-gray-300"></span></p>`;
                                break;
                            case 'masaniello':
                                detailsHtml = `<p class="text-medium">The Masaniello staking plan aims to maximize profit and manage risk within a series of bets. It requires setting an initial bankroll, a target profit, and the number of anticipated successful events. The chart guides your bet unit based on your current position (wins/losses).</p>
                                               <h4 class="font-semibold mt-4 text-medium">Masaniello Chart</h4>
                                               <p class="text-sm text-gray-500 mt-1">Current Position: [Col <span id="masanielloCurrentCol">${gameState.masanielloState.currentCol}</span>, Row <span id="masanielloCurrentRow">${gameState.masanielloState.currentRow}</span>]</p>
                                               <div class="masaniello-chart-container">
                                                   <div id="masanielloGrid" class="masaniello-grid"></div>
                                                   <div class="masaniello-legend">
                                                       <div class="legend-item"><span class="legend-color-box player-bg"></span> Player Bet</div>
                                                       <div class="legend-item"><span class="legend-color-box banker-bg"></span> Banker Bet</div>
                                                       <div class="legend-item"><span class="legend-color-box sit-out-bg"></span> Sit Out</div>
                                                   </div>
                                               </div>`;
                                break;
                            default:
                                detailsHtml = `<p class="text-center text-gray-400">Choose a pattern strategy from the dropdown above to see its description and controls.</p>`;
                        }
                        elements.patternStrategyDetails.innerHTML = detailsHtml;
                        gameState.lastPatternStrategyRendered = currentStrategy;
                    }

                    // Always update dynamic parts like history spans or Masaniello grid if visible
                    if (currentStrategy === 'pbpbpbPattern') {
                        const pbpbHistorySpan = document.getElementById('pbpbpbHistory');
                        if (pbpbHistorySpan) pbpbHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (currentStrategy === 'dragonPattern') {
                        const dragonHistorySpan = document.getElementById('dragonHistory');
                        if (dragonHistorySpan) dragonHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (currentStrategy === 'twosPattern') {
                        const twosHistorySpan = document.getElementById('twosHistory');
                        if (twosHistorySpan) twosHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    }
                    
                    if (currentStrategy === 'masaniello') {
                        drawMasanielloGrid(); // Always redraw Masaniello grid to reflect current position
                        // Update Masaniello current position text
                        const masanielloCurrentCol = document.getElementById('masanielloCurrentCol');
                        const masanielloCurrentRow = document.getElementById('masanielloCurrentRow');
                        if (masanielloCurrentCol) masanielloCurrentCol.textContent = gameState.masanielloState.currentCol;
                        if (masanielloCurrentRow) masanielloCurrentRow.textContent = gameState.masanielloState.currentRow;
                        // Also update the suggested bet within the patternAnalysisResult if Masaniello is active and its resultDiv is not hidden
                        const resultDiv = elements.patternAnalysisResult;
                        if (!resultDiv.classList.contains('hidden')) { 
                            const currentCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            let suggestedBetDisplay = currentCell.bet === 'sit-out' ? 'SIT OUT' : currentCell.bet.toUpperCase();
                            resultDiv.innerHTML = `<p class="text-light">Masaniello Chart displays your current staking position.</p>
                                                <p class="text-warning font-bold mt-2">Suggested Bet Unit: ${currentCell.value}</p>
                                                <p class="text-info font-bold mt-2">Suggested Bet Type: ${suggestedBetDisplay}</p>
                                                <p class="text-sm text-gray-500">Track your progress on the grid above.</p>`;
                        }
                    }
                    updatePatternAnalysis();
                }

                // Masaniello Grid Initialization and Drawing
                function initMasanielloGrid() {
                    gameState.masanielloState.grid = JSON.parse(JSON.stringify(masanielloGridConfig)); // Deep copy
                    // Start at bottom-most win-loss column (0 losses)
                    gameState.masanielloState.currentRow = masanielloGridConfig.length - 1; 
                    gameState.masanielloState.currentCol = 0; 
                }

                function drawMasanielloGrid() {
                    const gridElement = document.getElementById('masanielloGrid');
                    if (!gridElement) return;

                    gridElement.innerHTML = '';
                    // Iterate rows in reverse to draw from bottom up as in screenshot
                    for (let r = gameState.masanielloState.gridRows - 1; r >= 0; r--) {
                        for (let c = 0; c < gameState.masanielloState.gridCols; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'masaniello-cell';
                            const cellData = masanielloGridConfig[r][c]; // Use fixed config for cell data

                            cell.innerHTML = `<span class="value">${cellData.value}</span><span class="bet-type">${cellData.bet.replace('-', ' ').toUpperCase()}</span>`;

                            // Add background color class based on bet type
                            if (cellData.bet === 'player') {
                                cell.classList.add('player-bg');
                            } else if (cellData.bet === 'banker') {
                                cell.classList.add('banker-bg');
                            } else if (cellData.bet === 'sit-out') {
                                cell.classList.add('sit-out-bg');
                            }

                            if (r === gameState.masanielloState.currentRow && c === gameState.masanielloState.currentCol) {
                                cell.classList.add('active-position');
                            }
                            gridElement.appendChild(cell);
                        }
                    }
                    // Current position text updated in updatePatternDetails
                }

                function updateMasanielloPosition(outcome) {
                    let { currentRow, currentCol, gridRows, gridCols } = gameState.masanielloState;
                    const currentCell = masanielloGridConfig[currentRow][currentCol]; 

                    // Determine if the actual outcome resulted in a win, loss, or push for the current Masaniello bet type
                    let resultForMasaniello = 'push'; // Default to push for ties or sit-out
                    if (currentCell.bet === outcome) {
                        resultForMasaniello = 'win';
                    } else if (currentCell.bet !== 'sit-out' && outcome !== 'tie' && currentCell.bet !== outcome) {
                        resultForMasaniello = 'loss';
                    }
                    
                    if (resultForMasaniello === 'win') {
                        currentRow = Math.max(0, currentRow - 1); // Move up on win
                        currentCol = Math.max(0, currentCol - 1); // Move left on win, to previous loss count
                    } else if (resultForMasaniello === 'loss') {
                        currentCol = Math.min(gridCols - 1, currentCol + 1); // Move right on loss
                        currentRow = gridRows -1; // Reset to bottom row on loss (start of new cycle)
                    }
                    
                    // Clamp values to ensure they stay within grid boundaries
                    currentRow = Math.max(0, Math.min(gridRows - 1, currentRow));
                    currentCol = Math.max(0, Math.min(gridCols - 1, currentCol));

                    gameState.masanielloState.currentRow = currentRow;
                    gameState.masanielloState.currentCol = currentCol;
                    drawMasanielloGrid();
                }

                const patternStrategies = {
                    patternMethod: {
                        name: "General Pattern Method",
                        description: "This method tracks the overall win/loss ratio of Player and Banker outcomes. It suggests betting on the side with a higher historical probability or on a trend identified by majority wins. Ties are generally ignored for pattern analysis but affect theoretical bankroll.",
                        getRecommendation: () => {
                            const recentHistory = gameState.patternHistory.slice(-15);
                            if (recentHistory.length === 0) return 'sit-out';

                            const counts = { player: 0, banker: 0, tie: 0 };
                            recentHistory.forEach(outcome => {
                                counts[outcome]++;
                            });

                            if (counts.player > counts.banker) {
                                return 'player';
                            } else if (counts.banker > counts.player) {
                                return 'banker';
                            } else {
                                // If equal, or no clear majority, default to banker or sit-out
                                return 'banker'; 
                            }
                        }
                    },
                    pbpbpbPattern: {
                        name: "PBPBPB Pattern (Alternating)",
                        description: "This strategy looks for an alternating pattern (Player, Banker, Player, Banker...). If the last two outcomes were different (e.g., P then B), it predicts the next one will continue the alternation. If they were the same, it suggests a break in pattern and thus a 'sit-out' or 'no clear pattern'.",
                        getRecommendation: () => {
                            const historyLength = gameState.patternHistory.length;
                            if (historyLength < 2) return 'sit-out'; 

                            const lastOutcome = gameState.patternHistory[historyLength - 1];
                            const secondLastOutcome = gameState.patternHistory[historyLength - 2];

                            if (lastOutcome !== secondLastOutcome && lastOutcome !== 'tie' && secondLastOutcome !== 'tie') {
                                return lastOutcome === 'player' ? 'banker' : 'player';
                            }
                            return 'sit-out';
                        }
                    },
                    dragonPattern: {
                        name: "Dragon Pattern (Streaks)",
                        description: "The Dragon Pattern focuses on streaks. If there have been 3 or more consecutive Player wins (Dragon Tail) or Banker wins (Banker Dragon), it suggests betting on that same side to continue the streak. Otherwise, it suggests 'sit-out'.",
                        getRecommendation: () => {
                            const history = gameState.patternHistory;
                            const historyLength = history.length;
                            if (historyLength < 3) return 'sit-out'; 

                            const lastOutcome = history[historyLength - 1];
                            const secondLastOutcome = history[historyLength - 2];
                            const thirdLastOutcome = history[historyLength - 3];

                            if (lastOutcome !== 'tie' && lastOutcome === secondLastOutcome && secondLastOutcome === thirdLastOutcome) {
                                return lastOutcome; 
                            }
                            return 'sit-out'; 
                        }
                    },
                    twosPattern: {
                        name: "Two-in-a-row Pattern",
                        description: "This strategy looks for outcomes occurring in pairs. If two of the same outcomes are followed by a switch (e.g., PPB or BBP), it anticipates a continuation of the *single* outcome (e.g., B for PPB, P for BBP). Otherwise, it suggests 'sit-out'.",
                        getRecommendation: () => {
                            const history = gameState.patternHistory;
                            const historyLength = history.length;
                            if (historyLength < 3) return 'sit-out'; 

                            const lastOutcome = history[historyLength - 1];
                            const secondLastOutcome = history[historyLength - 2];
                            const thirdLastOutcome = history[historyLength - 3];

                            if (thirdLastOutcome !== 'tie' && secondLastOutcome !== 'tie' && lastOutcome !== 'tie' &&
                                thirdLastOutcome === secondLastOutcome && thirdLastOutcome !== lastOutcome) {
                                return lastOutcome; 
                            }
                            return 'sit-out';
                        }
                    },
                    masaniello: {
                        name: "Masaniello Progression",
                        description: `Masaniello is a complex money management system that aims to maximize profits while limiting losses over a series of bets. It requires setting an initial bankroll, a target profit, and the number of anticipated successful events. The chart guides your bet unit based on your current position (wins/losses).`,
                        getRecommendation: () => {
                            const state = gameState.masanielloState;
                            if (state.grid.length === 0) return { bet: null, reason: "Masaniello grid not initialized. Please configure." };

                            const currentCell = masanielloGridConfig[state.currentRow][state.currentCol]; 
                            if (!currentCell) return { bet: 'sit-out', reason: "Invalid Masaniello grid position. Reset needed." }; 
                            
                            const betType = currentCell.bet;
                            const betValue = currentCell.value * state.unitIncrement;

                            if (betType === 'sit-out') {
                                return { bet: 'sit-out', reason: `Masaniello recommends sitting out. Next theoretical bet: $${betValue.toLocaleString()}.` };
                            } else {
                                return { bet: betType, reason: `Masaniello recommends betting ${betType.toUpperCase()}. Next theoretical bet: $${betValue.toLocaleString()}.` };
                            }
                        }
                    }
                };

                const bettingSystems = {
                    flatBetting: {
                        name: "Flat Betting",
                        description: "In Flat Betting, you wager the same amount (your base unit) on every hand, regardless of previous wins or losses. It's the simplest and lowest-risk system.",
                        getNextBet: () => gameState.patternBetting.flatBetAmount,
                        handleOutcome: (outcome, betTarget) => {
                            // No state change needed here for flat betting
                        },
                        reset: () => {
                            gameState.patternBetting.flatBetAmount = 1;
                        }
                    },
                    martingale: {
                        name: "Martingale",
                        description: "The Martingale system involves doubling your bet after every loss, aiming to recover all previous losses with a single win. After a win, you return to your original base bet. This system requires a large bankroll and can be risky.",
                        getNextBet: () => gameState.patternBetting.martingaleBet, 
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.martingaleBet = 1; 
                            } else if (outcome !== 'tie') { 
                                gameState.patternBetting.martingaleBet *= 2; 
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.martingaleBet = 1;
                        }
                    },
                    dalembert: {
                        name: "D'Alembert",
                        description: "The D'Alembert system is a negative progression strategy where you increase your bet by one unit after a loss and decrease it by one unit after a win. It's less aggressive than Martingale.",
                        getNextBet: () => Math.max(1, gameState.patternBetting.dalembertBet), 
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.dalembertBet = Math.max(1, gameState.patternBetting.dalembertBet - 1); 
                            } else if (outcome !== 'tie') { 
                                gameState.patternBetting.dalembertBet += 1; 
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.dalembertBet = 1;
                        }
                    },
                    fibonacci: {
                        name: "Fibonacci",
                        description: "The Fibonacci system uses the Fibonacci sequence (1, 1, 2, 3, 5, 8...) to determine bet amounts. After a loss, you move to the next number in the sequence. After a win, you move back two numbers. It's a less aggressive negative progression than Martingale.",
                        getNextBet: () => gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex], 
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.fibonacciIndex = Math.max(0, gameState.patternBetting.fibonacciIndex - 2);
                            } else if (outcome !== 'tie') { 
                                gameState.patternBetting.fibonacciIndex++;
                                if (gameState.patternBetting.fibonacciIndex >= gameState.patternBetting.fibonacciSequence.length) {
                                    const nextFib = gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex - 1] +
                                                    gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex - 2];
                                    gameState.patternBetting.fibonacciSequence.push(nextFib);
                                }
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.fibonacciSequence = [1, 1];
                            gameState.patternBetting.fibonacciIndex = 0;
                        }
                    }
                };
                
                // Record Pattern Outcome
                elements.patternOutcomeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const outcome = this.dataset.outcome;
                        recordPatternOutcome(outcome);
                        this.classList.add('animate__animated', 'animate__pulse');
                        setTimeout(() => this.classList.remove('animate__pulse'), 500);
                        playSound(clickSound);
                    });
                });

                // Clear Pattern History
                elements.clearPatternBtn.addEventListener('click', () => {
                    clearPatternHistory();
                    playSound(clickSound);
                });

                function recordPatternOutcome(outcome) {
                    gameState.patternHistory.push(outcome);
                    gameState.outcomeCounts[outcome]++;
                    displayMessage(`Outcome: ${outcome.toUpperCase()} recorded.`, 'info');

                    let bettingOutcomeType = null; 
                    let impliedBetTarget = null; 

                    const currentStrategy = patternStrategies[gameState.currentPatternStrategy];
                    const recommendationResult = currentStrategy.getRecommendation();
                    
                    if (typeof recommendationResult === 'string') {
                        impliedBetTarget = (recommendationResult === 'no_clear_pattern') ? 'sit-out' : recommendationResult;
                    } else if (typeof recommendationResult === 'object' && recommendationResult !== null && recommendationResult.bet) {
                        impliedBetTarget = recommendationResult.bet;
                    } else {
                        impliedBetTarget = 'sit-out';
                    }
                    
                    gameState.currentPatternRecommendation = impliedBetTarget; 

                    if (impliedBetTarget === 'sit-out') {
                        bettingOutcomeType = 'push'; 
                    } else if (outcome === 'tie') {
                        bettingOutcomeType = 'push'; 
                    } else if (impliedBetTarget === outcome) {
                        bettingOutcomeType = 'win';
                    } else {
                        bettingOutcomeType = 'loss';
                    }

                    if (gameState.currentPatternStrategy === 'masaniello') {
                        updateMasanielloPosition(outcome);
                    }

                    updatePatternAnalysis();
                    
                    if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem && impliedBetTarget !== null) {
                        updateTheoreticalBankroll(bettingOutcomeType, impliedBetTarget, outcome);
                    } else if (gameState.patternBetting.isEnabled && gameState.currentPatternStrategy && !gameState.patternBetting.currentSystem) {
                        displayMessage('Select a betting progression system to apply it automatically!', 'warning');
                    }
                    updatePatternChartsDebounced(); // Use debounced update for charts
                }

                function updatePatternAnalysis() {
                    const resultDiv = elements.patternAnalysisResult;
                    resultDiv.classList.remove('hidden');
                    resultDiv.innerHTML = '';

                    let recommendationText = '';
                    if (gameState.patternHistory.length === 0) {
                        resultDiv.innerHTML = `<p class="text-gray-400">No outcomes recorded yet. Enter Banker, Player, or Tie to start.</p>`;
                        return;
                    }

                    const currentStrategy = patternStrategies[gameState.currentPatternStrategy];
                    const recommendationResult = currentStrategy.getRecommendation();
                    
                    let actualRecommendation = '';
                    if (typeof recommendationResult === 'string') {
                        actualRecommendation = recommendationResult;
                    } else if (typeof recommendationResult === 'object' && recommendationResult !== null && recommendationResult.bet) {
                        actualRecommendation = recommendationResult.bet;
                    }

                    if (actualRecommendation === 'no_clear_pattern' || actualRecommendation === 'sit-out' || actualRecommendation === null) {
                        recommendationText = `Recommendation: <span class="text-gray-400 font-bold">NO CLEAR PATTERN / SIT OUT</span>`;
                    } else {
                        recommendationText = `Next recommended bet: <span class="text-success font-bold">${actualRecommendation.toUpperCase()}</span>`;
                    }
                    
                    resultDiv.innerHTML = `<p class="text-info mt-2">${recommendationText}</p>
                                           <p class="text-sm text-gray-500 mt-2">${currentStrategy.description}</p>`;

                    // Update dynamic history displays for relevant strategies
                    if (gameState.currentPatternStrategy === 'pbpbpbPattern') {
                        const pbpbHistorySpan = document.getElementById('pbpbpbHistory');
                        if (pbpbHistorySpan) pbpbHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (gameState.currentPatternStrategy === 'dragonPattern') {
                        const dragonHistorySpan = document.getElementById('dragonHistory');
                        if (dragonHistorySpan) dragonHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (gameState.currentPatternStrategy === 'twosPattern') {
                        const twosHistorySpan = document.getElementById('twosHistory');
                        if (twosHistorySpan) twosHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    }
                    
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        drawMasanielloGrid(); // Ensure grid is always updated
                        const currentCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                        let suggestedBetDisplay = currentCell.bet === 'sit-out' ? 'SIT OUT' : currentCell.bet.toUpperCase();
                        resultDiv.innerHTML = `<p class="text-light">Masaniello Chart displays your current staking position.</p>
                                            <p class="text-warning font-bold mt-2">Suggested Bet Unit: ${currentCell.value}</p>
                                            <p class="text-info font-bold mt-2">Suggested Bet Type: ${suggestedBetDisplay}</p>
                                            <p class="text-sm text-gray-500">Track your progress on the grid above.</p>`;
                    }

                    if (gameState.patternBetting.isEnabled) {
                        updatePatternNextBetDisplay();
                    }
                    // Do not call updatePatternCharts here, it's called by recordPatternOutcome
                }

                function clearPatternHistory() {
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;
                    displayMessage('Pattern history cleared.', 'info');
                    
                    initMasanielloGrid(); // Reset Masaniello state
                    updatePatternDetails(); 
                    
                    resetPatternBettingSystem(); // Reset betting progression state
                    updatePatternChartsDebounced(); // Clear pie chart
                }

                // Betting Progression Logic
                elements.enableBettingProgressionToggle.addEventListener('change', (event) => {
                    gameState.patternBetting.isEnabled = event.target.checked;
                    if (gameState.patternBetting.isEnabled) {
                        elements.patternBettingControls.classList.remove('hidden');
                        if (gameState.patternBetting.currentSystem) {
                            elements.patternBettingInputArea.classList.remove('hidden');
                            elements.patternChartContainer.classList.remove('hidden');
                            updatePatternNextBetDisplay(); 
                            updatePatternAnalysisChart();
                        }
                    } else {
                        elements.patternBettingControls.classList.add('hidden');
                        elements.patternBettingInputArea.classList.add('hidden');
                        elements.patternChartContainer.classList.add('hidden');
                    }
                    updatePatternChartsDebounced(); 
                });

                elements.setBetUnitValueBtn.addEventListener('click', () => {
                    const newValue = parseInt(elements.betUnitValueInput.value);
                    if (!isNaN(newValue) && newValue > 0) {
                        gameState.patternBetting.bettingUnitValue = newValue;
                        displayMessage(`Betting unit set to $${newValue}.`, 'success');
                        updatePatternNextBetDisplay();
                    } else {
                        displayMessage('Betting unit must be a positive number.', 'error');
                    }
                    playSound(clickSound);
                });

                // FIX: Add event listener to the pattern dropdown button
                elements.patternDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.patternDropdownMenu);
                });

                elements.bettingProgressionDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.bettingProgressionDropdownMenu);
                });

                elements.patternDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        const strategyKey = event.target.dataset.strategy;
                        selectPatternStrategy(strategyKey);
                    }
                });

                elements.bettingProgressionDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        const systemKey = event.target.dataset.system;
                        gameState.patternBetting.currentSystem = systemKey;
                        elements.selectedBettingProgressionText.textContent = bettingSystems[systemKey].name;
                        elements.bettingProgressionDropdownMenu.classList.remove('show');

                        updatePatternBettingSystemDetails();

                        elements.patternBettingInputArea.classList.remove('hidden');
                        elements.patternChartContainer.classList.remove('hidden');
                        
                        resetPatternBettingSystem(); 
                        updatePatternNextBetDisplay();
                        updatePatternChartsDebounced(); // Use debounced update for charts
                        playSound(clickSound);
                    }
                });

                elements.patternResetBettingBtn.addEventListener('click', () => {
                    resetPatternBettingSystem();
                    updatePatternChartsDebounced(); // Use debounced update for charts
                    displayMessage('Betting system reset.', 'info');
                    playSound(clickSound);
                });

                function resetPatternBettingSystem() {
                    gameState.patternBetting.martingaleBet = 1;
                    gameState.patternBetting.dalembertBet = 1;
                    gameState.patternBetting.fibonacciSequence = [1, 1];
                    gameState.patternBetting.fibonacciIndex = 0;
                    gameState.patternBetting.flatBetAmount = 1;
                    gameState.patternBetting.theoreticalBankroll = 10000;
                    gameState.bankrollTimeline = [];

                    if (gameState.currentPatternStrategy === 'masaniello') {
                        gameState.masanielloState.currentRow = masanielloGridConfig.length - 1; 
                        gameState.masanielloState.currentCol = 0;
                        drawMasanielloGrid(); 
                    }
                    
                    updatePatternNextBetDisplay();
                    updatePatternAnalysisChart(); 
                }
                
                function updateTheoreticalBankroll(bettingOutcomeType, impliedBetTarget, actualOutcome) {
                    let betUnits = 0;
                    const pb = gameState.patternBetting;

                    if (impliedBetTarget === 'sit-out') {
                        displayMessage('Theoretical push (strategy recommended sit out). Bankroll unchanged.', 'info');
                        gameState.bankrollTimeline.push({
                            outcomeIndex: gameState.patternHistory.length,
                            bankroll: pb.theoreticalBankroll, 
                            actualOutcome: actualOutcome,
                            betAmount: 0, 
                            betTarget: impliedBetTarget
                        });
                        updatePatternNextBetDisplay(); 
                        updatePatternAnalysisChart();
                        return;
                    }

                    switch (pb.currentSystem) {
                        case 'flatBetting': betUnits = pb.flatBetAmount; break;
                        case 'martingale': betUnits = pb.martingaleBet; break;
                        case 'dalembert': betUnits = pb.dalembertBet; break;
                        case 'fibonacci': betUnits = pb.fibonacciSequence[pb.fibonacciIndex]; break;
                        case 'masaniello':
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            betUnits = currentMasanielloCell ? currentMasanielloCell.value : 0; 
                            break;
                        default:
                            betUnits = 0; 
                    }
                    
                    const betAmountDollars = betUnits * pb.bettingUnitValue;

                    if (betAmountDollars > pb.theoreticalBankroll && bettingOutcomeType === 'loss') {
                        displayMessage(`Theoretical bankroll ($${pb.theoreticalBankroll.toLocaleString()}) insufficient for next ${betUnits} unit bet ($${betAmountDollars.toFixed(2)}). Resetting betting system.`, 'error');
                        playSound(errorSound);
                        resetPatternBettingSystem();
                        return;
                    }

                    let winLossAmount = 0;
                    if (bettingOutcomeType === 'win') {
                        if (impliedBetTarget === 'banker') {
                            winLossAmount = betAmountDollars * 0.95; 
                        } else if (impliedBetTarget === 'tie') {
                            winLossAmount = betAmountDollars * 8; 
                        }
                        else { 
                            winLossAmount = betAmountDollars;
                        }
                        pb.theoreticalBankroll += winLossAmount;
                        displayMessage(`Theoretical WIN of $${winLossAmount.toFixed(2)}. Theoretical Bankroll: $${pb.theoreticalBankroll.toLocaleString()}.`, 'success');
                        playSound(winSound);
                        
                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                            bettingSystems[pb.currentSystem].handleOutcome('win', impliedBetTarget);
                        }

                    } else if (bettingOutcomeType === 'loss') {
                        winLossAmount = -betAmountDollars;
                        pb.theoreticalBankroll += winLossAmount; 
                        displayMessage(`Theoretical LOSS of $${betAmountDollars.toFixed(2)}. Theoretical Bankroll: $${pb.theoreticalBankroll.toLocaleString()}.`, 'error');
                        playSound(loseSound);

                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                            bettingSystems[pb.currentSystem].handleOutcome('loss', impliedBetTarget);
                        }
                    } else { 
                        displayMessage('Theoretical push. Bankroll unchanged.', 'info');
                        winLossAmount = 0; 
                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                             bettingSystems[pb.currentSystem].handleOutcome('push', impliedBetTarget);
                        }
                    }

                    gameState.bankrollTimeline.push({
                        outcomeIndex: gameState.patternHistory.length,
                        bankroll: pb.theoreticalBankroll,
                        actualOutcome: actualOutcome, 
                        betAmount: betAmountDollars,
                        betTarget: impliedBetTarget 
                    });
                    
                    updatePatternNextBetDisplay(); 
                    // Do not call updatePatternAnalysisChart here, it's handled by updatePatternChartsDebounced
                }

                function updatePatternNextBetDisplay() {
                    let nextBetUnits = 0;
                    let currentBaseInfo = '';
                    const pb = gameState.patternBetting;

                    if (!pb.currentSystem) {
                        elements.patternNextBetAmount.textContent = '0 units';
                        elements.patternCurrentBaseBet.textContent = 'N/A';
                        return;
                    }

                    if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].getNextBet) {
                        nextBetUnits = bettingSystems[pb.currentSystem].getNextBet();
                    } else if (pb.currentSystem === 'masaniello') {
                        const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                        nextBetUnits = currentMasanielloCell ? currentMasanielloCell.value : 0;
                    }

                    switch (pb.currentSystem) {
                        case 'flatBetting':
                            currentBaseInfo = `Base: ${pb.flatBetAmount} units`;
                            break;
                        case 'martingale':
                            currentBaseInfo = `Current Bet: ${pb.martingaleBet} units`;
                            break;
                        case 'dalembert':
                            currentBaseInfo = `Current Bet: ${pb.dalembertBet} units`;
                            break;
                        case 'fibonacci':
                            currentBaseInfo = `Current Index: ${pb.fibonacciIndex}`;
                            break;
                        case 'masaniello':
                            currentBaseInfo = `Current Position: [Col ${gameState.masanielloState.currentCol}, Row ${gameState.masanielloState.currentRow}]`;
                            break;
                        default:
                            currentBaseInfo = 'N/A';
                    }
                    elements.patternNextBetAmount.textContent = `${nextBetUnits.toLocaleString()} units ($${(nextBetUnits * pb.bettingUnitValue).toLocaleString()})`;
                    elements.patternCurrentBaseBet.textContent = currentBaseInfo;
                    elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`;
                }

                // Update betting system details section content
                function updatePatternBettingSystemDetails() {
                    let detailsHtml = '';
                    const system = gameState.patternBetting.currentSystem;
                    if (system && bettingSystems[system]) {
                        detailsHtml = `<p>${bettingSystems[system].description}</p>`;
                    } else {
                        detailsHtml = `<p class="text-center text-gray-400">Choose a betting system to manage your wagers.</p>`;
                    }
                    elements.patternBettingSystemDetails.innerHTML = detailsHtml;
                }

                // Charting for Pattern Recognition Tab (Bankroll Evolution)
                function initPatternAnalysisChart() {
                    if (gameState.patternAnalysisChartInstance) {
                        gameState.patternAnalysisChartInstance.destroy(); 
                    }
                    const ctx = elements.patternAnalysisChartCanvas.getContext('2d');
                    gameState.patternAnalysisChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [], 
                            datasets: [{
                                label: 'Theoretical Bankroll ($)',
                                data: [],
                                borderColor: 'var(--success)',
                                backgroundColor: 'rgba(0, 184, 148, 0.1)',
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 5,
                                pointBackgroundColor: (context) => {
                                    const dataPoint = context.raw;
                                    const actualOutcome = dataPoint.actualOutcome;
                                    const betTarget = dataPoint.betTarget;
                                    
                                    if (betTarget && actualOutcome) {
                                        if (betTarget === 'sit-out') return 'var(--text-medium)'; 
                                        if (actualOutcome === betTarget) return 'var(--success)'; 
                                        if (actualOutcome === 'tie') return 'var(--warning)'; 
                                        if (actualOutcome !== betTarget) return 'var(--danger)'; 
                                    }
                                    return 'var(--info)'; 
                                },
                                pointBorderColor: 'var(--light)',
                                pointHoverRadius: 7,
                                pointHoverBackgroundColor: 'var(--light)'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--text-light)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            const dataPoint = context.raw;
                                            return [
                                                `Bankroll: $${dataPoint.bankroll.toLocaleString()}`,
                                                `Actual Outcome: ${dataPoint.actualOutcome.toUpperCase() || 'N/A'}`,
                                                `Recommended Bet: ${dataPoint.betTarget ? dataPoint.betTarget.toUpperCase() : 'N/A'}`
                                            ];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Hands Played',
                                        color: 'var(--text-light)'
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--text-light)' }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Bankroll ($)',
                                        color: 'var(--text-light)'
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--text-light)' }
                                }
                            },
                            animation: {
                                duration: 1000,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updatePatternAnalysisChart() {
                    if (!gameState.patternAnalysisChartInstance) {
                        initPatternAnalysisChart();
                    }
                    const labels = gameState.bankrollTimeline.map((data, index) => `Hand ${index + 1}`);
                    const dataPoints = gameState.bankrollTimeline.map(data => ({
                        y: data.bankroll,
                        actualOutcome: data.actualOutcome,
                        betTarget: data.betTarget
                    }));

                    gameState.patternAnalysisChartInstance.data.labels = labels;
                    gameState.patternAnalysisChartInstance.data.datasets[0].data = dataPoints;
                    gameState.patternAnalysisChartInstance.update();
                }

                // Charting for Pattern Recognition Tab (Outcome Distribution Pie Chart)
                function initPatternOutcomeDistributionChart() {
                    if (gameState.patternOutcomeDistributionChartInstance) {
                        gameState.patternOutcomeDistributionChartInstance.destroy();
                    }
                    const ctx = elements.patternOutcomeDistributionChartCanvas.getContext('2d');
                    gameState.patternOutcomeDistributionChartInstance = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: ['Player', 'Banker', 'Tie'],
                            datasets: [{
                                data: [0, 0, 0], // Initial data
                                backgroundColor: ['var(--info)', 'var(--danger)', 'var(--warning)'],
                                borderColor: 'var(--panel-bg)',
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'right',
                                    labels: {
                                        color: 'var(--text-light)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || '';
                                            const value = context.raw;
                                            const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                            const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                            return `${label}: ${value} (${percentage}%)`;
                                        }
                                    }
                                }
                            },
                            animation: {
                                animateRotate: true,
                                animateScale: true
                            }
                        }
                    });
                }

                function updatePatternOutcomeDistributionChart() {
                    if (!gameState.patternOutcomeDistributionChartInstance) {
                        initPatternOutcomeDistributionChart();
                    }
                    const data = [
                        gameState.outcomeCounts.player,
                        gameState.outcomeCounts.banker,
                        gameState.outcomeCounts.tie
                    ];
                    gameState.patternOutcomeDistributionChartInstance.data.datasets[0].data = data;
                    gameState.patternOutcomeDistributionChartInstance.update();
                }

                // Debounced function to update all charts in the Pattern Recognition tab
                function updatePatternChartsDebounced() {
                    clearTimeout(gameState.patternChartUpdateTimer);
                    gameState.patternChartUpdateTimer = setTimeout(() => {
                        // Always hide bankroll chart if betting progression is disabled or no system is selected
                        if (!gameState.patternBetting.isEnabled || !gameState.patternBetting.currentSystem) {
                            elements.patternChartContainer.classList.add('hidden');
                        } else {
                            elements.patternChartContainer.classList.remove('hidden');
                            updatePatternAnalysisChart();
                        }
                        // Pie chart visibility is separate
                        if (gameState.patternHistory.length > 0) {
                            elements.patternOutcomeDistributionChartContainer.classList.remove('hidden');
                            updatePatternOutcomeDistributionChart();
                        } else {
                            elements.patternOutcomeDistributionChartContainer.classList.add('hidden');
                        }
                    }, 150); // Debounce by 150ms
                }

                // Initial pattern setup
                updatePatternDetails(); 
                updatePatternBettingSystemDetails(); 
                updatePatternChartsDebounced(); // Call once at init to set initial visibility

                // =============================================
                // Mini-Game Functions
                // =============================================

                function initializeDeck() {
                    const suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades'];
                    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    let newDeck = [];
                    for (let i = 0; i < 8; i++) { // 8 decks
                        suits.forEach(suit => {
                            ranks.forEach(rank => {
                                newDeck.push({ rank: rank, suit: suit });
                            });
                        });
                    }
                    gameState.deck = newDeck;
                    shuffleDeck();
                }

                function shuffleDeck() {
                    for (let i = gameState.deck.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]]; // ES6 swap
                    }
                }

                function dealCard() {
                    if (gameState.deck.length === 0) {
                        displayMessage('Reshuffling deck!', 'info');
                        initializeDeck();
                    }
                    return gameState.deck.pop();
                }

                function getBaccaratCardValue(card) {
                    if (['10', 'J', 'Q', 'K'].includes(card.rank)) return 0;
                    if (card.rank === 'A') return 1;
                    return parseInt(card.rank);
                }

                function calculateBaccaratScore(hand) {
                    let score = 0;
                    hand.forEach(card => {
                        score += getBaccaratCardValue(card);
                    });
                    return score % 10;
                }

                function displayCards(hand, elementId) {
                    const cardListElement = document.getElementById(elementId);
                    cardListElement.innerHTML = '';
                    hand.forEach((card, index) => {
                        const cardItem = document.createElement('div');
                        cardItem.className = 'card-item';
                        cardItem.textContent = card.rank;
                        cardItem.style.animationDelay = `${index * 0.15}s`;
                        cardListElement.appendChild(cardItem);
                        playSound(cardSound);
                    });
                }

                function determineWinner(playerScore, bankerScore, playerHasThirdCard, bankerHasThirdCard) {
                    if (playerScore === bankerScore) return 'tie';

                    // Natural Wins (8 or 9 on first two cards)
                    // If either hand has a natural 8 or 9, no more cards are drawn.
                    // This is handled by the rules below implicitly by checking the score after all drawing rules.
                    
                    // Standard Baccarat Rules for determining winner after drawing
                    if (playerScore > bankerScore) {
                        return 'player';
                    } else {
                        return 'banker';
                    }
                }

                function dealHand() {
                    playSound(clickSound);
                    const betAmount = parseInt(elements.betAmountInput.value);
                    const betType = gameState.currentBet.type;

                    if (!betType) {
                        displayMessage('Please select a bet type (Player, Banker, or Tie).', 'warning');
                        playSound(errorSound);
                        return;
                    }

                    if (isNaN(betAmount) || betAmount <= 0) {
                        displayMessage('Please enter a valid bet amount.', 'warning');
                        playSound(errorSound);
                        return;
                    }
                    if (betAmount > gameState.miniGameBalance) {
                        displayMessage('Insufficient balance for this bet.', 'error');
                        playSound(errorSound);
                        return;
                    }

                    // Reset game area visuals
                    elements.playerCardList.innerHTML = '';
                    elements.bankerCardList.innerHTML = '';
                    elements.playerScore.textContent = '0';
                    elements.bankerScore.textContent = '0';
                    elements.gameResultDisplay.classList.add('hidden');

                    // Deduct bet from balance
                    gameState.miniGameBalance -= betAmount;
                    elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;

                    // Initialize hands
                    gameState.playerHand = [];
                    gameState.bankerHand = [];

                    // Deal initial two cards to Player and Banker
                    gameState.playerHand.push(dealCard());
                    gameState.bankerHand.push(dealCard());
                    gameState.playerHand.push(dealCard());
                    gameState.bankerHand.push(dealCard());

                    displayCards(gameState.playerHand, 'playerCardList');
                    displayCards(gameState.bankerHand, 'bankerCardList');

                    let playerScore = calculateBaccaratScore(gameState.playerHand);
                    let bankerScore = calculateBaccaratScore(gameState.bankerHand);

                    elements.playerScore.textContent = playerScore;
                    elements.bankerScore.textContent = bankerScore;

                    let playerDraws = false;
                    let bankerDraws = false;

                    // Baccarat Drawing Rules (Simplified - Player always acts first)
                    // Rule 1: If Player or Banker has a natural (8 or 9), no more cards are drawn.
                    if (playerScore >= 8 || bankerScore >= 8) {
                        // Naturals, no draw
                    } else if (playerScore <= 5) {
                        // Rule 2: If Player has 0-5, Player draws a third card.
                        playerDraws = true;
                        gameState.playerHand.push(dealCard());
                        setTimeout(() => {
                            displayCards(gameState.playerHand, 'playerCardList');
                            playerScore = calculateBaccaratScore(gameState.playerHand);
                            elements.playerScore.textContent = playerScore;
                        }, 700); // Delay for visual effect
                    }

                    // Banker's Third Card Rules (conditional on Player's third card or lack thereof)
                    // Use a timeout to ensure player's third card is visually dealt first
                    setTimeout(() => {
                        const playerThirdCardValue = playerDraws ? getBaccaratCardValue(gameState.playerHand[2]) : null;

                        if (bankerScore <= 2) {
                            bankerDraws = true;
                        } else if (bankerScore === 3) {
                            if (playerDraws && playerThirdCardValue !== 8) bankerDraws = true;
                            else if (!playerDraws) bankerDraws = true; // Banker draws if player did not draw
                        } else if (bankerScore === 4) {
                            if (playerDraws && [2, 3, 4, 5, 6, 7].includes(playerThirdCardValue)) bankerDraws = true;
                        } else if (bankerScore === 5) {
                            if (playerDraws && [4, 5, 6, 7].includes(playerThirdCardValue)) bankerDraws = true;
                        } else if (bankerScore === 6) {
                            if (playerDraws && [6, 7].includes(playerThirdCardValue)) bankerDraws = true;
                        }
                        // If Banker has 7, they stand. (No else needed here)

                        if (bankerDraws) {
                            gameState.bankerHand.push(dealCard());
                            setTimeout(() => {
                                displayCards(gameState.bankerHand, 'bankerCardList');
                                bankerScore = calculateBaccaratScore(gameState.bankerHand);
                                elements.bankerScore.textContent = bankerScore;
                                resolveGameOutcome(playerScore, bankerScore, betAmount, betType);
                            }, 700);
                        } else {
                            resolveGameOutcome(playerScore, bankerScore, betAmount, betType);
                        }
                    }, playerDraws ? 800 : 0); // Delay banker's action if player drew
                }

                function resolveGameOutcome(playerScore, bankerScore, betAmount, betType) {
                    const winner = determineWinner(playerScore, bankerScore);
                    let resultText = '';
                    let resultClass = '';
                    let winnings = 0;

                    if (winner === 'player') {
                        resultText = 'PLAYER WINS!';
                        resultClass = 'result-player';
                        if (betType === 'player') {
                            winnings = betAmount * 2; // Player bet pays 1:1
                            gameState.miniGameBalance += winnings;
                            playSound(winSound);
                        } else if (betType === 'banker') {
                             playSound(loseSound);
                        }
                    } else if (winner === 'banker') {
                        resultText = 'BANKER WINS!';
                        resultClass = 'result-banker';
                        if (betType === 'banker') {
                            winnings = betAmount * 1.95; // Banker bet pays 0.95:1 (5% commission)
                            gameState.miniGameBalance += winnings;
                            playSound(winSound);
                        } else if (betType === 'player') {
                             playSound(loseSound);
                        }
                    } else { // tie
                        resultText = 'IT\'S A TIE!';
                        resultClass = 'result-tie';
                        if (betType === 'tie') {
                            winnings = betAmount * 9; // Tie bet pays 8:1 (or 9:1 depending on casino)
                            gameState.miniGameBalance += winnings;
                            playSound(winSound);
                        } else { // Player or Banker bet results in a push on tie
                            gameState.miniGameBalance += betAmount; // Return the original bet
                            playSound(clickSound); // Neutral sound
                        }
                    }

                    elements.gameResultText.textContent = resultText;
                    elements.gameResultText.className = `game-result ${resultClass}`;
                    elements.gameNewBalance.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;
                    elements.gameResultDisplay.classList.remove('hidden');
                    elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;

                    if (gameState.miniGameBalance <= 0) {
                        displayMessage('Game Over! Your balance is 0. Resetting balance to $10,000.', 'error');
                        playSound(loseSound);
                        gameState.miniGameBalance = 10000;
                        elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;
                    }
                }
                
                // Event Listeners for Mini-Game
                elements.betOptionBtns.forEach(button => {
                    button.addEventListener('click', function() {
                        elements.betOptionBtns.forEach(btn => btn.classList.remove('active-bet')); 
                        this.classList.add('active-bet'); 
                        gameState.currentBet.type = this.dataset.betTarget;
                        displayMessage(`Selected to bet on ${gameState.currentBet.type.toUpperCase()}`, 'info');
                        playSound(clickSound);
                    });
                });

                elements.dealHandBtn.addEventListener('click', function() {
                    dealHand();
                    this.classList.add('animate__animated', 'animate__swing');
                    setTimeout(() => {
                        this.classList.remove('animate__swing');
                    }, 1000);
                });

                // Initial setup for the app
                initializeDeck(); // Mini-game deck setup
                startTimer();
                initChart(); // Card Counting chart
                updateRoadmap();
                updateStats();
                updateHistory();
                updateRecommendation();
                initMasanielloGrid(); // Masaniello grid for Pattern Recognition
                initPatternOutcomeDistributionChart(); // Initialise the outcome distribution chart

                // Event Listeners for Card Counting Tab
                elements.cardButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const cardValue = this.dataset.cardValue;
                        addCardEntry(cardValue);
                        this.classList.add('animate__animated', 'animate__rubberBand');
                        setTimeout(() => {
                            this.classList.remove('animate__rubberBand');
                        }, 1000);
                    });
                });

                elements.clearBtn.addEventListener('click', function() {
                    clearAllCardCounting();
                    this.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => {
                        this.classList.remove('animate__shakeX');
                    }, 1000);
                });

                // Tab Switching Logic
                elements.strategyTabs.addEventListener('click', function(event) {
                    if (event.target.classList.contains('tab-btn')) {
                        const clickedTab = event.target;
                        const targetTabId = clickedTab.dataset.tab;

                        elements.strategyTabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                        elements.tabContents.forEach(content => content.classList.remove('active'));

                        clickedTab.classList.add('active');
                        document.getElementById(targetTabId).classList.add('active');
                        playSound(clickSound);

                        // Logic specific to tab activation
                        if (targetTabId === 'cardCounting') {
                            updateChart();
                            updateRoadmap();
                            updateStats();
                            updateHistory();
                            updateRecommendation();
                        } else if (targetTabId === 'patternRecognition') {
                            updatePatternDetails(); // Re-render strategy details
                            updatePatternChartsDebounced(); // Update chart visibility and data
                            updatePatternNextBetDisplay(); // Ensure betting display is current
                        } else if (targetTabId === 'miniGame') {
                            // Mini-game might need a reset or visual clearing
                            elements.playerCardList.innerHTML = '';
                            elements.bankerCardList.innerHTML = '';
                            elements.playerScore.textContent = '0';
                            elements.bankerScore.textContent = '0';
                            elements.gameResultDisplay.classList.add('hidden');
                            initializeDeck(); // Re-initialize deck for fresh game
                        }
                    }
                });
            }

            // Initial check for authentication status on page load
            checkExistingAuth();
        });
    </script>
</body>
</html>
