<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat AI - Strategic Advisor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <style>
        :root {
            --primary: #7c3aed; /* Vibrant purple */
            --primary-dark: #5b21b6;
            --primary-light: #8b5cf6;
            --secondary: #10b981; /* Emerald green */
            --accent: #f43f5e; /* Rose red */
            --dark: #0f172a; /* Navy blue */
            --darker: #020617; /* Almost black */
            --light: #e2e8f0; /* Light gray */
            --lighter: #f8fafc; /* Almost white */
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
            
            /* Translucent backgrounds */
            --glass-bg: rgba(15, 23, 42, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
            --card-bg: rgba(30, 41, 59, 0.6);
            
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-tertiary: #64748b;
            
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.3);
            
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            background: none; /* Ensure no default body background, video will provide */
        }

        /* Video Background */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -2; /* Behind particles and main content */
            overflow: hidden;
            display: none; /* Hidden by default, shown after auth */
        }

        .video-background video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures video covers the entire area */
            pointer-events: none; /* Allows clicks to pass through to elements below */
        }

        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1; /* Above video, below content */
            /* Removed background from here as video provides it */
        }

        /* Auth Overlay */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(2, 6, 23, 0.85); /* Slightly more translucent */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(15px); /* More blur for the overlay */
            opacity: 1;
            transition: opacity 0.8s cubic-bezier(0.65, 0.05, 0.36, 1);
        }

        .auth-container {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.7), rgba(30, 41, 59, 0.7)); /* Translucent */
            padding: 3rem;
            border-radius: 1.5rem;
            width: 90%;
            max-width: 500px;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--glass-border);
            text-align: center;
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px); /* Apply blur to the container */
        }

        .auth-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                transparent 0%,
                rgba(124, 58, 237, 0.1) 50%,
                transparent 100%
            );
            transform: rotate(30deg);
            animation: shine 6s infinite linear;
        }

        @keyframes shine {
            0% { transform: rotate(30deg) translate(-30%, -30%); }
            100% { transform: rotate(30deg) translate(30%, 30%); }
        }

        .auth-title {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 900;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(124, 58, 237, 0.3);
        }

        .auth-title span {
            color: var(--primary-light);
        }

        .auth-input {
            width: 100%;
            padding: 1.2rem 1.5rem;
            margin-bottom: 1.5rem;
            border: none;
            border-radius: 0.75rem;
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
            outline: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .auth-input:focus {
            background: rgba(30, 41, 59, 0.7);
            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.3), inset 0 2px 4px rgba(0, 0, 0, 0.3);
            border-color: var(--primary);
        }

        .auth-btn {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            color: white;
            border: none;
            padding: 1.2rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .auth-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: var(--transition-slow);
        }

        .auth-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .auth-btn:hover::after {
            left: 100%;
        }

        .auth-message {
            margin-top: 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            display: none;
            animation: fadeIn 0.6s ease-out;
            padding: 0.8rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .auth-error {
            color: var(--danger);
            background-color: rgba(239, 68, 68, 0.15);
            border-color: var(--danger);
        }

        .auth-success {
            color: var(--success);
            background-color: rgba(16, 185, 129, 0.15);
            border-color: var(--success);
        }

        .key-info {
            margin-top: 2rem;
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .time-remaining {
            margin-top: 1.5rem;
            color: var(--warning);
            font-weight: 800;
            display: none;
            font-size: 1rem;
            animation: pulse 2s infinite;
        }

        /* Main Container */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            position: relative; /* Ensure it's above the video and particles */
            z-index: 10;
        }

        .container.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--glass-border);
            position: relative;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: flex;
            align-items: center;
            text-shadow: 0 0 20px rgba(124, 58, 237, 0.3);
            transition: var(--transition);
        }

        .logo:hover {
            transform: scale(1.02);
        }

        .logo span {
            color: var(--primary-light);
            margin-left: 0.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1.5rem; /* Space between time and volume */
        }

        .time-info {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 0.8rem 1.5rem;
            border-radius: 2rem;
            display: flex;
            align-items: center;
            box-shadow: var(--shadow-lg);
            font-size: 0.95rem;
            font-weight: 600;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            transition: var(--transition);
        }

        .time-info:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .time-label {
            opacity: 0.8;
            margin-right: 0.75rem;
            color: var(--text-secondary);
        }

        .time-value {
            color: var(--info);
            font-weight: 700;
        }
        
        .volume-control-btn {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 0.8rem 1.2rem;
            border-radius: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }
        .volume-control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            background: var(--primary-dark);
        }


        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
            flex-wrap: wrap;
            position: relative;
            z-index: 2;
        }

        .tab-btn {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            color: var(--text-primary);
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--glass-border);
            font-size: 0.95rem;
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(124, 58, 237, 0.2), transparent);
            transition: var(--transition-slow);
        }

        .tab-btn:hover {
            background: rgba(30, 41, 59, 0.7);
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .tab-btn.active {
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-color: var(--primary-light);
            box-shadow: 0 4px 6px rgba(124, 58, 237, 0.3);
            transform: translateY(-3px);
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.6s ease-out;
            position: relative;
        }

        .tab-content.active {
            display: block;
        }

        /* Panel Styles */
        .panel {
            background: var(--glass-bg); /* Translucent */
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px); /* Apply blur */
            border: 1px solid var(--glass-border);
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
            transition: var(--transition);
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px rgba(0, 0, 0, 0.2);
        }

        .panel-title {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            position: relative;
            display: inline-block;
        }

        .panel-title::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 3px;
        }

        /* Card Counting Layout */
        .card-counting-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
        }

        .chart-container {
            position: relative;
            overflow: hidden;
            min-height: 500px;
            border-radius: 0.75rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .chart-controls {
            display: flex;
            gap: 0.75rem;
        }

        .control-btn {
            background: rgba(30, 41, 59, 0.6); /* Translucent */
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .control-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-3px);
        }

        .chart-area {
            height: 350px;
            position: relative;
            width: 100%;
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .roadmap {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 0.75rem;
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.5); /* More translucent for background effect */
            border-radius: 0.75rem;
            overflow-x: auto;
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .roadmap::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .roadmap::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .roadmap::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .cell {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            background-color: rgba(30, 41, 59, 0.6); /* Translucent */
            color: var(--text-primary);
            position: relative;
            transition: var(--transition);
            box-shadow: var(--shadow-lg);
            border: 2px solid var(--glass-border);
            backdrop-filter: blur(3px); /* Apply blur */
        }

        .cell.predicted-player {
            background-color: var(--info);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .cell.predicted-banker {
            background-color: var(--danger);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .cell.predicted-tie {
            background-color: var(--warning);
            color: var(--darker);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* Analysis Panel */
        .analysis-panel {
            display: flex;
            flex-direction: column;
        }

        .bet-recommendation {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 2rem;
            border-radius: 0.75rem;
            margin-bottom: 2rem;
            text-align: center;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: var(--transition-slow);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .bet-recommendation::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                135deg,
                rgba(124, 58, 237, 0.1) 0%,
                rgba(244, 63, 94, 0.1) 100%
            );
            opacity: 0;
            transition: var(--transition-slow);
        }

        .bet-recommendation.active::before {
            opacity: 1;
        }

        .recommendation-text {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 0.75rem;
            animation: fadeIn 0.8s ease-out;
        }

        .no-bet {
            color: var(--text-secondary);
        }

        .bet-suggestion {
            color: var(--success);
            animation: pulse 2s infinite;
        }

        .bet-amount {
            font-size: 1.2rem;
            color: var(--warning);
            font-weight: 700;
        }

        .count-info {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 2rem;
            border-radius: 0.75rem;
            margin-bottom: 2rem;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .count-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary-light);
        }

        .count-result-value {
            font-size: 3rem;
            font-weight: 900;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            animation: bounceIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .count-desc {
            font-size: 0.95rem;
            opacity: 0.9;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-box {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .stat-box:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            animation: fadeIn 0.6s ease-out;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            color: var(--text-secondary);
        }

        .player-stat .stat-value { color: var(--info); }
        .banker-stat .stat-value { color: var(--danger); }
        .tie-stat .stat-value { color: var(--warning); }

        .input-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .card-btn {
            padding: 1rem 0.5rem;
            border-radius: 0.5rem;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(30, 41, 59, 0.6); /* Translucent */
            color: var(--text-primary);
            font-size: 1.1rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .card-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .clear-btn-container {
            text-align: center;
            margin-top: 1.5rem;
        }

        .btn-secondary {
            background: rgba(30, 41, 59, 0.6); /* Translucent */
            color: var(--text-primary);
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--glass-border);
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .btn-secondary:hover {
            background: rgba(59, 130, 246, 0.7);
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .history-container {
            margin-top: auto;
            padding-top: 2rem;
            border-top: 1px solid var(--glass-border);
        }

        .history-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary-light);
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 0.75rem;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(255, 255, 255, 0.1);
        }

        .history-list::-webkit-scrollbar {
            width: 8px;
        }

        .history-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .history-list::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95rem;
            animation: fadeIn 0.6s ease-out;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-outcome.player { color: var(--info); font-weight: 700; }
        .history-outcome.banker { color: var(--danger); font-weight: 700; }
        .history-outcome.tie { color: var(--warning); font-weight: 700; }

        /* Message Box */
        .message-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
            pointer-events: none;
        }

        .message-box {
            padding: 1rem 1.25rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
            pointer-events: auto;
            box-shadow: var(--shadow-xl);
            border: 1px solid;
            transform: translateX(100%);
            backdrop-filter: blur(10px);
        }

        .message-box.show {
            display: block;
            opacity: 1;
            transform: translateX(0);
        }

        .message-box.error {
            background-color: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border-color: var(--danger);
        }

        .message-box.success {
            background-color: rgba(16, 185, 129, 0.2);
            color: var(--success);
            border-color: var(--success);
        }

        .message-box.info {
            background-color: rgba(59, 130, 246, 0.2);
            color: var(--info);
            border-color: var(--info);
        }

        .message-box.warning {
            background-color: rgba(245, 158, 11, 0.2);
            color: var(--warning);
            border-color: var(--warning);
        }

        /* Pattern Recognition Tab */
        .strategy-content {
            padding: 2rem;
            text-align: center;
        }

        .strategy-content h3 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--primary-light);
            margin-bottom: 1.5rem;
        }

        .strategy-content p {
            font-size: 1rem;
            line-height: 1.7;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .dropdown-container {
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 300px;
        }

        .dropdown-button {
            background: rgba(30, 41, 59, 0.6); /* Translucent */
            color: var(--text-primary);
            padding: 0.8rem 1.25rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--glass-border);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .dropdown-button:hover {
            background: rgba(59, 130, 246, 0.7);
            transform: translateY(-3px);
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            background: var(--dark);
            border-radius: 0.75rem;
            box-shadow: var(--shadow-xl);
            z-index: 10;
            min-width: 100%;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            padding: 0.5rem 0;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            padding: 0.8rem 1.25rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
            text-align: left;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .dropdown-item:hover {
            background-color: var(--primary-dark);
            color: white;
        }

        /* Masaniello Chart */
        .masaniello-chart-container {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.4); /* More translucent */
            border-radius: 0.75rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .masaniello-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.5rem;
            width: fit-content;
            margin: 0 auto;
        }

        .masaniello-cell {
            width: 40px;
            height: 40px;
            background-color: rgba(30, 41, 59, 0.6); /* Translucent */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 0.5rem;
            color: var(--text-secondary);
            transition: var(--transition);
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(3px); /* Apply blur */
        }

        .masaniello-cell .value {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .masaniello-cell .bet-type {
            font-size: 0.65rem;
            opacity: 0.8;
        }

        .masaniello-cell.active-position {
            border: 2px solid var(--warning);
            box-shadow: 0 0 15px var(--warning);
            transform: scale(1.1);
            z-index: 2;
        }

        .masaniello-cell.player-bg { background-color: var(--info); color: white; }
        .masaniello-cell.banker-bg { background-color: var(--danger); color: white; }
        .masaniello-cell.sit-out-bg { background-color: var(--text-tertiary); color: var(--darker); }

        .masaniello-legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1.5rem;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color-box {
            width: 16px;
            height: 16px;
            border-radius: 0.25rem;
            margin-right: 0.5rem;
        }

        /* Mini-Game Styles */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            align-items: center;
            justify-content: center;
        }

        .game-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
        }

        .bet-option-btn {
            background: rgba(30, 41, 59, 0.6); /* Translucent */
            color: var(--text-primary);
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--glass-border);
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
            box-shadow: var(--shadow-lg);
            text-transform: uppercase;
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .bet-option-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .bet-option-btn.player-bet:hover { background-color: var(--info); }
        .bet-option-btn.banker-bet:hover { background-color: var(--danger); }
        .bet-option-btn.tie-bet:hover { background-color: var(--warning); color: var(--darker); }

        .bet-option-btn.active-bet {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            border-color: var(--primary-light);
            box-shadow: 0 4px 6px rgba(124, 58, 237, 0.3);
            transform: translateY(-3px);
        }

        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .bet-input {
            width: 120px;
            padding: 0.8rem;
            border-radius: 0.75rem;
            border: 1px solid var(--glass-border);
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
            text-align: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .deal-btn {
            background: linear-gradient(90deg, var(--success), #0d9d6e);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1.1rem;
            box-shadow: 0 4px 6px rgba(16, 185, 129, 0.3);
            margin-top: 1.5rem;
            width: 100%;
            max-width: 300px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .deal-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: var(--transition-slow);
        }

        .deal-btn:hover {
            background: linear-gradient(90deg, #0d9d6e, var(--success));
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(16, 185, 129, 0.4);
        }

        .deal-btn:hover::after {
            left: 100%;
        }

        .cards-display {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .player-hand, .banker-hand {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 1.5rem;
            border-radius: 0.75rem;
            width: 48%;
            min-width: 280px;
            text-align: center;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            transition: var(--transition);
            backdrop-filter: blur(5px); /* Apply blur */
        }

        .player-hand h3, .banker-hand h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .player-hand h3 { color: var(--info); }
        .banker-hand h3 { color: var(--danger); }

        .card-list {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
            min-height: 60px;
        }

        .card-item {
            background: rgba(30, 41, 59, 0.7);
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            animation: fadeIn 0.6s ease-out forwards;
            transition: var(--transition);
            position: relative;
            transform-style: preserve-3d;
            transform: perspective(500px);
            backdrop-filter: blur(3px); /* Apply blur */
        }

        .card-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            border-radius: 0.5rem;
        }

        .card-item:hover {
            transform: perspective(500px) rotateY(10deg) translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .hand-score {
            font-size: 2.5rem;
            font-weight: 900;
            margin-top: 1rem;
            animation: bounceIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .game-outcome-display {
            margin-top: 1.5rem;
            display: none;
            text-align: center;
        }

        .game-result {
            font-size: 2.5rem;
            font-weight: 900;
            animation: fadeIn 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .result-player { color: var(--info); }
        .result-banker { color: var(--danger); }
        .result-tie { color: var(--warning); }
        
        .game-outcome-display p {
            font-size: 1.1rem;
            margin-top: 0.75rem;
            color: var(--text-secondary);
        }

        /* Balance Display */
        .balance-info {
            background: rgba(15, 23, 42, 0.6); /* Translucent */
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--glass-border);
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            backdrop-filter: blur(5px); /* Apply blur */
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .card-counting-layout {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .panel {
                padding: 1.5rem;
            }
            
            .panel-title {
                font-size: 1.5rem;
            }
            
            .chart-area {
                height: 300px;
            }
            
            .bet-recommendation .recommendation-text {
                font-size: 1.5rem;
            }
            
            .count-result-value {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .auth-container {
                padding: 1.5rem;
            }
            
            .auth-title {
                font-size: 2rem;
            }
            
            .container {
                padding: 1rem;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
                padding-bottom: 1.5rem;
            }
            
            .logo {
                font-size: 2rem;
            }
            
            .header-controls {
                flex-direction: column;
                align-items: flex-start;
                width: 100%;
                gap: 0.75rem;
            }
            .time-info, .volume-control-btn {
                width: 100%;
                justify-content: center;
            }
            
            .tabs-nav {
                gap: 0.5rem;
            }
            
            .tab-btn {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
            }
            
            .panel {
                padding: 1.25rem;
            }
            
            .chart-title {
                font-size: 1.2rem;
            }
            
            .chart-controls {
                gap: 0.5rem;
            }
            
            .control-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
            }
            
            .roadmap {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
                gap: 0.5rem;
                padding: 1rem;
                max-height: 200px;
            }
            
            .cell {
                width: 40px;
                height: 40px;
                font-size: 0.9rem;
            }
            
            .bet-recommendation {
                padding: 1.5rem;
            }
            
            .recommendation-text {
                font-size: 1.3rem;
            }
            
            .bet-amount {
                font-size: 1rem;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .input-controls {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                gap: 0.75rem;
            }
            
            .card-btn {
                padding: 0.8rem 0.4rem;
                font-size: 1rem;
            }
            
            .player-hand, .banker-hand {
                width: 100%;
                padding: 1rem;
            }
            
            .game-result {
                font-size: 1.8rem;
            }
            
            .message-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 10px;
            }
            
            .message-box {
                padding: 0.8rem;
                font-size: 0.9rem;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.2); opacity: 0; }
            50% { transform: scale(1.15); opacity: 1; }
            70% { transform: scale(0.98); }
            100% { transform: scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.9; }
        }
        
        @keyframes pulse-glow {
            0% { opacity: 0.9; text-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
            50% { opacity: 1; text-shadow: 0 0 25px rgba(16, 185, 129, 1); }
            100% { opacity: 0.9; text-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
        }
        
        @keyframes rubberBand {
            from { transform: scale3d(1, 1, 1); }
            30% { transform: scale3d(1.25, 0.75, 1); }
            40% { transform: scale3d(0.75, 1.25, 1); }
            50% { transform: scale3d(1.15, 0.85, 1); }
            65% { transform: scale3d(0.95, 1.05, 1); }
            75% { transform: scale3d(1.05, 0.95, 1); }
            to { transform: scale3d(1, 1, 1); }
        }
        
        @keyframes flipInX {
            from { transform: perspective(400px) rotate3d(1, 0, 0, 90deg); opacity: 0; }
            40% { transform: perspective(400px) rotate3d(1, 0, 0, -20deg); }
            60% { transform: perspective(400px) rotate3d(1, 0, 0, 10deg); opacity: 1; }
            80% { transform: perspective(400px) rotate3d(1, 0, 0, -5deg); }
            to { transform: perspective(400px); }
        }
        
        /* Custom animations for cards */
        @keyframes dealCard {
            0% { transform: translateY(-100px) rotateY(180deg); opacity: 0; }
            100% { transform: translateY(0) rotateY(0); opacity: 1; }
        }
        
        @keyframes cardReveal {
            0% { transform: rotateY(0); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0); }
        }
    </style>
</head>
<body>
    <!-- Video Background -->
    <div class="video-background" id="videoBackground">
        <!-- Replaced YouTube iframe with a direct video tag -->
        <video autoplay loop muted playsinline id="backgroundVideo">
            <source src="https://cdn.discordapp.com/attachments/1337096277984415745/1387252775234179112/Tokyo_Ghoul_Opening_Unravel_7aMOurgDB-o.mp4?ex=685cab53&is=685b59d3&hm=eef92cb5b3aebe9956eb8f1f28662d7caba4d8fb0a7d966dea8478685a18b790&" type="video/mp4">
            Your browser does not support the video tag.
        </video>
    </div>
    
    <!-- Particles.js Background -->
    <div id="particles-js"></div>

    <!-- Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="auth-container">
            <h1 class="auth-title">Baccarat<span>AI</span></h1>
            <input type="text" class="auth-input" id="authKeyInput" placeholder="Enter your access key">
            <button class="auth-btn" id="authSubmitBtn">Authenticate</button>
            <div class="auth-message auth-error" id="authError"></div>
            <div class="auth-message auth-success" id="authSuccess">Authentication successful! Loading...</div>
            <div class="time-remaining" id="timeRemaining"></div>
            <div class="key-info">
                <p>Unlock premium features with an access key. Each key is limited to one device.</p>
                <p>Your key's remaining time will be displayed after successful authentication.</p>
            </div>
        </div>
    </div>

    <!-- Message Box for notifications -->
    <div class="message-container">
        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- Main Application Content -->
    <div class="container" id="mainContent">
        <header>
            <div class="logo">
                Baccarat<span>AI</span>
            </div>
            <div class="header-controls">
                <div class="time-info" id="timeContainer">
                    <span class="time-label">Time Left:</span>
                    <span class="time-value" id="timeValue">00:00:00</span>
                </div>
                <button id="volumeBtn" class="volume-control-btn">
                    <i class="fas fa-volume-up"></i> <span id="volumeText">100%</span>
                </button>
            </div>
        </header>

        <!-- Strategy Tabs -->
        <nav class="tabs-nav" id="strategyTabs">
            <button class="tab-btn active" data-tab="cardCounting">Card Counting</button>
            <button class="tab-btn" data-tab="patternRecognition">Pattern Recognition</button>
            <button class="tab-btn" data-tab="miniGame">Mini-Game</button>
        </nav>

        <!-- Card Counting Tab Content -->
        <div id="cardCounting" class="tab-content active">
            <div class="card-counting-layout">
                <div class="panel chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Baccarat Card Sequence & Trend</div>
                        <div class="chart-controls">
                            <button class="control-btn" id="bigRoadBtn">Big Road</button>
                            <button class="control-btn" id="beadPlateBtn">Bead Plate</button>
                            <button class="control-btn" id="derivativeBtn">Derivative</button>
                        </div>
                    </div>
                    <div class="chart-area" id="chartArea"></div>
                    <div class="roadmap" id="roadmap"></div>
                </div>

                <div class="panel analysis-panel">
                    <h2 class="panel-title">Card Counting Analysis</h2>

                    <div class="bet-recommendation" id="betRecommendation">
                        <div class="recommendation-text no-bet">Enter cards to see prediction</div>
                        <div class="bet-amount" id="betAmount"></div>
                    </div>

                    <div class="count-info">
                        <div class="count-title">Current Running Count:</div>
                        <div class="count-result-value" id="countResultValue">0</div>
                        <div class="count-desc">This is the numerical result from the counting system.</div>
                    </div>

                    <div class="stats-container">
                        <div class="stat-box player-stat">
                            <div class="stat-value" id="playerBets">0</div>
                            <div class="stat-label">Player Bets</div>
                        </div>
                        <div class="stat-box banker-stat">
                            <div class="stat-value" id="bankerBets">0</div>
                            <div class="stat-label">Banker Bets</div>
                        </div>
                        <div class="stat-box tie-stat">
                            <div class="stat-value" id="tieBets">0</div>
                            <div class="stat-label">Tie Bets</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="totalEntries">0</div>
                            <div class="stat-label">Total Cards Entered</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="entriesNeeded">N/A</div>
                            <div class="stat-label">Cards Needed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="decksRemaining">--</div>
                            <div class="stat-label">Decks Remaining (Est.)</div>
                        </div>
                    </div>

                    <div class="input-controls">
                        <button class="card-btn" data-card-value="A">A</button>
                        <button class="card-btn" data-card-value="2">2</button>
                        <button class="card-btn" data-card-value="3">3</button>
                        <button class="card-btn" data-card-value="4">4</button>
                        <button class="card-btn" data-card-value="5">5</button>
                        <button class="card-btn" data-card-value="6">6</button>
                        <button class="card-btn" data-card-value="7">7</button>
                        <button class="card-btn" data-card-value="8">8</button>
                        <button class="card-btn" data-card-value="9">9</button>
                        <button class="card-btn" data-card-value="10">10/F</button>
                    </div>
                    <div class="clear-btn-container">
                        <button class="btn-secondary" id="clearBtn">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>

                    <div class="history-container">
                        <div class="history-title">Prediction History</div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition Tab Content -->
        <div id="patternRecognition" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">Pattern Recognition & Betting Strategy</h2>
                <p>Analyze game outcomes and apply a betting progression based on patterns.</p>

                <div class="dropdown-container">
                    <button id="patternDropdownBtn" class="dropdown-button">
                        <span id="selectedPatternText">Select Pattern Method</span>
                        <i class="fas fa-caret-down"></i>
                    </button>
                    <div id="patternDropdownMenu" class="dropdown-menu">
                        <div class="dropdown-item" data-strategy="patternMethod">Pattern Method</div>
                        <div class="dropdown-item" data-strategy="pbpbpbPattern">PBPBPB Pattern</div>
                        <div class="dropdown-item" data-strategy="dragonPattern">Dragon Pattern (Streaks)</div>
                        <div class="dropdown-item" data-strategy="twosPattern">Two-in-a-row Pattern</div>
                        <div class="dropdown-item" data-strategy="masaniello">Masaniello</div>
                    </div>
                </div>

                <div id="patternStrategyDetails" class="mt-4 text-center">
                    <p class="text-secondary">Choose a pattern strategy from the dropdown above to see its description and controls.</p>
                </div>

                <div id="patternInputArea" class="hidden mt-6">
                    <h3 class="text-xl font-bold mb-4 text-primary-light">Record Game Outcome</h3>
                    <div class="grid grid-cols-3 gap-4 max-w-sm mx-auto">
                        <button class="btn-secondary" data-outcome="banker">Banker Won</button>
                        <button class="btn-secondary" data-outcome="player">Player Won</button>
                        <button class="btn-secondary" data-outcome="tie">Tie</button>
                    </div>
                    <button class="btn-secondary mt-4" id="clearPatternBtn">Clear History</button>
                </div>
                
                <div id="patternAnalysisResult" class="hidden mt-6">
                    <!-- Pattern specific analysis will be injected here -->
                </div>

                <div id="patternOutcomeDistributionChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title">Pattern Outcome Distribution</h4>
                    <canvas id="patternOutcomeDistributionChart"></canvas>
                </div>

                <div class="switch-container mt-6">
                    <label class="switch">
                        <input type="checkbox" id="enableBettingProgressionToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Enable Betting Progression</span>
                </div>

                <div class="hidden" id="patternBettingControls">
                    <h4 class="panel-title mt-6">Apply Betting Progression</h4>
                    <div class="flex flex-col items-center gap-4 mb-6">
                        <div class="dropdown-container">
                            <button id="bettingProgressionDropdownBtn" class="dropdown-button">
                                <span id="selectedBettingProgressionText">Select System</span>
                                <i class="fas fa-caret-down"></i>
                            </button>
                            <div id="bettingProgressionDropdownMenu" class="dropdown-menu">
                                <div class="dropdown-item" data-system="flatBetting">Flat Betting</div>
                                <div class="dropdown-item" data-system="martingale">Martingale</div>
                                <div class="dropdown-item" data-system="dalembert">D'Alembert</div>
                                <div class="dropdown-item" data-system="fibonacci">Fibonacci</div>
                            </div>
                        </div>
                        <div class="bet-unit-input-group flex items-center gap-2 max-w-xs w-full">
                            <label for="betUnitValueInput" class="text-light text-sm font-semibold">1 Unit = $</label>
                            <input type="number" id="betUnitValueInput" class="auth-input flex-grow" value="10" min="1" step="10">
                            <button class="btn-secondary px-4 py-2 text-sm" id="setBetUnitValueBtn">Set</button>
                        </div>
                    </div>

                    <div id="patternBettingSystemDetails" class="mt-4 text-center">
                        <p class="text-secondary">Choose a betting system to manage your wagers.</p>
                    </div>
                    <div id="patternBettingInputArea" class="hidden mt-6">
                        <p class="mt-4 text-light flex justify-center items-baseline">
                            <span class="text-secondary">Next Recommended Bet:</span>
                            <span id="patternNextBetAmount" class="text-warning font-bold ml-2">0 units</span>
                        </p>
                        <p class="text-sm text-secondary mt-2">Current Theoretical Bankroll: <span id="patternCurrentTheoreticalBankroll">$10,000</span></p>
                        <p class="text-sm text-secondary">Current Base Bet: <span id="patternCurrentBaseBet"></span></p>
                        <button class="btn-secondary mt-4" id="patternResetBettingBtn">Reset System</button>
                    </div>
                </div>
                
                <div id="patternChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title">Theoretical Bankroll Evolution</h4>
                    <canvas id="patternAnalysisChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Baccarat Mini-Game Tab Content -->
        <div id="miniGame" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">Baccarat Mini-Game</h2>
                <p>Place your bet and try your luck against the dealer!</p>

                <div class="balance-info">
                    <span class="balance-label">Your Balance:</span>
                    <span class="balance-value" id="miniGameBalanceDisplay">$10,000</span>
                </div>

                <div class="game-area">
                    <div class="game-controls">
                        <button class="bet-option-btn player-bet" data-bet-target="player">Bet Player</button>
                        <button class="bet-option-btn banker-bet" data-bet-target="banker">Bet Banker</button>
                        <button class="bet-option-btn tie-bet" data-bet-target="tie">Bet Tie</button>
                        <div class="bet-input-group">
                            <label for="betAmountInput" class="text-light">Amount:</label>
                            <input type="number" id="betAmountInput" class="bet-input" value="100" min="10">
                        </div>
                    </div>

                    <button class="deal-btn" id="dealHandBtn">Deal Hand</button>

                    <div class="cards-display mt-6">
                        <div class="player-hand">
                            <h3>Player Hand</h3>
                            <div class="card-list" id="playerCardList"></div>
                            <div class="hand-score" id="playerScore">0</div>
                        </div>
                        <div class="banker-hand">
                            <h3>Banker Hand</h3>
                            <div class="card-list" id="bankerCardList"></div>
                            <div class="hand-score" id="bankerScore">0</div>
                        </div>
                    </div>

                    <div class="game-outcome-display hidden" id="gameResultDisplay">
                        <h3 class="game-result" id="gameResultText"></h3>
                        <p class="text-lg mt-2">New Balance: <span id="gameNewBalance" class="font-bold text-warning"></span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let backgroundVideoElement; // Declare video element variable globally
        let currentVolume = 0.2; // Initialize with 20% volume (0.2 for video.volume)

        document.addEventListener('DOMContentLoaded', async function() {
            backgroundVideoElement = document.getElementById('backgroundVideo');

            // Initialize particles.js background
            particlesJS('particles-js', {
                "particles": {
                    "number": {
                        "value": 80,
                        "density": {
                            "enable": true,
                            "value_area": 800
                        }
                    },
                    "color": {
                        "value": "#7c3aed"
                    },
                    "shape": {
                        "type": "circle",
                        "stroke": {
                            "width": 0,
                            "color": "#000000"
                        },
                        "polygon": {
                            "nb_sides": 5
                        }
                    },
                    "opacity": {
                        "value": 0.3,
                        "random": false,
                        "anim": {
                            "enable": false,
                            "speed": 1,
                            "opacity_min": 0.1,
                            "sync": false
                        }
                    },
                    "size": {
                        "value": 3,
                        "random": true,
                        "anim": {
                            "enable": false,
                            "speed": 40,
                            "size_min": 0.1,
                            "sync": false
                        }
                    },
                    "line_linked": {
                        "enable": true,
                        "distance": 150,
                        "color": "#7c3aed",
                        "opacity": 0.2,
                        "width": 1
                    },
                    "move": {
                        "enable": true,
                        "speed": 2,
                        "direction": "none",
                        "random": false,
                        "straight": false,
                        "out_mode": "out",
                        "bounce": false,
                        "attract": {
                            "enable": false,
                            "rotateX": 600,
                            "rotateY": 1200
                        }
                    }
                },
                "interactivity": {
                    "detect_on": "canvas",
                    "events": {
                        "onhover": {
                            "enable": true,
                            "mode": "grab"
                        },
                        "onclick": {
                            "enable": true,
                            "mode": "push"
                        },
                        "resize": true
                    },
                    "modes": {
                        "grab": {
                            "distance": 140,
                            "line_linked": {
                                "opacity": 1
                            }
                        },
                        "bubble": {
                            "distance": 400,
                            "size": 40,
                            "duration": 2,
                            "opacity": 8,
                            "speed": 3
                        },
                        "repulse": {
                            "distance": 200,
                            "duration": 0.4
                        },
                        "push": {
                            "particles_nb": 4
                        },
                        "remove": {
                            "particles_nb": 2
                        }
                    }
                },
                "retina_detect": true
            });

            // =============================================
            // Authentication System (same as before)
            // =============================================
            const authOverlay = document.getElementById('authOverlay');
            const mainContent = document.getElementById('mainContent');
            const authKeyInput = document.getElementById('authKeyInput');
            const authSubmitBtn = document.getElementById('authSubmitBtn');
            const authError = document.getElementById('authError');
            const authSuccess = document.getElementById('authSuccess');
            const timeRemaining = document.getElementById('timeRemaining');
            const timeContainer = document.getElementById('timeContainer');
            const videoBackground = document.getElementById('videoBackground');
            const volumeBtn = document.getElementById('volumeBtn');
            const volumeText = document.getElementById('volumeText');


            // Predefined valid keys with expiration periods (in minutes)
            const validKeys = {
                "BAC-AI-2024-K1X7": { expiresIn: 525600 }, // 1 year
                "DEMO-KEY-1": { expiresIn: 60 },    // 60 minutes (1 hour)
                "DEMO-KEY-2": { expiresIn: 1440 },  // 1440 minutes (24 hours)
                "PRO-KEY-A": { expiresIn: 20480 },  // Approx 14 days
                "ULTRA-KEY-B": { expiresIn: 24480 } // Approx 17 days
            };

            // Check if a key is expired
            function isKeyExpired(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return true;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);

                return new Date() > expirationDate;
            }

            // Format time as HH:MM:SS
            function formatTime(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            // Calculate remaining time in seconds
            function getRemainingTime(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return 0;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                const now = new Date();

                return Math.max(0, Math.floor((expirationDate - now) / 1000));
            }

            // Enhanced device fingerprinting for security
            async function getDeviceFingerprint() {
                const components = [
                    navigator.userAgent,
                    navigator.platform,
                    navigator.hardwareConcurrency || 'unknown',
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    navigator.languages.join(','),
                    !!navigator.pdfViewerEnabled,
                    navigator.maxTouchPoints || 'unknown'
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('BaccaratAI', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('BaccaratAI', 4, 17);
                const canvasData = canvas.toDataURL();

                let webglData = 'unsupported';
                try {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        webglData = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + '|' +
                                   gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    }
                } catch (e) {}

                const combined = components.join('|') + '|' + canvasData + '|' + webglData;
                const msgBuffer = new TextEncoder().encode(combined);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                return 'fp-' + hashHex;
            }

            // Authentication handler with expiration check
            authSubmitBtn.addEventListener('click', async function() {
                const enteredKey = authKeyInput.value.trim();

                if (!validKeys.hasOwnProperty(enteredKey)) {
                    authError.textContent = "Invalid access key";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => {
                        authKeyInput.classList.remove('animate__animated', 'animate__shakeX');
                    }, 1000);
                    return;
                }

                let keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const deviceFingerprint = await getDeviceFingerprint();

                if (!keyRegistry[enteredKey]) {
                    const newKeyInfo = {
                        fingerprint: deviceFingerprint,
                        firstUsed: new Date().toISOString(),
                        lastUsed: new Date().toISOString(),
                        expiresIn: validKeys[enteredKey].expiresIn
                    };
                    keyRegistry[enteredKey] = newKeyInfo;
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else if (keyRegistry[enteredKey].fingerprint === deviceFingerprint) {
                    if (isKeyExpired(keyRegistry[enteredKey])) {
                        authError.textContent = "This key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                        setTimeout(() => {
                            authKeyInput.classList.remove('animate__animated', 'animate__shakeX');
                        }, 1000);
                        return;
                    }
                    keyRegistry[enteredKey].lastUsed = new Date().toISOString();
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else {
                    authError.textContent = "This key is already in use on another device";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => {
                        authKeyInput.classList.remove('animate__animated', 'animate__shakeX');
                    }, 1000);
                    return;
                }

                localStorage.setItem('baccaratAuthKey', enteredKey);
                localStorage.setItem('baccaratAuthFingerprint', deviceFingerprint);

                const keyInfo = keyRegistry[enteredKey];
                const remainingTimeSeconds = getRemainingTime(keyInfo);

                timeRemaining.textContent = `Expires in: ${formatTime(remainingTimeSeconds)}`;
                timeRemaining.style.display = 'block';

                authError.style.display = 'none';
                authSuccess.style.display = 'block';
                this.disabled = true;

                // Show video background and play
                videoBackground.style.display = 'block';
                if (backgroundVideoElement) {
                    backgroundVideoElement.muted = false; // Unmute
                    backgroundVideoElement.volume = currentVolume; // Set volume to 20%
                    backgroundVideoElement.play().catch(error => {
                        console.error('Video autoplay failed:', error);
                        displayMessage('Video autoplay blocked. Please tap to play.', 'warning');
                        // Optionally show a play button if autoplay fails
                    });
                }
                
                setTimeout(() => {
                    authOverlay.style.opacity = '0';
                    setTimeout(() => {
                        authOverlay.style.display = 'none';
                        mainContent.classList.add('show');
                        initApp(enteredKey);
                    }, 500);
                }, 1500);
            });

            // Check for existing auth on page load
            async function checkExistingAuth() {
                const savedKey = localStorage.getItem('baccaratAuthKey');
                const savedFingerprint = localStorage.getItem('baccaratAuthFingerprint');

                // Explicitly ensure the input is enabled and interactive
                authKeyInput.disabled = false;
                authKeyInput.readOnly = false;
                authKeyInput.style.pointerEvents = 'auto'; // Ensure pointer events are not blocked by CSS

                if (!savedKey || !savedFingerprint) {
                    // If no saved key, focus on the input to allow immediate entry
                    setTimeout(() => authKeyInput.focus(), 100); 
                    return false;
                }

                const currentFingerprint = await getDeviceFingerprint();
                if (savedFingerprint !== currentFingerprint) {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');
                    authError.textContent = "Authentication required: Device mismatch. Please re-enter your key.";
                    authError.style.display = 'block';
                    authKeyInput.value = savedKey; // Pre-fill if key exists but fingerprint mismatches
                    setTimeout(() => authKeyInput.focus(), 100); 
                    return false;
                }

                const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const keyInfo = keyRegistry[savedKey];

                if (keyInfo && keyInfo.fingerprint === currentFingerprint) {
                    if (isKeyExpired(keyInfo)) {
                        localStorage.removeItem('baccaratAuthKey');
                        localStorage.removeItem('baccaratAuthFingerprint');
                        authError.textContent = "Your access key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.value = savedKey; // Pre-fill expired key
                        setTimeout(() => authKeyInput.focus(), 100); 
                        return false;
                    }

                    keyInfo.lastUsed = new Date().toISOString();
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));

                    authOverlay.style.display = 'none';
                    mainContent.classList.add('show');
                    videoBackground.style.display = 'block'; // Show video if authentication is still valid
                    if (backgroundVideoElement) {
                        backgroundVideoElement.muted = false; // Unmute
                        backgroundVideoElement.volume = currentVolume; // Ensure current volume is maintained
                        backgroundVideoElement.play().catch(error => {
                            console.error('Video autoplay failed:', error);
                            displayMessage('Video autoplay blocked. Please tap to play.', 'warning');
                            // Optionally show a play button if autoplay fails
                        });
                    }
                    initApp(savedKey);
                    return true;
                }

                // If any other scenario, ensure input is ready for user to type
                setTimeout(() => authKeyInput.focus(), 100); 
                return false;
            }

            // Update volume display and icon
            function updateVolumeDisplay() {
                if (backgroundVideoElement) {
                    const volumePercentage = Math.round(backgroundVideoElement.volume * 100);
                    volumeText.textContent = `${volumePercentage}%`;
                    if (volumePercentage === 0 || backgroundVideoElement.muted) {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-off"></i> <span id="volumeText">Muted</span>';
                    } else if (volumePercentage <= 50) {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-down"></i> <span id="volumeText">' + volumePercentage + '%</span>';
                    } else {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-up"></i> <span id="volumeText">' + volumePercentage + '%</span>';
                    }
                }
            }

            // Volume control button logic
            volumeBtn.addEventListener('click', function() {
                if (backgroundVideoElement) {
                    let newVolume = Math.round(backgroundVideoElement.volume * 100) + 10; // Get current percentage, add 10

                    // Clamp to 20-100% or cycle back to 20%
                    if (newVolume > 100) {
                        newVolume = 20; // Loop back to min if max is reached
                        displayMessage('Volume reset to 20%.', 'info');
                    } else if (newVolume < 20) { // Should not be hit if starting at 20 and increasing
                        newVolume = 20;
                        displayMessage('Video volume cannot be set less than 20%.', 'warning');
                    } else {
                        displayMessage(`Volume set to ${newVolume}%.`, 'info');
                    }
                    
                    backgroundVideoElement.volume = newVolume / 100; // Set volume as a decimal
                    backgroundVideoElement.muted = false; // Ensure it's unmuted
                    currentVolume = newVolume / 100; // Update internal state
                    updateVolumeDisplay(); // Update UI
                }
            });


            // =============================================
            // Baccarat Core Application Functionality
            // =============================================
            function initApp(activeKey) {
                const gameState = {
                    entries: [],
                    predictionHistory: [],
                    miniGameBalance: 10000,
                    chart: null,
                    activeKey: activeKey,
                    timer: null,
                    totalDecks: 8,
                    cardsDealt: 0,
                    
                    patternBetting: {
                        currentSystem: null,
                        bettingUnitValue: 10,
                        martingaleBet: 1,
                        dalembertBet: 1,
                        fibonacciSequence: [1, 1],
                        fibonacciIndex: 0,
                        flatBetAmount: 1,
                        theoreticalBankroll: 10000,
                        isEnabled: false
                    },

                    currentPatternStrategy: null,
                    patternHistory: [],
                    currentPatternRecommendation: null,
                    outcomeCounts: { player: 0, banker: 0, tie: 0 },
                    masanielloState: {
                        grid: [],
                        gridRows: 10,
                        gridCols: 10,
                        currentRow: 0,
                        currentCol: 0,
                        unitIncrement: 10
                    },
                    patternAnalysisChartInstance: null,
                    bankrollTimeline: [],
                    patternOutcomeDistributionChartInstance: null,
                    
                    deck: [],
                    playerHand: [],
                    bankerHand: [],
                    currentBet: { type: null, amount: 0 }
                };

                const masanielloGridConfig = [
                    [{value: 0, bet: 'sit-out'}, {value: 1, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 1, bet: 'banker'}, {value: 0, bet: 'banker'}],
                    [{value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 1, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}],
                    [{value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 2, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 6, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}],
                    [{value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 6, bet: 'player'}, {value: 4, bet: 'player'}],
                    [{value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 7, bet: 'player'}, {value: 9, bet: 'player'}, {value: 11, bet: 'player'}, {value: 8, 'bet': 'player'}],
                    [{value: 5, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 3, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}],
                    [{value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    [{value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 9, bet: 'player'}, {value: 8, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    [{value: 1, bet: 'player'}, {value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 8, bet: 'player'}, {value: 11, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}],
                    [{value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 1, bet: 'sit-out'}, {value: 2, bet: 'sit-out'}, {value: 4, bet: 'sit-out'}, {value: 8, bet: 'sit-out'}, {value: 15, bet: 'sit-out'}, {value: 30, bet: 'sit-out'}, {value: 61, bet: 'sit-out'}]
                ];

                const elements = {
                    roadmap: document.getElementById('roadmap'),
                    chartArea: document.getElementById('chartArea'),
                    messageBox: document.getElementById('messageBox'),
                    strategyTabs: document.getElementById('strategyTabs'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    timeValue: document.getElementById('timeValue'),

                    betRecommendation: document.getElementById('betRecommendation'),
                    betAmount: document.getElementById('betAmount'),
                    countResultValue: document.getElementById('countResultValue'),
                    countDesc: document.getElementById('countDesc'),
                    playerBets: document.getElementById('playerBets'),
                    bankerBets: document.getElementById('bankerBets'),
                    tieBets: document.getElementById('tieBets'),
                    totalEntries: document.getElementById('totalEntries'),
                    entriesNeeded: document.getElementById('entriesNeeded'),
                    decksRemaining: document.getElementById('decksRemaining'),
                    cardButtons: document.querySelectorAll('.card-btn'),
                    clearBtn: document.getElementById('clearBtn'),
                    historyList: document.getElementById('historyList'),

                    patternDropdownBtn: document.getElementById('patternDropdownBtn'),
                    selectedPatternText: document.getElementById('selectedPatternText'),
                    patternDropdownMenu: document.getElementById('patternDropdownMenu'),
                    patternStrategyDetails: document.getElementById('patternStrategyDetails'),
                    patternInputArea: document.getElementById('patternInputArea'),
                    patternOutcomeButtons: document.querySelectorAll('#patternInputArea .btn-secondary'),
                    clearPatternBtn: document.getElementById('clearPatternBtn'),
                    patternAnalysisResult: document.getElementById('patternAnalysisResult'),
                    patternBettingControls: document.getElementById('patternBettingControls'),
                    enableBettingProgressionToggle: document.getElementById('enableBettingProgressionToggle'),
                    patternCurrentTheoreticalBankroll: document.getElementById('patternCurrentTheoreticalBankroll'),

                    bettingProgressionDropdownBtn: document.getElementById('bettingProgressionDropdownBtn'),
                    selectedBettingProgressionText: document.getElementById('selectedBettingProgressionText'),
                    bettingProgressionDropdownMenu: document.getElementById('bettingProgressionDropdownMenu'),
                    patternBettingSystemDetails: document.getElementById('patternBettingSystemDetails'),
                    patternBettingInputArea: document.getElementById('patternBettingInputArea'),
                    patternNextBetAmount: document.getElementById('patternNextBetAmount'),
                    patternCurrentBaseBet: document.getElementById('patternCurrentBaseBet'),
                    patternResetBettingBtn: document.getElementById('patternResetBettingBtn'),
                    betUnitValueInput: document.getElementById('betUnitValueInput'),
                    setBetUnitValueBtn: document.getElementById('setBetUnitValueBtn'),
                    patternAnalysisChartCanvas: document.getElementById('patternAnalysisChart'),
                    patternChartContainer: document.getElementById('patternChartContainer'),
                    patternOutcomeDistributionChartCanvas: document.getElementById('patternOutcomeDistributionChart'),
                    patternOutcomeDistributionChartContainer: document.getElementById('patternOutcomeDistributionChartContainer'),

                    miniGameBalanceDisplay: document.getElementById('miniGameBalanceDisplay'),
                    betOptionBtns: document.querySelectorAll('.bet-option-btn'),
                    betAmountInput: document.getElementById('betAmountInput'),
                    dealHandBtn: document.getElementById('dealHandBtn'),
                    playerCardList: document.getElementById('playerCardList'),
                    bankerCardList: document.getElementById('bankerCardList'),
                    playerScore: document.getElementById('playerScore'),
                    bankerScore: document.getElementById('bankerScore'),
                    gameResultDisplay: document.getElementById('gameResultDisplay'),
                    gameResultText: document.getElementById('gameResultText'),
                    gameNewBalance: document.getElementById('gameNewBalance')
                };

                // Display a temporary message
                function displayMessage(message, type) {
                    elements.messageBox.textContent = message;
                    elements.messageBox.className = `message-box show ${type} animate__animated animate__fadeInRight`;
                    
                    setTimeout(() => {
                        elements.messageBox.classList.remove('show');
                        elements.messageBox.classList.add('animate__animated', 'animate__fadeOutRight');
                        setTimeout(() => {
                            elements.messageBox.textContent = '';
                            elements.messageBox.classList.remove('animate__fadeOutRight');
                        }, 500);
                    }, 3000);
                }

                // Start the countdown timer
                function startTimer() {
                    if (gameState.timer) clearInterval(gameState.timer);

                    updateTimerDisplay();

                    gameState.timer = setInterval(() => {
                        const remaining = updateTimerDisplay();
                        if (remaining <= 0) {
                            clearInterval(gameState.timer);
                            handleKeyExpiration();
                        }
                    }, 1000);
                }

                // Update the timer display and return remaining seconds
                function updateTimerDisplay() {
                    const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                    const keyInfo = keyRegistry[gameState.activeKey];
                    if (!keyInfo) return 0;

                    const expirationDate = new Date(keyInfo.firstUsed);
                    expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                    const now = new Date();
                    const remaining = Math.max(0, Math.floor((expirationDate - now) / 1000));
                    
                    elements.timeValue.textContent = formatTime(remaining);

                    if (remaining <= 300) {
                        elements.timeValue.style.color = 'var(--danger)';
                        timeContainer.classList.add('animate__animated', 'animate__pulse');
                    } else if (remaining <= 900) {
                        elements.timeValue.style.color = 'var(--warning)';
                        timeContainer.classList.remove('animate__pulse');
                    } else {
                        elements.timeValue.style.color = 'var(--info)';
                        timeContainer.classList.remove('animate__pulse');
                    }
                    return remaining;
                }

                // Handle key expiration
                function handleKeyExpiration() {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');

                    mainContent.classList.remove('show');
                    authOverlay.style.display = 'flex';
                    authOverlay.style.opacity = '1';
                    authError.textContent = "Your access key has expired. Please renew your subscription.";
                    authError.style.display = 'block';
                    authKeyInput.value = gameState.activeKey;
                    timeRemaining.style.display = 'none';
                    authSubmitBtn.disabled = false;
                    videoBackground.style.display = 'none'; // Hide video on expiration
                    displayMessage('Your session has expired. Please authenticate again.', 'error');
                }

                // Card counting logic
                function getCardCountContribution(cardValue) {
                    switch (cardValue) {
                        case 'A': return -1;
                        case '2':
                        case '3': return -1;
                        case '4':
                        case '5': return -5;
                        case '6':
                        case '7': return +5;
                        case '8':
                        case '9': return +1;
                        case '10':
                        case 'J':
                        case 'Q':
                        case 'K': return 0;
                        default: return 0;
                    }
                }

                function calculateRunningCount() {
                    let totalCount = 0;
                    gameState.entries.forEach(card => {
                        totalCount += getCardCountContribution(card);
                    });
                    return totalCount;
                }

                function getPrediction() {
                    const currentCount = calculateRunningCount();
                    if (gameState.entries.length === 0) {
                        return { prediction: "no prediction", countResult: 0 };
                    }
                    let prediction = "";
                    if (currentCount === 0) {
                        prediction = "tie";
                    } else if (currentCount % 2 !== 0) {
                        prediction = "banker";
                    } else {
                        prediction = "player";
                    }
                    return { prediction: prediction, countResult: currentCount };
                }

                // Chart and UI updates for Card Counting
                function initChart() {
                    elements.chartArea.innerHTML = '<canvas id="myChart"></canvas>';
                    const ctx = document.getElementById('myChart');

                    gameState.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Running Count',
                                data: [],
                                borderColor: 'var(--primary)',
                                backgroundColor: 'rgba(124, 58, 237, 0.1)',
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: 'var(--primary)'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--text-primary)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return `Count: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--text-primary)' }
                                },
                                y: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--text-primary)' }
                                }
                            },
                            animation: {
                                duration: 1200,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updateChart() {
                    const labels = [];
                    const countData = [];
                    let tempCount = 0;
                    gameState.entries.forEach((card, index) => {
                        labels.push(`Card ${index + 1}`);
                        tempCount += getCardCountContribution(card);
                        countData.push(tempCount);
                    });

                    gameState.chart.data.labels = labels;
                    gameState.chart.data.datasets[0].data = countData;
                    gameState.chart.update();
                }

                function updateRoadmap() {
                    elements.roadmap.innerHTML = '';
                    gameState.entries.forEach((card, index) => {
                        const cell = document.createElement('div');
                        cell.className = `cell animate__animated animate__fadeIn`;
                        cell.style.animationDelay = `${index * 0.05}s`;
                        cell.textContent = card === '10' ? '10/F' : card;

                        if (index === gameState.entries.length - 1) {
                            const predictionResult = getPrediction();
                            if (predictionResult && predictionResult.prediction !== "no prediction") {
                                const prediction = predictionResult.prediction;
                                if (prediction === 'player') {
                                    cell.classList.add('predicted-player');
                                } else if (prediction === 'banker') {
                                    cell.classList.add('predicted-banker');
                                } else if (prediction === 'tie') {
                                    cell.classList.add('predicted-tie');
                                }
                                cell.title = `Card ${index + 1}: ${card} (Current Prediction: ${prediction.toUpperCase()})`;
                            }
                        } else {
                            cell.title = `Card ${index + 1}: ${card}`;
                        }
                        elements.roadmap.appendChild(cell);
                    });
                }

                function updateStats() {
                    const playerBets = gameState.predictionHistory.filter(p => p.prediction === 'player').length;
                    const bankerBets = gameState.predictionHistory.filter(p => p.prediction === 'banker').length;
                    const tieBets = gameState.predictionHistory.filter(p => p.prediction === 'tie').length;

                    elements.playerBets.textContent = playerBets;
                    elements.bankerBets.textContent = bankerBets;
                    elements.tieBets.textContent = tieBets;
                    elements.totalEntries.textContent = gameState.entries.length;

                    const totalCardsInShoe = gameState.totalDecks * 52;
                    const cardsRemaining = totalCardsInShoe - gameState.entries.length;
                    const decksRemaining = (cardsRemaining / 52).toFixed(2);
                    elements.decksRemaining.textContent = Math.max(0, parseFloat(decksRemaining));

                    elements.entriesNeeded.textContent = gameState.entries.length > 0 ? gameState.entries.length : 'N/A';
                    elements.countResultValue.textContent = calculateRunningCount();
                }

                function updateHistory() {
                    elements.historyList.innerHTML = '';
                    gameState.predictionHistory.slice().reverse().forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item animate__animated animate__fadeIn';
                        historyItem.style.animationDelay = `${index * 0.05}s`;

                        const predictionNum = document.createElement('span');
                        predictionNum.textContent = `Hand ${gameState.predictionHistory.length - index}`;

                        const result = document.createElement('span');
                        result.className = `history-outcome ${item.prediction}`;
                        let outcomeText = item.prediction.charAt(0).toUpperCase() + item.prediction.slice(1);
                        if (item.countResult !== null) {
                            outcomeText += ` (Count: ${item.countResult})`;
                        }
                        result.textContent = outcomeText;

                        historyItem.appendChild(predictionNum);
                        historyItem.appendChild(result);
                        elements.historyList.appendChild(historyItem);
                    });
                }

                function updateRecommendation() {
                    const recommendationTextElement = elements.betRecommendation.querySelector('.recommendation-text');
                    const betAmountElement = elements.betAmount;
                    const countResultValueElement = elements.countResultValue;
                    const countDescElement = elements.countDesc;

                    recommendationTextElement.classList.remove('animate__animated', 'animate__fadeIn');
                    countResultValueElement.classList.remove('animate__animated', 'animate__bounceIn');
                    countDescElement.classList.remove('animate__animated', 'animate__fadeIn');
                    void recommendationTextElement.offsetWidth;
                    void countResultValueElement.offsetWidth;
                    void countDescElement.offsetWidth;
                    recommendationTextElement.classList.add('animate__animated', 'animate__fadeIn');
                    countResultValueElement.classList.add('animate__animated', 'animate__bounceIn');
                    countDescElement.classList.add('animate__animated', 'animate__fadeIn');

                    if (gameState.entries.length === 0) {
                        recommendationTextElement.textContent = "Enter cards to see prediction";
                        recommendationTextElement.className = "recommendation-text no-bet";
                        betAmountElement.textContent = "";
                        countResultValueElement.textContent = "0";
                        countDescElement.textContent = "This is the numerical result from the counting system.";
                        elements.betRecommendation.classList.remove('active');
                        return;
                    }

                    const predictionResult = getPrediction();
                    const countResult = predictionResult.countResult;
                    const absCount = Math.abs(countResult);

                    let betMessage = `Bet ${predictionResult.prediction.charAt(0).toUpperCase() + predictionResult.prediction.slice(1)}`;
                    if (predictionResult.prediction !== "no prediction") {
                        betMessage += ` (Count: ${countResult})`;
                    } else {
                        betMessage = `No clear prediction yet. (Count: ${countResult})`;
                    }

                    recommendationTextElement.textContent = betMessage;
                    if (predictionResult.prediction === "no prediction") {
                        recommendationTextElement.className = "recommendation-text no-bet";
                        elements.betRecommendation.classList.remove('active');
                    } else {
                        recommendationTextElement.className = "recommendation-text bet-suggestion";
                        elements.betRecommendation.classList.add('active');
                    }

                    const recommendedBet = 500;
                    betAmountElement.textContent = `Suggested Bet: $${recommendedBet.toLocaleString()}`;

                    countResultValueElement.textContent = countResult;

                    let description = "This is the numerical result from the counting system.";
                    if (countResult === 0) {
                        description = "Count is 0: Consider betting Tie, or wait for a clearer edge.";
                    } else if (absCount === 1) {
                        description = "Count is 1 (or -1): Slight edge, proceed with caution.";
                    } else if (absCount >= 2 && absCount <= 5) {
                        description = "Count is 2-5 (or -2 to -5): Moderate edge, increased bet suggested.";
                    } else if (absCount >= 6 && absCount <= 9) {
                        description = "Count is 6-9 (or -6 to -9): Significant edge, higher bets recommended.";
                    } else if (absCount >= 10 && absCount <= 14) {
                        description = "Count is 10-14 (or -10 to -14): Strong edge, significant bets advisable.";
                    } else if (absCount >= 15) {
                        description = "Count is 15+ (or -15+): Very strong edge, maximum bets recommended!";
                    }
                    countDescElement.textContent = description;

                    if (predictionResult.prediction !== "no prediction" &&
                        (gameState.predictionHistory.length === 0 || 
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].prediction !== predictionResult.prediction ||
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].countResult !== predictionResult.countResult)) {
                        gameState.predictionHistory.push({
                            prediction: predictionResult.prediction,
                            countResult: predictionResult.countResult,
                            timestamp: new Date().toLocaleTimeString()
                        });
                        updateHistory();
                    }
                    updateChart();
                }

                function addCardEntry(cardValue) {
                    gameState.entries.push(cardValue);
                    gameState.cardsDealt++;
                    updateStats();
                    updateRoadmap();
                    updateRecommendation();
                    displayMessage(`Card '${cardValue}' added.`, 'success');
                }

                function clearAllCardCounting() {
                    gameState.entries = [];
                    gameState.predictionHistory = [];
                    gameState.cardsDealt = 0;

                    elements.roadmap.classList.add('animate__animated', 'animate__fadeOut');
                    elements.chartArea.classList.add('animate__animated', 'animate__fadeOut');
                    
                    setTimeout(() => {
                        updateRoadmap();
                        updateChart();
                        updateStats();
                        updateHistory();

                        elements.betRecommendation.querySelector('.recommendation-text').textContent = "Enter cards to see prediction";
                        elements.betRecommendation.querySelector('.recommendation-text').className = "recommendation-text no-bet";
                        elements.betAmount.textContent = "";
                        elements.countResultValue.textContent = "0";
                        elements.countDesc.textContent = "This is the numerical result from the counting system.";

                        elements.roadmap.classList.remove('animate__fadeOut');
                        elements.chartArea.classList.remove('animate__fadeOut');
                        elements.roadmap.classList.add('animate__animated', 'animate__fadeIn');
                        elements.chartArea.classList.add('animate__animated', 'animate__fadeIn');
                        setTimeout(() => {
                            elements.roadmap.classList.remove('animate__fadeIn');
                            elements.chartArea.classList.remove('animate__fadeIn');
                        }, 500);
                    }, 500);
                    displayMessage('Card Counting data cleared.', 'info');
                }

                // =============================================
                // Pattern Recognition Functions
                // =============================================
                function toggleDropdown(dropdownMenu) {
                    dropdownMenu.classList.toggle('show');
                }

                function selectPatternStrategy(strategy) {
                    if (gameState.currentPatternStrategy === strategy) {
                        elements.patternDropdownMenu.classList.remove('show');
                        return;
                    }

                    gameState.currentPatternStrategy = strategy;
                    elements.selectedPatternText.textContent = strategy.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace('Pbpbpb', 'PBPBPB').replace('Patternmethod', 'Pattern Method').replace('Dragonpattern', 'Dragon Pattern').replace('Twospattern', 'Two-in-a-row Pattern');
                    elements.patternDropdownMenu.classList.remove('show');
                    
                    elements.patternInputArea.classList.remove('hidden');
                    elements.patternAnalysisResult.classList.add('hidden');
                    elements.patternAnalysisResult.innerHTML = '';
                    
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;

                    gameState.bankrollTimeline = [];
                    updatePatternAnalysisChart();
                    elements.patternChartContainer.classList.add('hidden');

                    initMasanielloGrid();
                    updatePatternDetails();
                    
                    initPatternOutcomeDistributionChart();
                    updatePatternOutcomeDistributionChart();
                    elements.patternOutcomeDistributionChartContainer.classList.remove('hidden');

                    document.getElementById('patternRecognition').classList.add('animate__animated', 'animate__fadeIn');
                    setTimeout(() => {
                        document.getElementById('patternRecognition').classList.remove('animate__animated', 'animate__fadeIn');
                    }, 600);
                    displayMessage(`Strategy '${elements.selectedPatternText.textContent}' selected.`, 'info');
                }

                function updatePatternDetails() {
                    let detailsHtml = '';
                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            detailsHtml = `<p class="text-secondary">This "Pattern Method" provides an intuitive suggestion for your next bet. It adapts to the flow of the game to guide your decisions.</p>`;
                            break;
                        case 'pbpbpbPattern':
                            detailsHtml = `<p class="text-secondary">This strategy looks for a repeating Player-Banker-Player-Banker (PBPBPB) sequence. If identified, it suggests betting on the continuation of this alternating pattern.</p>
                                           <p class="font-semibold mt-4 text-secondary">Current Pattern History: <span id="pbpbpbHistory" class="font-normal text-primary"></span></p>`;
                            break;
                        case 'dragonPattern':
                            detailsHtml = `<p class="text-secondary">The Dragon Pattern strategy identifies streaks of three or more consecutive Player or Banker wins. It recommends betting on the continuation of the current streak.</p>
                                           <p class="font-semibold mt-4 text-secondary">Current Pattern History: <span id="dragonHistory" class="font-normal text-primary"></span></p>`;
                            break;
                        case 'twosPattern':
                            detailsHtml = `<p class="text-secondary">The Two-in-a-row Pattern strategy looks for sequences where an outcome appears twice, then switches (e.g., P P B, B B P). It recommends betting on the next expected outcome in that sequence.</p>
                                           <p class="font-semibold mt-4 text-secondary">Current Pattern History: <span id="twosHistory" class="font-normal text-primary"></span></p>`;
                            break;
                        case 'masaniello':
                            detailsHtml = `<p class="text-secondary">The Masaniello staking plan aims to maximize profit and manage risk within a series of bets. This visualization tracks your progress through the plan based on game outcomes.</p>
                                           <h4 class="font-semibold mt-4 text-secondary">Masaniello Chart</h4>
                                           <p class="text-sm text-tertiary mt-1">Current Position: [Col <span id="masanielloCurrentCol">${gameState.masanielloState.currentCol}</span>, Row <span id="masanielloCurrentRow">${gameState.masanielloState.currentRow}</span>]</p>
                                           <div class="masaniello-chart-container">
                                               <div id="masanielloGrid" class="masaniello-grid"></div>
                                               <div class="masaniello-legend">
                                                   <div class="legend-item"><span class="legend-color-box player-bg"></span> Player Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box banker-bg"></span> Banker Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box sit-out-bg"></span> Sit Out</div>
                                               </div>
                                           </div>`;
                            break;
                        default:
                            detailsHtml = `<p class="text-secondary">Choose a pattern strategy from the dropdown above to see its description and controls.</p>`;
                    }
                    elements.patternStrategyDetails.innerHTML = detailsHtml;
                    elements.patternStrategyDetails.classList.remove('animate__animated', 'animate__fadeIn');
                    void elements.patternStrategyDetails.offsetWidth;
                    elements.patternStrategyDetails.classList.add('animate__animated', 'animate__fadeIn');

                    if (gameState.currentPatternStrategy === 'masaniello') {
                        drawMasanielloGrid();
                        elements.patternOutcomeDistributionChartContainer.classList.add('hidden');
                        elements.patternChartContainer.classList.add('hidden');
                    } else {
                         elements.patternOutcomeDistributionChartContainer.classList.remove('hidden');
                         updatePatternOutcomeDistributionChart();
                         if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem) {
                            elements.patternChartContainer.classList.remove('hidden');
                            updatePatternAnalysisChart();
                         } else {
                            elements.patternChartContainer.classList.add('hidden');
                         }
                    }
                    updatePatternAnalysis();
                }

                function initMasanielloGrid() {
                    gameState.masanielloState.grid = JSON.parse(JSON.stringify(masanielloGridConfig));
                    gameState.masanielloState.currentRow = masanielloGridConfig.length - 1;
                    gameState.masanielloState.currentCol = 0;
                }

                function drawMasanielloGrid() {
                    const gridElement = document.getElementById('masanielloGrid');
                    if (!gridElement) return;

                    gridElement.innerHTML = '';
                    for (let r = gameState.masanielloState.gridRows - 1; r >= 0; r--) {
                        for (let c = 0; c < gameState.masanielloState.gridCols; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'masaniello-cell animate__animated animate__fadeIn';
                            cell.style.animationDelay = `${(r + c) * 0.05}s`;
                            const cellData = masanielloGridConfig[r][c];

                            cell.innerHTML = `<span class="value">${cellData.value}</span><span class="bet-type">${cellData.bet.replace('-', ' ').toUpperCase()}</span>`;

                            if (cellData.bet === 'player') {
                                cell.classList.add('player-bg');
                            } else if (cellData.bet === 'banker') {
                                cell.classList.add('banker-bg');
                            } else if (cellData.bet === 'sit-out') {
                                cell.classList.add('sit-out-bg');
                            }

                            if (r === gameState.masanielloState.currentRow && c === gameState.masanielloState.currentCol) {
                                cell.classList.add('active-position');
                            }
                            gridElement.appendChild(cell);
                        }
                    }
                    const currentColSpan = document.getElementById('masanielloCurrentCol');
                    const currentRowSpan = document.getElementById('masanielloCurrentRow');
                    if (currentColSpan) currentColSpan.textContent = gameState.masanielloState.currentCol;
                    if (currentRowSpan) currentRowSpan.textContent = gameState.masanielloState.currentRow;
                }

                function updateMasanielloPosition(outcome) {
                    let { currentRow, currentCol, gridRows, gridCols } = gameState.masanielloState;
                    const currentCell = masanielloGridConfig[currentRow][currentCol];

                    let isWinForMasaniello = null;
                    if (currentCell.bet === 'player' && outcome === 'player') {
                        isWinForMasaniello = true;
                    } else if (currentCell.bet === 'banker' && outcome === 'banker') {
                        isWinForMasaniello = true;
                    } else if (currentCell.bet === 'player' && outcome === 'banker') {
                        isWinForMasaniello = false;
                    } else if (currentCell.bet === 'banker' && outcome === 'player') {
                        isWinForMasaniello = false;
                    }

                    if (isWinForMasaniello === true) {
                        currentRow = Math.max(0, currentRow - 1);
                    } else if (isWinForMasaniello === false) {
                        currentCol = Math.min(gridCols - 1, currentCol + 1);
                    }

                    currentRow = Math.max(0, Math.min(gridRows - 1, currentRow));
                    currentCol = Math.max(0, Math.min(gridCols - 1, currentCol));

                    gameState.masanielloState.currentRow = currentRow;
                    gameState.masanielloState.currentCol = currentCol;
                    drawMasanielloGrid(); // Re-draw the grid with the new active position
                }
                
                function getPatternMethodPrediction() {
                    const recentHistory = gameState.patternHistory.slice(-15);
                    if (recentHistory.length === 0) return 'no_clear_pattern';

                    const counts = { player: 0, banker: 0, tie: 0 };
                    recentHistory.forEach(outcome => {
                        counts[outcome]++;
                    });

                    if (counts.player > counts.banker) {
                        return 'player';
                    } else if (counts.banker > counts.player) {
                        return 'banker';
                    } else {
                        return 'banker'; // Default to banker if tied
                    }
                }

                function getPBPBPBRecommendation() {
                    const historyLength = gameState.patternHistory.length;
                    if (historyLength < 2) return 'no_clear_pattern';

                    const lastOutcome = gameState.patternHistory[historyLength - 1];
                    const secondLastOutcome = gameState.patternHistory[historyLength - 2];

                    if (lastOutcome !== secondLastOutcome && lastOutcome !== 'tie' && secondLastOutcome !== 'tie') {
                        return lastOutcome === 'player' ? 'banker' : 'player';
                    }
                    return 'no_clear_pattern';
                }

                function getDragonRecommendation() {
                    const history = gameState.patternHistory;
                    const historyLength = history.length;
                    if (historyLength < 3) return 'no_clear_pattern';

                    const lastOutcome = history[historyLength - 1];
                    const secondLastOutcome = history[historyLength - 2];
                    const thirdLastOutcome = history[historyLength - 3];

                    if (lastOutcome === secondLastOutcome && secondLastOutcome === thirdLastOutcome && (lastOutcome === 'player' || lastOutcome === 'banker')) {
                        return lastOutcome;
                    }
                    return 'no_clear_pattern';
                }

                function getTwosPatternRecommendation() {
                    const history = gameState.patternHistory;
                    const historyLength = history.length;
                    if (historyLength < 3) return 'no_clear_pattern';

                    const lastOutcome = history[historyLength - 1];
                    const secondLastOutcome = history[historyLength - 2];
                    const thirdLastOutcome = history[historyLength - 3];

                    if (secondLastOutcome === thirdLastOutcome && secondLastOutcome !== lastOutcome && (secondLastOutcome === 'player' || secondLastOutcome === 'banker')) {
                        return secondLastOutcome;
                    }
                    return 'no_clear_pattern';
                }

                function recordPatternOutcome(outcome) {
                    gameState.patternHistory.push(outcome);
                    gameState.outcomeCounts[outcome]++;
                    displayMessage(`Outcome: ${outcome.toUpperCase()} recorded.`, 'info');
                    updatePatternOutcomeDistributionChart();


                    let impliedBetTarget = null;

                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            impliedBetTarget = getPatternMethodPrediction();
                            break;
                        case 'pbpbpbPattern':
                            impliedBetTarget = getPBPBPBRecommendation();
                            break;
                        case 'dragonPattern':
                            impliedBetTarget = getDragonRecommendation();
                            break;
                        case 'twosPattern':
                            impliedBetTarget = getTwosPatternRecommendation();
                            break;
                        case 'masaniello':
                            updateMasanielloPosition(outcome);
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            impliedBetTarget = currentMasanielloCell.bet;
                            break;
                    }
                    gameState.currentPatternRecommendation = impliedBetTarget;
                    
                    let bettingOutcome = null;
                    
                    if (outcome === 'tie') {
                        bettingOutcome = 'push';
                    } else if (impliedBetTarget === 'sit-out' || impliedBetTarget === 'no_clear_pattern') {
                        bettingOutcome = 'push';
                    } else if (impliedBetTarget === outcome) {
                        bettingOutcome = 'win';
                    } else {
                        bettingOutcome = 'loss';
                    }

                    updatePatternAnalysis();

                    if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem && bettingOutcome) {
                        if (bettingOutcome === 'win' || bettingOutcome === 'loss') {
                            updateTheoreticalBankroll(bettingOutcome, impliedBetTarget);
                            gameState.bankrollTimeline.push({
                                outcomeIndex: gameState.patternHistory.length,
                                bankroll: gameState.patternBetting.theoreticalBankroll,
                                actualOutcome: outcome
                            });
                            updatePatternAnalysisChart();
                        } else {
                            displayMessage('Betting progression: Push (no change).', 'info');
                            gameState.bankrollTimeline.push({
                                outcomeIndex: gameState.patternHistory.length,
                                bankroll: gameState.patternBetting.theoreticalBankroll,
                                actualOutcome: outcome
                            });
                            updatePatternAnalysisChart();
                            updatePatternNextBetDisplay();
                        }
                    } else if (gameState.patternBetting.isEnabled && !gameState.patternBetting.currentSystem) {
                        displayMessage('Select a betting progression system to apply it automatically!', 'warning');
                    }
                }

                function updatePatternAnalysis() {
                    const resultDiv = elements.patternAnalysisResult;
                    resultDiv.classList.remove('hidden');
                    resultDiv.classList.remove('animate__animated', 'animate__fadeIn');
                    void resultDiv.offsetWidth;
                    resultDiv.classList.add('animate__animated', 'animate__fadeIn');


                    resultDiv.innerHTML = '';

                    if (gameState.patternHistory.length === 0) {
                        resultDiv.innerHTML = `<p class="text-secondary">No outcomes recorded yet. Enter Banker, Player, or Tie to start.</p>`;
                        return;
                    }

                    let recommendationText = '';
                    let currentRecommendation = gameState.currentPatternRecommendation;

                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span>`;
                            } else {
                                recommendationText = `Recommendation: <span class="text-danger font-bold">NO CLEAR BET</span>`;
                            }
                            resultDiv.innerHTML = `<p class="text-info mt-2">${recommendationText}</p>
                                                   <p class="text-sm text-tertiary mt-2">Based on analysis of recent trends.</p>`;
                            break;
                        case 'pbpbpbPattern':
                            if(document.getElementById('pbpbpbHistory')) document.getElementById('pbpbpbHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following PBPBPB)`;
                            } else {
                                recommendationText = `No clear PBPBPB pattern observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-chart-line text-5xl text-tertiary opacity-70"></i>
                                                <p class="text-sm text-tertiary mt-2">Visual trend analysis can be added here.</p>
                                            </div>`;
                            break;
                        case 'dragonPattern':
                            if(document.getElementById('dragonHistory')) document.getElementById('dragonHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following Dragon)`;
                            } else {
                                recommendationText = `No clear Dragon pattern (streak of 3+) observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-fire text-5xl text-tertiary opacity-70"></i>
                                                <p class="text-sm text-tertiary mt-2">Looks for long streaks.</p>
                                            </div>`;
                            break;
                        case 'twosPattern':
                            if(document.getElementById('twosHistory')) document.getElementById('twosHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following Two-in-a-row)`;
                            } else {
                                recommendationText = `No clear Two-in-a-row pattern observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-arrows-alt-h text-5xl text-tertiary opacity-70"></i>
                                                <p class="text-sm text-tertiary mt-2">Looks for paired outcomes.</p>
                                            </div>`;
                            break;
                        case 'masaniello':
                            drawMasanielloGrid();
                            const currentCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            let suggestedBetDisplay = currentCell.bet === 'sit-out' ? 'SIT OUT' : currentCell.bet.toUpperCase();
                            resultDiv.innerHTML = `<p class="text-primary">Masaniello Chart displays your current staking position.</p>
                                            <p class="text-warning font-bold mt-2">Suggested Bet Unit: ${currentCell.value}</p>
                                            <p class="text-info font-bold mt-2">Suggested Bet Type: ${suggestedBetDisplay}</p>
                                            <p class="text-sm text-tertiary">Track your progress on the grid above.</p>`;
                            break;
                        default:
                            resultDiv.innerHTML = `<p class="text-secondary">Select a strategy to begin analysis.</p>`;
                    }

                    if (gameState.patternBetting.isEnabled) {
                        updatePatternNextBetDisplay();
                    }
                }

                function clearPatternHistory() {
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;
                    displayMessage('Pattern history cleared.', 'success');
                    
                    initMasanielloGrid();
                    updatePatternDetails();
                    updatePatternOutcomeDistributionChart();

                    elements.patternAnalysisResult.classList.add('hidden');
                    elements.patternAnalysisResult.innerHTML = '';
                    
                    resetPatternBettingSystem(true);
                    elements.clearPatternBtn.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => {
                        elements.clearPatternBtn.classList.remove('animate__animated', 'animate__shakeX');
                    }, 1000);
                }

                // =============================================
                // Betting Systems Functions
                // =============================================
                function selectPatternBettingSystem(system) {
                    if (gameState.patternBetting.currentSystem === system) {
                        elements.bettingProgressionDropdownMenu.classList.remove('show');
                        return;
                    }
                    gameState.patternBetting.currentSystem = system;
                    elements.selectedBettingProgressionText.textContent = system.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    elements.bettingProgressionDropdownMenu.classList.remove('show');
                    
                    elements.patternBettingInputArea.classList.remove('hidden');
                    updatePatternBettingSystemDetails();
                    resetPatternBettingSystem(false);
                    displayMessage(`Betting system '${elements.selectedBettingProgressionText.textContent}' selected.`, 'info');
                }

                function updatePatternBettingSystemDetails() {
                    let detailsHtml = '';
                    switch (gameState.patternBetting.currentSystem) {
                        case 'flatBetting':
                            detailsHtml = `<p class="text-secondary">Flat betting involves placing the same amount of units on every wager, regardless of wins or losses. It's a low-risk strategy focused on consistency.</p>
                                           <p class="mt-2">Set your base bet in units:</p>
                                           <input type="number" id="patternFlatBetInput" class="auth-input mt-2" value="${gameState.patternBetting.flatBetAmount}" min="1">
                                           <button class="btn-secondary mt-4" id="setPatternFlatBetBtn">Set Flat Bet (Units)</button>`;
                            break;
                        case 'martingale':
                            detailsHtml = `<p class="text-secondary">The Martingale system involves doubling your bet units after every loss, aiming to recover all previous losses with a single win. Risky, requires large bankroll.</p>
                                           <p class="text-warning mt-2">Starting bet: ${gameState.patternBetting.martingaleBet} units. Next bet will adjust based on outcome.</p>`;
                            break;
                        case 'dalembert':
                            detailsHtml = `<p class="text-secondary">D'Alembert system involves increasing your bet by one unit after a loss and decreasing by one unit after a win. Less aggressive than Martingale.</p>
                                           <p class="text-warning mt-2">Starting bet: ${gameState.patternBetting.dalembertBet} units. Next bet will adjust based on outcome.</p>`;
                            break;
                        case 'fibonacci':
                            detailsHtml = `<p class="text-secondary">Fibonacci system uses the Fibonacci sequence (1, 1, 2, 3, 5, 8...) where the next bet is the sum of the previous two. Move up the sequence on loss, back two on win.</p>
                                           <p class="text-warning mt-2">Current Fibonacci Index: ${gameState.patternBetting.fibonacciIndex}. Next bet will adjust based on outcome.</p>`;
                            break;
                        default:
                            detailsHtml = `<p class="text-secondary">Choose a betting system to manage your wagers.</p>`;
                    }
                    elements.patternBettingSystemDetails.innerHTML = detailsHtml;
                    elements.patternBettingSystemDetails.classList.remove('animate__animated', 'animate__fadeIn');
                    void elements.patternBettingSystemDetails.offsetWidth;
                    elements.patternBettingSystemDetails.classList.add('animate__animated', 'animate__fadeIn');


                    if (gameState.patternBetting.currentSystem === 'flatBetting') {
                        document.getElementById('setPatternFlatBetBtn').onclick = () => {
                            const newBet = parseInt(document.getElementById('patternFlatBetInput').value);
                            if (!isNaN(newBet) && newBet >= 1) {
                                gameState.patternBetting.flatBetAmount = newBet;
                                displayMessage(`Flat bet set to ${newBet} units.`, 'success');
                                updatePatternNextBetDisplay();
                            } else {
                                displayMessage('Please enter a valid flat bet amount (at least 1 unit).', 'error');
                            }
                        };
                    }
                    updatePatternNextBetDisplay();
                }

                function updateTheoreticalBankroll(outcomeWinLoss, impliedBetTarget) {
                    let betUnits = 0;
                    const pb = gameState.patternBetting;

                    let currentBetUnitsForCalc = 0;
                     switch (pb.currentSystem) {
                        case 'flatBetting': currentBetUnitsForCalc = pb.flatBetAmount; break;
                        case 'martingale': currentBetUnitsForCalc = pb.martingaleBet; break;
                        case 'dalembert': currentBetUnitsForCalc = pb.dalembertBet; break;
                        case 'fibonacci': currentBetUnitsForCalc = pb.fibonacciSequence[pb.fibonacciIndex]; break;
                        case 'masaniello':
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            currentBetUnitsForCalc = currentMasanielloCell.value;
                            break;
                        default:
                            currentBetUnitsForCalc = 0;
                    }
                    
                    const betAmountDollars = currentBetUnitsForCalc * pb.bettingUnitValue;

                    if (pb.theoreticalBankroll - betAmountDollars < 0 && outcomeWinLoss === 'loss') {
                        displayMessage(`Theoretical bankroll ($${pb.theoreticalBankroll.toLocaleString()}) insufficient for next $${betAmountDollars.toFixed(2)} bet. Resetting betting system.`, 'error');
                        resetPatternBettingSystem(true);
                        return;
                    }

                    if (outcomeWinLoss === 'win') {
                        let winAmountDollars = betAmountDollars;
                        if (impliedBetTarget === 'banker') {
                            winAmountDollars = winAmountDollars * 0.95;
                        } else if (impliedBetTarget === 'tie') {
                            winAmountDollars = betAmountDollars * 8;
                        }
                        pb.theoreticalBankroll += winAmountDollars;
                        displayMessage(`Theoretical WIN of $${winAmountDollars.toFixed(2)}.`, 'success');
                        
                        switch (pb.currentSystem) {
                            case 'martingale': pb.martingaleBet = 1; break;
                            case 'dalembert': pb.dalembertBet = Math.max(1, pb.dalembertBet - 1); break;
                            case 'fibonacci': pb.fibonacciIndex = Math.max(0, pb.fibonacciIndex - 2); break;
                        }

                    } else {
                        pb.theoreticalBankroll -= betAmountDollars;
                        displayMessage(`Theoretical LOSS of $${betAmountDollars.toFixed(2)}.`, 'error');

                        switch (pb.currentSystem) {
                            case 'martingale': pb.martingaleBet *= 2; break;
                            case 'dalembert': pb.dalembertBet += 1; break;
                            case 'fibonacci': 
                                pb.fibonacciIndex++;
                                if (pb.fibonacciIndex >= pb.fibonacciSequence.length) {
                                    const nextFib = pb.fibonacciSequence[pb.fibonacciIndex - 1] + pb.fibonacciSequence[pb.fibonacciIndex - 2];
                                    pb.fibonacciSequence.push(nextFib);
                                }
                                break;
                        }
                    }
                    updatePatternNextBetDisplay();
                }

                function updatePatternNextBetDisplay() {
                    let nextBetUnits = 0;
                    let currentBaseInfo = '';
                    const pb = gameState.patternBetting;

                    if (!pb.currentSystem) {
                        elements.patternNextBetAmount.textContent = '0 units';
                        elements.patternCurrentBaseBet.textContent = 'N/A';
                        elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`;
                        return;
                    }

                    switch (pb.currentSystem) {
                        case 'flatBetting':
                            nextBetUnits = pb.flatBetAmount;
                            currentBaseInfo = `Base: ${pb.flatBetAmount} units`;
                            break;
                        case 'martingale':
                            nextBetUnits = pb.martingaleBet;
                            currentBaseInfo = `Current Bet: ${pb.martingaleBet} units`;
                            break;
                        case 'dalembert':
                            nextBetUnits = pb.dalembertBet;
                            currentBaseInfo = `Current Bet: ${pb.dalembertBet} units`;
                            break;
                        case 'fibonacci':
                            nextBetUnits = pb.fibonacciSequence[pb.fibonacciIndex];
                            currentBaseInfo = `Current Index: ${pb.fibonacciIndex}`;
                            break;
                        case 'masaniello':
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            nextBetUnits = currentMasanielloCell.value;
                            currentBaseInfo = `Unit Value: $${gameState.masanielloState.unitIncrement}`;
                            break;
                        default:
                            nextBetUnits = 0;
                            currentBaseInfo = 'N/A';
                    }
                    elements.patternNextBetAmount.textContent = `${nextBetUnits.toLocaleString()} units`;
                    elements.patternCurrentBaseBet.textContent = currentBaseInfo;
                    elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`;
                }

                function resetPatternBettingSystem(resetSelectedSystem = true) {
                    if (resetSelectedSystem) {
                        gameState.patternBetting.currentSystem = null;
                        elements.selectedBettingProgressionText.textContent = 'Select System';
                    }

                    gameState.patternBetting.martingaleBet = 1;
                    gameState.patternBetting.dalembertBet = 1;
                    gameState.patternBetting.fibonacciSequence = [1, 1];
                    gameState.patternBetting.fibonacciIndex = 0;
                    gameState.patternBetting.flatBetAmount = 1;
                    gameState.patternBetting.theoreticalBankroll = 10000;

                    gameState.bankrollTimeline = [];
                    updatePatternAnalysisChart();
                    elements.patternChartContainer.classList.add('hidden');

                    const flatBetInput = document.getElementById('patternFlatBetInput');
                    if (flatBetInput) {
                        flatBetInput.value = gameState.patternBetting.flatBetAmount;
                    }

                    elements.patternBettingInputArea.classList.add('hidden');
                    elements.patternBettingSystemDetails.innerHTML = `<p class="text-secondary">Choose a betting system to manage your wagers.</p>`;

                    updatePatternNextBetDisplay();
                    displayMessage('Betting system reset to base units. Theoretical bankroll reset.', 'info');
                }

                function initPatternAnalysisChart() {
                    if (gameState.patternAnalysisChartInstance) {
                        gameState.patternAnalysisChartInstance.destroy();
                    }
                    let canvas = elements.patternChartContainer.querySelector('#patternAnalysisChart');
                    if (!canvas) {
                        elements.patternChartContainer.innerHTML = '<h4 class="panel-title">Theoretical Bankroll Evolution</h4><canvas id="patternAnalysisChart"></canvas>';
                        canvas = elements.patternChartContainer.querySelector('#patternAnalysisChart');
                    }

                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;

                    const style = getComputedStyle(document.documentElement);
                    const successColor = style.getPropertyValue('--success').trim();
                    const dangerColor = style.getPropertyValue('--danger').trim();
                    const warningColor = style.getPropertyValue('--warning').trim(); 

                    gameState.patternAnalysisChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Theoretical Bankroll',
                                data: [],
                                borderColor: successColor,
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 5,
                                pointBackgroundColor: successColor,
                                pointBorderColor: '#fff',
                                pointHoverRadius: 7,
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--text-primary)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        title: function(context) {
                                            return `Outcome #${context[0].dataIndex + 1}`;
                                        },
                                        label: function(context) {
                                            const dataPoint = gameState.bankrollTimeline[context.dataIndex];
                                            return `Bankroll: $${dataPoint.bankroll.toLocaleString()} (Outcome: ${dataPoint.actualOutcome.toUpperCase()})`;
                                        },
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.08)' },
                                    ticks: { color: 'var(--text-secondary)' },
                                    title: {
                                        display: true,
                                        text: 'Outcome Number',
                                        color: 'var(--text-secondary)',
                                        font: { size: 16 }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(255, 255, 255, 0.08)' },
                                    ticks: { color: 'var(--text-secondary)' },
                                    title: {
                                        display: true,
                                        text: 'Bankroll ($)',
                                        color: 'var(--text-secondary)',
                                        font: { size: 16 }
                                    }
                                }
                            }
                        }
                    });
                }

                function updatePatternAnalysisChart() {
                    if (!gameState.patternAnalysisChartInstance) {
                        initPatternAnalysisChart();
                    }
                    if (!gameState.patternAnalysisChartInstance) {
                        return;
                    }

                    const labels = gameState.bankrollTimeline.map((_, i) => `${i + 1}`);
                    const data = gameState.bankrollTimeline.map(point => point.bankroll);

                    gameState.patternAnalysisChartInstance.data.labels = labels;
                    gameState.patternAnalysisChartInstance.data.datasets[0].data = data;

                    if (gameState.bankrollTimeline.length > 0) {
                        const lastBankroll = gameState.bankrollTimeline[gameState.bankrollTimeline.length - 1].bankroll;
                        const initialBankroll = gameState.bankrollTimeline[0] ? gameState.bankrollTimeline[0].bankroll : 10000;

                        const style = getComputedStyle(document.documentElement);
                        const successColor = style.getPropertyValue('--success').trim();
                        const dangerColor = style.getPropertyValue('--danger').trim();
                        const warningColor = style.getPropertyValue('--warning').trim();

                        if (lastBankroll > initialBankroll) {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = successColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = successColor;
                        } else if (lastBankroll < initialBankroll) {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = dangerColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = dangerColor;
                        } else {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = warningColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = warningColor;
                        }
                    }

                    gameState.patternAnalysisChartInstance.update();
                }

                function initPatternOutcomeDistributionChart() {
                    if (gameState.patternOutcomeDistributionChartInstance) {
                        gameState.patternOutcomeDistributionChartInstance.destroy();
                    }
                    let canvas = elements.patternOutcomeDistributionChartContainer.querySelector('#patternOutcomeDistributionChart');
                    if (!canvas) {
                        elements.patternOutcomeDistributionChartContainer.innerHTML = '<h4 class="panel-title">Pattern Outcome Distribution</h4><canvas id="patternOutcomeDistributionChart"></canvas>';
                        canvas = elements.patternOutcomeDistributionChartContainer.querySelector('#patternOutcomeDistributionChart');
                    }

                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;

                    const style = getComputedStyle(document.documentElement);
                    const infoColor = style.getPropertyValue('--info').trim();
                    const dangerColor = style.getPropertyValue('--danger').trim();
                    const warningColor = style.getPropertyValue('--warning').trim();

                    gameState.patternOutcomeDistributionChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Player', 'Banker', 'Tie'],
                            datasets: [{
                                label: 'Outcome Count',
                                data: [0, 0, 0],
                                backgroundColor: [infoColor, dangerColor, warningColor],
                                borderColor: ['#fff', '#fff', '#fff'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return `${context.label}: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { display: false },
                                    ticks: { color: 'var(--text-primary)' }
                                },
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--text-primary)', precision: 0 }
                                }
                            },
                            animation: {
                                duration: 800,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updatePatternOutcomeDistributionChart() {
                    if (!gameState.patternOutcomeDistributionChartInstance) {
                        initPatternOutcomeDistributionChart();
                    }
                    if (!gameState.patternOutcomeDistributionChartInstance) {
                        return;
                    }

                    const playerCounts = gameState.patternHistory.filter(o => o === 'player').length;
                    const bankerCounts = gameState.patternHistory.filter(o => o === 'banker').length;
                    const tieCounts = gameState.patternHistory.filter(o => o === 'tie').length;

                    gameState.patternOutcomeDistributionChartInstance.data.datasets[0].data = [playerCounts, bankerCounts, tieCounts];
                    gameState.patternOutcomeDistributionChartInstance.update();
                    
                    elements.patternOutcomeDistributionChartContainer.classList.remove('hidden');
                    elements.patternOutcomeDistributionChartContainer.classList.remove('animate__animated', 'animate__fadeIn');
                    void elements.patternOutcomeDistributionChartContainer.offsetWidth;
                    elements.patternOutcomeDistributionChartContainer.classList.add('animate__animated', 'animate__fadeIn');
                }


                // =============================================
                // Baccarat Mini-Game Functions
                // =============================================

                function createDeck() {
                    const suits = ['♠', '♥', '♦', '♣'];
                    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    let deck = [];
                    for (let i = 0; i < gameState.totalDecks; i++) {
                        suits.forEach(suit => {
                            ranks.forEach(rank => {
                                deck.push({ rank, suit });
                            });
                        });
                    }
                    return shuffleDeck(deck);
                }

                function shuffleDeck(deck) {
                    for (let i = deck.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [deck[i], deck[j]] = [deck[j], deck[i]];
                    }
                    return deck;
                }

                function getCardValueBaccarat(card) {
                    if (['10', 'J', 'Q', 'K'].includes(card.rank)) return 0;
                    if (card.rank === 'A') return 1;
                    return parseInt(card.rank);
                }

                function calculateHandScore(hand) {
                    let score = hand.reduce((sum, card) => sum + getCardValueBaccarat(card), 0);
                    return score % 10;
                }

                function displayHand(hand, elementId) {
                    const listElement = document.getElementById(elementId);
                    if (!listElement) {
                        console.error(`Element with ID '${elementId}' not found for displaying hand.`);
                        return;
                    }
                    listElement.innerHTML = '';
                    hand.forEach((card, index) => {
                        const cardItem = document.createElement('div');
                        cardItem.className = 'card-item animate__animated animate__fadeInUp';
                        cardItem.textContent = `${card.rank}${card.suit}`;
                        cardItem.style.animationDelay = `${index * 0.2}s`;
                        listElement.appendChild(cardItem);
                    });
                }

                function determineWinner(playerScore, bankerScore, playerHand, bankerHand) {
                    const playerNatural = playerHand.length === 2 && (playerScore === 8 || playerScore === 9);
                    const bankerNatural = bankerHand.length === 2 && (bankerScore === 8 || bankerScore === 9);

                    if (playerNatural && bankerNatural) {
                        if (playerScore === bankerScore) return 'tie';
                        return playerScore > bankerScore ? 'player' : 'banker';
                    }
                    if (playerNatural) return 'player';
                    if (bankerNatural) return 'banker';

                    if (playerScore === bankerScore) return 'tie';
                    return playerScore > bankerScore ? 'player' : 'banker';
                }

                function shouldPlayerDraw(playerScore) {
                    return playerScore <= 5;
                }

                function shouldBankerDraw(bankerScore, playerThirdCardValue) {
                    if (bankerScore <= 2) return true;
                    if (bankerScore === 3 && playerThirdCardValue !== 8) return true;
                    if (bankerScore === 4 && playerThirdCardValue >= 2 && playerThirdCardValue <= 7) return true;
                    if (bankerScore === 5 && playerThirdCardValue >= 4 && playerThirdCardValue <= 7) return true;
                    if (bankerScore === 6 && (playerThirdCardValue === 6 || playerThirdCardValue === 7)) return true;
                    return false;
                }

                function resetMiniGameUI() {
                    if (elements.playerCardList) elements.playerCardList.innerHTML = '';
                    if (elements.bankerCardList) elements.bankerCardList.innerHTML = '';
                    if (elements.playerScore) elements.playerScore.textContent = '0';
                    if (elements.bankerScore) elements.bankerScore.textContent = '0';
                    if (elements.gameResultDisplay) elements.gameResultDisplay.classList.add('hidden');
                    if (elements.gameResultText) elements.gameResultText.textContent = '';
                    elements.betOptionBtns.forEach(btn => btn.classList.remove('active-bet'));
                    gameState.currentBet.type = null;
                }

                function dealHand() {
                    const betAmount = parseInt(elements.betAmountInput.value);
                    const betTarget = gameState.currentBet.type;

                    if (!betTarget) {
                        displayMessage('Please select a bet target (Player, Banker, or Tie).', 'error');
                        return;
                    }
                    if (isNaN(betAmount) || betAmount <= 0) {
                        displayMessage('Please enter a valid bet amount.', 'error');
                        return;
                    }
                    if (betAmount > gameState.miniGameBalance) {
                        displayMessage('You do not have enough balance for this bet!', 'error');
                        return;
                    }

                    resetMiniGameUI();
                    displayMessage(`Betting $${betAmount} on ${betTarget.toUpperCase()}. Dealing cards...`, 'info');
                    gameState.currentBet.amount = betAmount;

                    gameState.deck = createDeck();
                    gameState.playerHand = [];
                    gameState.bankerHand = [];

                    gameState.playerHand.push(gameState.deck.pop());
                    gameState.bankerHand.push(gameState.deck.pop());
                    gameState.playerHand.push(gameState.deck.pop());
                    gameState.bankerHand.push(gameState.deck.pop());
                    displayHand(gameState.playerHand, 'playerCardList');
                    displayHand(gameState.bankerHand, 'bankerCardList');

                    let playerScore = calculateHandScore(gameState.playerHand);
                    let bankerScore = calculateHandScore(gameState.bankerHand);
                    elements.playerScore.textContent = playerScore;
                    elements.bankerScore.textContent = bankerScore;

                    setTimeout(() => {
                        let playerThirdCard = null;

                        const playerNatural = gameState.playerHand.length === 2 && (playerScore === 8 || playerScore === 9);
                        const bankerNatural = gameState.bankerHand.length === 2 && (bankerScore === 8 || bankerScore === 9);

                        let needsThirdCardPhase = true;

                        if (playerNatural || bankerNatural) {
                            if (playerNatural && bankerNatural) {
                                needsThirdCardPhase = false;
                            } else if (playerNatural) {
                                needsThirdCardPhase = false;
                            } else if (bankerNatural) {
                                needsThirdCardPhase = false;
                            }
                        }

                        if (needsThirdCardPhase) {
                            const playerDraws = shouldPlayerDraw(playerScore);
                            if (playerDraws) {
                                playerThirdCard = gameState.deck.pop();
                                gameState.playerHand.push(playerThirdCard);
                                displayHand(gameState.playerHand, 'playerCardList');
                                playerScore = calculateHandScore(gameState.playerHand);
                                elements.playerScore.textContent = playerScore;
                                displayMessage('Player drew a third card.', 'info');
                            }

                            const playerThirdCardValue = playerThirdCard ? getCardValueBaccarat(playerThirdCard) : null;
                            const bankerDraws = shouldBankerDraw(bankerScore, playerThirdCardValue);
                            if (bankerDraws) {
                                gameState.bankerHand.push(gameState.deck.pop());
                                displayHand(gameState.bankerHand, 'bankerCardList');
                                bankerScore = calculateHandScore(gameState.bankerHand);
                                elements.bankerScore.textContent = bankerScore;
                                displayMessage('Banker drew a third card.', 'info');
                            }
                        }


                        setTimeout(() => {
                            const winner = determineWinner(playerScore, bankerScore, gameState.playerHand, gameState.bankerHand);
                            let winLossAmount = 0;
                            let resultText = '';
                            let resultClass = '';

                            if (winner === betTarget) {
                                if (betTarget === 'banker') {
                                    winLossAmount = gameState.currentBet.amount * 0.95;
                                } else if (betTarget === 'tie') {
                                    winLossAmount = gameState.currentBet.amount * 8;
                                } else {
                                    winLossAmount = gameState.currentBet.amount;
                                }
                                gameState.miniGameBalance += winLossAmount;
                                resultText = `You WON! ${winner.toUpperCase()} wins! (+ $${winLossAmount.toFixed(2)})`;
                                resultClass = 'result-player';
                            } else {
                                winLossAmount = -gameState.currentBet.amount;
                                gameState.miniGameBalance -= gameState.currentBet.amount;
                                resultText = `You LOST! ${winner.toUpperCase()} wins. (- $${Math.abs(winLossAmount).toFixed(2)})`;
                                resultClass = 'result-banker';
                            }

                            if (winner === 'tie' && betTarget !== 'tie') {
                                resultText = `It's a TIE! Your ${betTarget.toUpperCase()} bet is a push.`;
                                resultClass = 'result-tie';
                                winLossAmount = 0;
                            }

                            elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;
                            elements.gameNewBalance.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;
                            elements.gameResultText.textContent = resultText;
                            elements.gameResultText.className = `game-result ${resultClass}`;
                            elements.gameResultDisplay.classList.remove('hidden');

                            if (winLossAmount > 0) {
                                elements.gameResultText.classList.add('animate__animated', 'animate__bounceIn');
                            } else if (winLossAmount < 0) {
                                elements.gameResultText.classList.add('animate__animated', 'animate__shakeX');
                            } else {
                                elements.gameResultText.classList.add('animate__animated', 'animate__fadeIn');
                            }

                        }, 1000);
                    }, 1000);
                }


                // =============================================
                // Event Listeners
                // =============================================
                // Card Counting Buttons
                elements.cardButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const cardValue = this.dataset.cardValue;
                        addCardEntry(cardValue);
                        this.classList.add('animate__animated', 'animate__rubberBand');
                        setTimeout(() => {
                            this.classList.remove('animate__animated', 'animate__rubberBand');
                        }, 1000);
                    });
                });

                elements.clearBtn.addEventListener('click', function() {
                    clearAllCardCounting();
                    this.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => {
                        this.classList.remove('animate__animated', 'animate__shakeX');
                    }, 1000);
                });

                // Strategy Tabs
                elements.strategyTabs.addEventListener('click', function(event) {
                    if (event.target.classList.contains('tab-btn')) {
                        const tabId = event.target.dataset.tab;

                        elements.strategyTabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                        elements.tabContents.forEach(content => {
                            content.classList.remove('active');
                            content.classList.remove('animate__animated', 'animate__fadeIn');
                        });

                        event.target.classList.add('active');
                        const activeTabContent = document.getElementById(tabId);
                        void activeTabContent.offsetWidth; // Trigger reflow
                        activeTabContent.classList.add('active', 'animate__animated', 'animate__fadeIn');
                        
                        // Re-initialize chart only for Card Counting tab if not already initialized or is missing
                        if (tabId === 'cardCounting') {
                            initChart(); // Ensure chart is always initialized for card counting
                            updateChart();
                            updateRoadmap();
                            updateStats();
                            updateHistory();
                            updateRecommendation();
                        } else if (tabId === 'patternRecognition') {
                            updatePatternDetails(); // Re-render details on tab switch
                            updatePatternAnalysis(); // Re-evaluate pattern recommendation
                            initPatternOutcomeDistributionChart(); // Ensure pattern outcome chart is initialized
                            updatePatternOutcomeDistributionChart(); // Update it
                            // Re-initialize bankroll chart only if progression enabled and not Masaniello
                            if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem && gameState.currentPatternStrategy !== 'masaniello') {
                                initPatternAnalysisChart();
                                updatePatternAnalysisChart();
                                elements.patternChartContainer.classList.remove('hidden');
                            } else {
                                elements.patternChartContainer.classList.add('hidden');
                            }
                        } else if (tabId === 'miniGame') {
                            resetMiniGameUI();
                        }
                    }
                });

                // Pattern Recognition Dropdown & Buttons
                elements.patternDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.patternDropdownMenu);
                });

                elements.patternDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        selectPatternStrategy(event.target.dataset.strategy);
                    }
                });

                elements.patternOutcomeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        if (gameState.currentPatternStrategy) {
                            recordPatternOutcome(this.dataset.outcome);
                            this.classList.add('animate__animated', 'animate__pulse');
                            setTimeout(() => this.classList.remove('animate__pulse'), 500);
                        } else {
                            displayMessage('Please select a pattern strategy first!', 'error');
                        }
                    });
                });

                elements.clearPatternBtn.addEventListener('click', clearPatternHistory);

                // Betting Progression Toggle
                elements.enableBettingProgressionToggle.addEventListener('change', function() {
                    gameState.patternBetting.isEnabled = this.checked;
                    if (this.checked) {
                        elements.patternBettingControls.classList.remove('hidden');
                        void elements.patternBettingControls.offsetWidth;
                        elements.patternBettingControls.classList.add('animate__animated', 'animate__fadeInDown');
                        
                        if (!gameState.patternBetting.currentSystem) {
                            selectPatternBettingSystem('flatBetting');
                        } else {
                            updatePatternNextBetDisplay();
                        }

                        if (gameState.patternBetting.currentSystem && gameState.currentPatternStrategy !== 'masaniello') {
                            if (gameState.bankrollTimeline.length > 0 || gameState.patternBetting.theoreticalBankroll === 10000) {
                                elements.patternChartContainer.classList.remove('hidden');
                                void elements.patternChartContainer.offsetWidth;
                                elements.patternChartContainer.classList.add('animate__animated', 'animate__fadeInUp');
                                updatePatternAnalysisChart();
                            }
                        } else {
                            elements.patternChartContainer.classList.add('hidden');
                        }
                        displayMessage('Betting progression enabled.', 'success');
                    } else {
                        elements.patternBettingControls.classList.add('hidden');
                        elements.patternBettingControls.classList.remove('animate__fadeInDown');
                        elements.patternChartContainer.classList.add('hidden');
                        resetPatternBettingSystem(true);
                        displayMessage('Betting progression disabled and reset.', 'info');
                    }
                });


                // Betting Progression Dropdown & Buttons (within Pattern Recognition)
                elements.bettingProgressionDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.bettingProgressionDropdownMenu);
                });

                elements.bettingProgressionDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        selectPatternBettingSystem(event.target.dataset.system);
                        if (gameState.patternBetting.isEnabled && gameState.currentPatternStrategy !== 'masaniello') {
                            elements.patternChartContainer.classList.remove('hidden');
                            void elements.patternChartContainer.offsetWidth;
                            elements.patternChartContainer.classList.add('animate__animated', 'animate__fadeInUp');
                            updatePatternAnalysisChart();
                        } else {
                            elements.patternChartContainer.classList.add('hidden');
                        }
                    }
                });

                elements.patternResetBettingBtn.addEventListener('click', () => resetPatternBettingSystem(false));

                // Set Unit Value for Betting Progressions
                elements.setBetUnitValueBtn.addEventListener('click', function() {
                    const newUnitValue = parseInt(elements.betUnitValueInput.value);
                    if (!isNaN(newUnitValue) && newUnitValue >= 1) {
                        gameState.patternBetting.bettingUnitValue = newUnitValue;
                        displayMessage(`Betting unit set to $${newUnitValue}.`, 'success');
                        updatePatternNextBetDisplay();
                        this.classList.add('animate__animated', 'animate__tada');
                        setTimeout(() => this.classList.remove('animate__tada'), 1000);
                    } else {
                        displayMessage('Please enter a valid unit value (minimum $1).', 'error');
                        this.classList.add('animate__animated', 'animate__shakeX');
                        setTimeout(() => this.classList.remove('animate__shakeX'), 1000);
                    }
                });


                // Mini-Game Buttons
                elements.betOptionBtns.forEach(button => {
                    button.addEventListener('click', function() {
                        elements.betOptionBtns.forEach(btn => btn.classList.remove('active-bet'));
                        this.classList.add('active-bet');
                        gameState.currentBet.type = this.dataset.betTarget;
                        displayMessage(`Selected to bet on ${gameState.currentBet.type.toUpperCase()}.`, 'info');
                        this.classList.add('animate__animated', 'animate__rubberBand');
                        setTimeout(() => {
                            this.classList.remove('animate__rubberBand');
                        }, 1000);
                    });
                });

                elements.dealHandBtn.addEventListener('click', function() {
                    dealHand();
                    this.classList.add('animate__animated', 'animate__swing');
                    setTimeout(() => {
                        this.classList.remove('animate__swing');
                    }, 1000);
                });

                // Initial setup for the app (after successful authentication)
                function init() {
                    initChart(); // Initialize chart for card counting tab
                    startTimer(); // Start global timer
                    // No sample data added automatically on init for card counting
                    updateRoadmap();
                    updateChart();
                    updateStats();
                    updateHistory();
                    updateRecommendation();
                    initMasanielloGrid(); // Initialize Masaniello grid state
                    updatePatternDetails(); // Load initial pattern details and prediction
                    updatePatternNextBetDisplay(); // Initialize betting display
                    initPatternAnalysisChart(); // Initialize the new pattern analysis chart (theoretical bankroll)
                    initPatternOutcomeDistributionChart(); // Initialize the new pattern outcome distribution chart
                }

                init();
            }

            // Initial check for authentication status on page load
            checkExistingAuth();
        });
    </script>
</body>
</html>
