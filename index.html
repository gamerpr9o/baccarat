<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat AI Pro - Advanced Strategic Advisor</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6a11cb; /* Vibrant Purple */
            --primary-dark: #4a0ba8;
            --primary-light: #8e2de2;
            --secondary: #00c6ff; /* Bright Blue */
            --accent: #ff2d75; /* Hot Pink */
            --success: #00e676; /* Vibrant Green */
            --danger: #ff3d00; /* Bright Red */
            --warning: #ffab00; /* Amber */
            --info: #00b0ff; /* Sky Blue */
            --dark: #121218; /* Dark background */
            --darker: #0a0a0e; /* Even darker */
            --light: #f5f5f7; /* Light text */
            --light-gray: #e0e0e0;
            --medium-gray: #a0a0a0;
            --card-bg: rgba(255, 255, 255, 0.08);
            --panel-bg: rgba(20, 20, 30, 0.95);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, var(--darker), var(--dark));
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Particle background effect */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            background: var(--secondary);
            border-radius: 50%;
            opacity: 0.3;
            animation: float 15s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg);
                opacity: 0.3;
            }
            50% {
                opacity: 0.1;
            }
            100% {
                transform: translateY(-100vh) translateX(100px) rotate(360deg);
                opacity: 0.3;
            }
        }

        /* Auth Overlay - Modern Glass Morphism */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            opacity: 1;
            transition: opacity 0.8s cubic-bezier(0.65, 0.05, 0.36, 1);
        }

        .auth-container {
            background: linear-gradient(145deg, rgba(30, 30, 40, 0.9), rgba(20, 20, 30, 0.95));
            padding: 3.5rem;
            border-radius: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--glass-border);
            text-align: center;
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }

        .auth-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(106, 17, 203, 0.1),
                rgba(0, 198, 255, 0.1),
                rgba(255, 45, 117, 0.1)
            );
            transform: rotate(30deg);
            z-index: -1;
            animation: gradientRotate 15s infinite linear;
        }

        @keyframes gradientRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .auth-title {
            font-size: 2.8rem;
            margin-bottom: 2rem;
            color: var(--light);
            font-weight: 800;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
        }

        .auth-title span {
            color: var(--secondary);
            font-weight: 900;
            text-shadow: 0 0 15px rgba(0, 198, 255, 0.5);
        }

        .auth-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 3px;
        }

        .auth-input-group {
            position: relative;
            margin-bottom: 2rem;
        }

        .auth-input {
            width: 100%;
            padding: 1.2rem 1.5rem;
            padding-left: 3rem;
            margin-bottom: 1.5rem;
            border: none;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.4);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
            outline: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .auth-input:focus {
            border-color: var(--secondary);
            box-shadow: 0 0 0 3px rgba(0, 198, 255, 0.3);
        }

        .auth-input-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--medium-gray);
            transition: all 0.3s ease;
        }

        .auth-input:focus + .auth-input-icon {
            color: var(--secondary);
        }

        .auth-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            border: none;
            padding: 1.2rem 2rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 20px rgba(106, 17, 203, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .auth-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s ease;
        }

        .auth-btn:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(106, 17, 203, 0.7);
        }

        .auth-btn:active {
            transform: translateY(0);
        }

        .auth-message {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            font-weight: 600;
            display: none;
            animation: fadeIn 0.5s ease-out;
            border-left: 4px solid;
        }

        .auth-error {
            background-color: rgba(255, 61, 0, 0.15);
            color: var(--danger);
            border-left-color: var(--danger);
        }

        .auth-success {
            background-color: rgba(0, 230, 118, 0.15);
            color: var(--success);
            border-left-color: var(--success);
        }

        .key-info {
            margin-top: 2rem;
            font-size: 0.9rem;
            line-height: 1.7;
            color: var(--text-secondary);
            text-align: center;
        }

        .time-remaining {
            margin-top: 1.5rem;
            color: var(--warning);
            font-weight: 700;
            display: none;
            font-size: 1rem;
            animation: pulse 2s infinite;
        }

        /* Main Container - Glass Morphism */
        .container {
            max-width: 1800px;
            width: 95%;
            margin: 2rem auto;
            padding: 2rem;
            display: none;
            background: var(--panel-bg);
            border-radius: 24px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            position: relative;
            z-index: 1;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(106, 17, 203, 0.1) 0%, rgba(0, 198, 255, 0.05) 50%, transparent 70%);
            z-index: -1;
            animation: pulseGlow 8s infinite alternate;
        }

        @keyframes pulseGlow {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--glass-border);
            position: relative;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--light);
            display: flex;
            align-items: center;
            letter-spacing: -1px;
            transition: all 0.3s ease;
        }

        .logo span {
            color: var(--secondary);
            margin-left: 8px;
            text-shadow: 0 0 15px rgba(0, 198, 255, 0.5);
        }

        .logo:hover {
            transform: scale(1.02);
        }

        .time-info {
            background: var(--glass-bg);
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            font-size: 0.95rem;
            font-weight: 600;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .time-info:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }

        .time-label {
            opacity: 0.8;
            margin-right: 0.8rem;
            color: var(--text-secondary);
        }

        .time-value {
            color: var(--info);
            font-weight: 700;
        }

        /* Tabs Navigation - Modern */
        .tabs-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 2.5rem;
            gap: 1rem;
            flex-wrap: wrap;
            position: relative;
        }

        .tab-btn {
            background: var(--glass-bg);
            color: var(--text-secondary);
            padding: 1rem 2rem;
            border-radius: 50px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
            font-size: 0.95rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            z-index: -1;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            color: var(--light);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .tab-btn:hover::before {
            opacity: 1;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--light);
            border-color: transparent;
            box-shadow: 0 6px 20px rgba(106, 17, 203, 0.5);
            transform: translateY(-3px);
        }

        .tab-btn.active::before {
            opacity: 1;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.8s ease-out;
            position: relative;
        }

        .tab-content.active {
            display: block;
        }

        /* Panel Styles - Glass Morphism */
        .panel {
            background: var(--panel-bg);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(106, 17, 203, 0.05), rgba(0, 198, 255, 0.05));
            z-index: -1;
        }

        .panel-title {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 1.5rem;
            color: var(--light);
            position: relative;
            padding-bottom: 0.5rem;
            text-align: center;
        }

        .panel-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 3px;
        }

        /* Card Counting Layout */
        .card-counting-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
        }

        .chart-container {
            position: relative;
            overflow: hidden;
            min-height: 500px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
        }

        .chart-controls {
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
        }

        .control-btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            background: var(--primary-dark);
            color: var(--light);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(106, 17, 203, 0.4);
        }

        .control-btn.active {
            background: var(--primary);
            color: var(--light);
            border-color: transparent;
        }

        .chart-area {
            height: 400px;
            position: relative;
            width: 100%;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
        }

        .roadmap {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 12px;
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow-x: auto;
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
        }

        .roadmap::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .roadmap::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .roadmap::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .cell {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.1rem;
            background-color: var(--glass-bg);
            color: var(--light);
            position: relative;
            transition: all 0.3s ease;
            flex-shrink: 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            cursor: pointer;
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .cell.predicted-player {
            background: linear-gradient(135deg, var(--info), #0088cc);
            box-shadow: 0 0 20px rgba(0, 176, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        .cell.predicted-banker {
            background: linear-gradient(135deg, var(--danger), #cc0000);
            box-shadow: 0 0 20px rgba(255, 61, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        .cell.predicted-tie {
            background: linear-gradient(135deg, var(--warning), #ff8f00);
            color: var(--dark);
            box-shadow: 0 0 20px rgba(255, 171, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        /* Analysis Panel */
        .analysis-panel {
            display: flex;
            flex-direction: column;
        }

        .bet-recommendation {
            background: rgba(0, 0, 0, 0.3);
            padding: 2rem;
            border-radius: 16px;
            margin-bottom: 2rem;
            text-align: center;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.5s ease;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            position: relative;
            overflow: hidden;
        }

        .bet-recommendation::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 230, 118, 0.1) 0%, transparent 70%);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .bet-recommendation.bet-suggestion::before {
            opacity: 1;
        }

        .recommendation-text {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 1rem;
            animation: fadeIn 1s ease-out;
        }

        .no-bet {
            color: var(--danger);
        }

        .bet-suggestion {
            color: var(--success);
            animation: pulse 2s infinite;
        }

        .bet-amount {
            font-size: 1.3rem;
            color: var(--warning);
            font-weight: 700;
        }

        .count-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 2rem;
            border-radius: 16px;
            margin-bottom: 2rem;
            border: 1px solid var(--glass-border);
        }

        .count-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--secondary);
        }

        .count-result-value {
            font-size: 3rem;
            font-weight: 900;
            color: var(--light);
            margin-bottom: 1rem;
            animation: bounceIn 1s ease-out;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .count-desc {
            font-size: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            animation: fadeIn 0.8s ease-out;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .player-stat .stat-value { color: var(--info); }
        .banker-stat .stat-value { color: var(--danger); }
        .tie-stat .stat-value { color: var(--warning); }

        .input-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .card-btn {
            padding: 1.2rem 0.5rem;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--glass-bg);
            color: var(--light);
            font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .card-btn:hover {
            background: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(106, 17, 203, 0.4);
            border-color: transparent;
        }

        .clear-btn-container {
            text-align: center;
            margin-top: 1.5rem;
        }

        .btn-secondary {
            background: var(--glass-bg);
            color: var(--light);
            padding: 1rem 2rem;
            border-radius: 50px;
            border: 1px solid var(--glass-border);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .history-container {
            margin-top: auto;
            padding-top: 2rem;
            border-top: 1px solid var(--glass-border);
        }

        .history-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 0.8rem;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(255, 255, 255, 0.1);
        }

        .history-list::-webkit-scrollbar {
            width: 8px;
        }

        .history-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .history-list::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1rem;
            animation: fadeIn 0.5s ease-out;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-outcome {
            font-weight: 700;
        }

        .history-outcome.player { color: var(--info); }
        .history-outcome.banker { color: var(--danger); }
        .history-outcome.tie { color: var(--warning); }

        /* Message Box - Floating Notifications */
        .message-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
            pointer-events: none;
        }

        .message-box {
            padding: 1.2rem 1.5rem;
            border-radius: 12px;
            margin-bottom: 1rem;
            font-weight: 600;
            display: none;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-left: 4px solid;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            transform: translateX(100px);
            animation: slideInRight 0.5s forwards;
        }

        .message-box.error {
            border-left-color: var(--danger);
            background: rgba(255, 61, 0, 0.15);
            color: var(--danger);
        }

        .message-box.success {
            border-left-color: var(--success);
            background: rgba(0, 230, 118, 0.15);
            color: var(--success);
        }

        .message-box.info {
            border-left-color: var(--info);
            background: rgba(0, 176, 255, 0.15);
            color: var(--info);
        }

        .message-box.warning {
            border-left-color: var(--warning);
            background: rgba(255, 171, 0, 0.15);
            color: var(--warning);
        }

        .message-box.show {
            display: block;
            opacity: 1;
            transform: translateX(0);
        }

        /* Pattern Recognition Tab */
        .strategy-content {
            padding: 2rem;
            text-align: center;
        }

        .strategy-content h3 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--secondary);
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
        }

        .strategy-content h3::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 3px;
        }

        .strategy-content p {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .dropdown-container {
            margin-bottom: 2rem;
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 300px;
        }

        .dropdown-button {
            background: var(--glass-bg);
            color: var(--text-secondary);
            padding: 1rem 1.5rem;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .dropdown-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            z-index: 10;
            min-width: 100%;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            padding: 0.5rem 0;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            max-height: 300px;
            overflow-y: auto;
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            padding: 1rem 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .dropdown-item:hover {
            background: rgba(106, 17, 203, 0.2);
            color: var(--light);
        }

        .strategy-input-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 400px;
            margin: 0 auto 2rem;
        }

        .strategy-input {
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.3);
            color: var(--light);
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .strategy-input:focus {
            border-color: var(--secondary);
            box-shadow: 0 0 0 3px rgba(0, 198, 255, 0.2);
        }

        .strategy-btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 1rem 1.8rem;
            border-radius: 50px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(106, 17, 203, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.95rem;
        }

        .strategy-btn:hover {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(0, 198, 255, 0.4);
        }

        .strategy-result {
            margin-top: 2rem;
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--success);
            animation: fadeIn 1s ease-out;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
        }

        /* Masaniello Chart */
        .masaniello-chart-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
        }

        .masaniello-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            width: fit-content;
            margin: 0 auto;
        }

        .masaniello-cell {
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            border-radius: 6px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .masaniello-cell .value {
            font-weight: 800;
            font-size: 0.9rem;
            color: var(--light);
        }

        .masaniello-cell .bet-type {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .masaniello-cell.active-position {
            border: 2px solid var(--warning);
            box-shadow: 0 0 15px var(--warning);
            transform: scale(1.1);
            z-index: 2;
        }

        .masaniello-cell.player-bg { 
            background: linear-gradient(135deg, var(--info), #0088cc);
            color: white;
        }
        .masaniello-cell.banker-bg { 
            background: linear-gradient(135deg, var(--danger), #cc0000);
            color: white;
        }
        .masaniello-cell.sit-out-bg { 
            background: linear-gradient(135deg, var(--medium-gray), #808080);
            color: var(--dark);
        }

        .masaniello-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 1.5rem;
            font-size: 0.9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color-box {
            width: 18px;
            height: 18px;
            border-radius: 4px;
        }

        /* Toggle Switch */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        /* Highlighted elements */
        .highlight-bet-label {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .highlight-bet-amount {
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--warning);
            text-shadow: 0 0 12px rgba(255, 171, 0, 0.5);
            animation: pulse 1.5s infinite alternate;
            padding-left: 0.5rem;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .card-counting-layout {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            
            .chart-area {
                height: 350px;
            }
            
            .roadmap {
                grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
                gap: 10px;
                padding: 1rem;
                max-height: 200px;
            }
            
            .cell {
                width: 45px;
                height: 45px;
                font-size: 1rem;
            }
            
            .recommendation-text {
                font-size: 1.5rem;
            }
            
            .count-result-value {
                font-size: 2.5rem;
            }
            
            .panel-title {
                font-size: 1.6rem;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }
            
            .auth-container {
                padding: 2rem 1.5rem;
                border-radius: 16px;
            }
            
            .auth-title {
                font-size: 2.2rem;
                margin-bottom: 1.5rem;
            }
            
            .container {
                padding: 1.5rem;
                margin: 1rem auto;
                border-radius: 16px;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
                margin-bottom: 1.5rem;
                padding-bottom: 1rem;
            }
            
            .logo {
                font-size: 2rem;
            }
            
            .time-info {
                width: 100%;
                justify-content: center;
                padding: 0.7rem 1rem;
                font-size: 0.9rem;
            }
            
            .tabs-nav {
                gap: 0.5rem;
                margin-bottom: 1.5rem;
            }
            
            .tab-btn {
                padding: 0.8rem 1.2rem;
                font-size: 0.9rem;
            }
            
            .panel {
                padding: 1.5rem;
                border-radius: 16px;
                margin-bottom: 1.5rem;
            }
            
            .panel-title {
                font-size: 1.4rem;
                margin-bottom: 1rem;
            }
            
            .chart-title {
                font-size: 1.2rem;
            }
            
            .chart-controls {
                gap: 0.5rem;
                justify-content: center;
            }
            
            .control-btn {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
            }
            
            .chart-area {
                height: 250px;
            }
            
            .roadmap {
                grid-template-columns: repeat(auto-fill, minmax(35px, 1fr));
                gap: 6px;
                padding: 0.8rem;
                max-height: 150px;
            }
            
            .cell {
                width: 35px;
                height: 35px;
                font-size: 0.9rem;
            }
            
            .bet-recommendation {
                padding: 1.5rem;
                min-height: 120px;
            }
            
            .recommendation-text {
                font-size: 1.2rem;
                margin-bottom: 0.5rem;
            }
            
            .bet-amount {
                font-size: 1rem;
            }
            
            .count-info {
                padding: 1.5rem;
            }
            
            .count-title {
                font-size: 1rem;
            }
            
            .count-result-value {
                font-size: 2rem;
            }
            
            .stats-container {
                gap: 1rem;
                margin-bottom: 1.5rem;
            }
            
            .stat-box {
                padding: 1rem;
            }
            
            .stat-value {
                font-size: 1.5rem;
            }
            
            .input-controls {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                gap: 0.8rem;
            }
            
            .card-btn {
                padding: 1rem 0.5rem;
                font-size: 1rem;
            }
            
            .btn-secondary {
                padding: 0.8rem 1.5rem;
                font-size: 0.95rem;
            }
            
            .history-list {
                max-height: 150px;
            }
            
            .history-item {
                font-size: 0.9rem;
                padding: 0.6rem 0;
            }
            
            .message-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 10px;
            }
            
            .message-box {
                padding: 1rem;
                font-size: 0.9rem;
            }
            
            /* Strategy Tab */
            .strategy-content {
                padding: 1.5rem;
            }
            
            .strategy-content h3 {
                font-size: 1.4rem;
            }
            
            .dropdown-container {
                max-width: 250px;
            }
            
            .dropdown-button {
                padding: 0.8rem 1.2rem;
                font-size: 0.95rem;
            }
            
            .dropdown-item {
                padding: 0.8rem 1.2rem;
                font-size: 0.9rem;
            }
            
            .strategy-input {
                padding: 0.8rem;
                font-size: 0.95rem;
            }
            
            .strategy-btn {
                padding: 0.8rem 1.5rem;
                font-size: 0.95rem;
            }
            
            .strategy-result {
                font-size: 1.3rem;
            }
            
            /* Masaniello */
            .masaniello-cell {
                width: 30px;
                height: 30px;
                font-size: 0.7rem;
            }
            
            .masaniello-legend {
                font-size: 0.8rem;
                gap: 0.8rem;
            }
            
            /* Custom animations */
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            70% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes rubberBand {
            from {
                transform: scale3d(1, 1, 1);
            }
            30% {
                transform: scale3d(1.25, 0.75, 1);
            }
            40% {
                transform: scale3d(0.75, 1.25, 1);
            }
            50% {
                transform: scale3d(1.15, 0.85, 1);
            }
            65% {
                transform: scale3d(0.95, 1.05, 1);
            }
            75% {
                transform: scale3d(1.05, 0.95, 1);
            }
            to {
                transform: scale3d(1, 1, 1);
            }
        }

        /* Custom utility classes */
        .animate-rubber-band {
            animation: rubberBand 0.75s;
        }

        .animate-float {
            animation: float 6s ease-in-out infinite;
        }

        .animate-delay-1 {
            animation-delay: 0.1s;
        }

        .animate-delay-2 {
            animation-delay: 0.2s;
        }

        .animate-delay-3 {
            animation-delay: 0.3s;
        }

        .animate-delay-4 {
            animation-delay: 0.4s;
        }

        .animate-delay-5 {
            animation-delay: 0.5s;
        }

        /* Masaniello Chart container */
        .masaniello-chart-outer-container {
            max-width: 100%;
            overflow-x: auto;
            margin-top: 2rem;
            padding-bottom: 1rem; /* For scrollbar visibility */
        }

        /* New glow for bet recommendation */
        .bet-recommendation.animate-glow {
            animation: pulse-glow 2.8s infinite;
        }
        @keyframes pulse-glow {
            0% { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 0 10px rgba(0, 230, 118, 0.6); }
            50% { box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3), 0 0 25px rgba(0, 230, 118, 1); }
            100% { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 0 10px rgba(0, 230, 118, 0.6); }
        }

        /* Styles for the highlighted next bet amount (Pattern Recognition) */
        .highlight-bet-label {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .highlight-bet-amount {
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--warning);
            text-shadow: 0 0 12px rgba(255, 171, 0, 0.5);
            animation: pulse-light 1.5s infinite alternate ease-in-out;
            padding-left: 0.5rem;
        }
        @keyframes pulse-light {
            0% { text-shadow: 0 0 10px rgba(255, 171, 0, 0.8), 0 0 15px rgba(255, 171, 0, 0.5); transform: scale(1); }
            100% { text-shadow: 0 0 20px rgba(255, 171, 0, 1), 0 0 35px rgba(255, 171, 0, 0.7); transform: scale(1.03); }
        }

    </style>
</head>
<body>
    <!-- Particle Background -->
    <div class="particles" id="particles"></div>

    <!-- Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="auth-container">
            <h1 class="auth-title animate__animated animate__fadeInDown">BAC<span>AI</span> PRO</h1>
            <div class="auth-input-group">
                <i class="fas fa-key auth-input-icon"></i>
                <input type="text" class="auth-input" id="authKeyInput" placeholder="Enter your access key">
            </div>
            <button class="auth-btn" id="authSubmitBtn">
                <i class="fas fa-lock-open"></i> Authenticate
            </button>
            <div class="auth-message" id="authError"></div>
            <div class="auth-message auth-success" id="authSuccess">Authentication successful! Loading...</div>
            <div class="time-remaining" id="timeRemaining"></div>
            <div class="key-info">
                <p>Unlock premium features with an access key. Each key is limited to one device.</p>
                <p>Your key's remaining time will be displayed after successful authentication.</p>
            </div>
        </div>
    </div>

    <!-- Message Box for notifications -->
    <div class="message-container">
        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- Main Application Content -->
    <div class="container" id="mainContent">
        <header>
            <div class="logo animate__animated animate__fadeIn">
                BAC<span>AI</span> <span class="badge">PRO</span>
            </div>
            <div class="time-info" id="timeContainer">
                <span class="time-label"><i class="fas fa-clock"></i> Time Left:</span>
                <span class="time-value" id="timeValue">00:00:00</span>
            </div>
        </header>

        <!-- Strategy Tabs -->
        <nav class="tabs-nav" id="strategyTabs">
            <button class="tab-btn active" data-tab="cardCounting">
                <i class="fas fa-calculator"></i> Card Counting
            </button>
            <button class="tab-btn" data-tab="patternRecognition">
                <i class="fas fa-chart-line"></i> Pattern Recognition
            </button>
        </nav>

        <!-- Card Counting Tab Content -->
        <div id="cardCounting" class="tab-content active">
            <div class="card-counting-layout">
                <div class="panel chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Baccarat Card Sequence & Trend</div>
                        <div class="chart-controls">
                            <button class="control-btn active" id="bigRoadBtn">Big Road</button>
                            <button class="control-btn" id="beadPlateBtn">Bead Plate</button>
                            <button class="control-btn" id="derivativeBtn">Derivative</button>
                        </div>
                    </div>
                    <div class="chart-area" id="chartArea"></div>
                    <div class="roadmap" id="roadmap"></div>
                </div>

                <div class="panel analysis-panel">
                    <h2 class="panel-title">Card Counting Analysis</h2>

                    <div class="bet-recommendation" id="betRecommendation">
                        <div class="recommendation-text no-bet">Enter cards to see prediction</div>
                        <div class="bet-amount" id="betAmount"></div>
                    </div>

                    <div class="count-info">
                        <div class="count-title">Current Running Count:</div>
                        <div class="count-result-value" id="countResultValue">0</div>
                        <div class="count-desc" id="countDesc">This is the numerical result from the counting system.</div>
                    </div>

                    <div class="stats-container">
                        <div class="stat-box player-stat">
                            <div class="stat-value" id="playerBets">0</div>
                            <div class="stat-label">Player Bets</div>
                        </div>
                        <div class="stat-box banker-stat">
                            <div class="stat-value" id="bankerBets">0</div>
                            <div class="stat-label">Banker Bets</div>
                        </div>
                        <div class="stat-box tie-stat">
                            <div class="stat-value" id="tieBets">0</div>
                            <div class="stat-label">Tie Bets</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="totalEntries">0</div>
                            <div class="stat-label">Total Cards Entered</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="entriesNeeded">N/A</div>
                            <div class="stat-label">Cards Needed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="decksRemaining">--</div>
                            <div class="stat-label">Decks Remaining (Est.)</div>
                        </div>
                    </div>

                    <div class="input-controls">
                        <button class="card-btn" data-card-value="A">A</button>
                        <button class="card-btn" data-card-value="2">2</button>
                        <button class="card-btn" data-card-value="3">3</button>
                        <button class="card-btn" data-card-value="4">4</button>
                        <button class="card-btn" data-card-value="5">5</button>
                        <button class="card-btn" data-card-value="6">6</button>
                        <button class="card-btn" data-card-value="7">7</button>
                        <button class="card-btn" data-card-value="8">8</button>
                        <button class="card-btn" data-card-value="9">9</button>
                        <button class="card-btn" data-card-value="10">10/F</button>
                    </div>
                    <div class="clear-btn-container">
                        <button class="btn btn-secondary" id="clearBtn">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>

                    <div class="history-container">
                        <div class="history-title">
                            <i class="fas fa-history"></i> Prediction History
                        </div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition Tab Content -->
        <div id="patternRecognition" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">Pattern Recognition & Betting Strategy</h2>
                <p>Analyze game outcomes and apply a betting progression based on patterns.</p>

                <div class="dropdown-container">
                    <button id="patternDropdownBtn" class="dropdown-button">
                        <span id="selectedPatternText">Select Pattern Method</span>
                        <i class="fas fa-caret-down"></i>
                    </button>
                    <div id="patternDropdownMenu" class="dropdown-menu">
                        <div class="dropdown-item" data-strategy="patternMethod">
                            <i class="fas fa-random"></i> General Pattern Method
                        </div>
                        <div class="dropdown-item" data-strategy="pbpbpbPattern">
                            <i class="fas fa-exchange-alt"></i> PBPBPB Pattern
                        </div>
                        <div class="dropdown-item" data-strategy="dragonPattern">
                            <i class="fas fa-fire"></i> Dragon Pattern (Streaks)
                        </div>
                        <div class="dropdown-item" data-strategy="twosPattern">
                            <i class="fas fa-layer-group"></i> Two-in-a-row Pattern
                        </div>
                        <div class="dropdown-item" data-strategy="masaniello">
                            <i class="fas fa-table"></i> Masaniello
                        </div>
                    </div>
                </div>

                <!-- Pattern Strategy Details and Input -->
                <div id="patternStrategyDetails" class="mt-4 text-left">
                    <p class="text-center text-gray-400">Choose a pattern strategy from the dropdown above to see its description and controls.</p>
                </div>

                <div id="patternInputArea" class="hidden mt-6">
                    <h3 class="text-xl font-bold mb-4 text-primary">Record Game Outcome</h3>
                    <div class="grid grid-cols-3 gap-4 max-w-sm mx-auto">
                        <button class="strategy-btn" data-outcome="banker">
                            <i class="fas fa-landmark"></i> Banker Won
                        </button>
                        <button class="strategy-btn" data-outcome="player">
                            <i class="fas fa-user"></i> Player Won
                        </button>
                        <button class="strategy-btn" data-outcome="tie">
                            <i class="fas fa-equals"></i> Tie
                        </button>
                    </div>
                    <button class="btn-secondary mt-4" id="clearPatternBtn">
                        <i class="fas fa-trash"></i> Clear History
                    </button>
                </div>
                
                <div id="patternAnalysisResult" class="strategy-result hidden">
                    <!-- Pattern specific analysis will be injected here -->
                </div>

                <!-- Toggle for Betting Progression -->
                <div class="switch-container mt-6">
                    <label class="switch">
                        <input type="checkbox" id="enableBettingProgressionToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Enable Betting Progression</span>
                </div>

                <!-- Betting Progression Selection -->
                <div class="hidden" id="patternBettingControls">
                    <h4>Apply Betting Progression</h4>
                    <div class="flex flex-col items-center gap-4 mb-6">
                        <div class="dropdown-container">
                            <button id="bettingProgressionDropdownBtn" class="dropdown-button">
                                <span id="selectedBettingProgressionText">Select System</span>
                                <i class="fas fa-caret-down"></i>
                            </button>
                            <div id="bettingProgressionDropdownMenu" class="dropdown-menu">
                                <div class="dropdown-item" data-system="flatBetting">
                                    <i class="fas fa-equals"></i> Flat Betting
                                </div>
                                <div class="dropdown-item" data-system="martingale">
                                    <i class="fas fa-chart-line"></i> Martingale
                                </div>
                                <div class="dropdown-item" data-system="dalembert">
                                    <i class="fas fa-wave-square"></i> D'Alembert
                                </div>
                                <div class="dropdown-item" data-system="fibonacci">
                                    <i class="fas fa-seedling"></i> Fibonacci
                                </div>
                            </div>
                        </div>
                        <div class="bet-unit-input-group flex items-center gap-2 max-w-xs w-full">
                            <label for="betUnitValueInput" class="text-light text-sm font-semibold">1 Unit = $</label>
                            <input type="number" id="betUnitValueInput" class="strategy-input flex-grow" value="10" min="1" step="10">
                            <button class="strategy-btn px-4 py-2 text-sm" id="setBetUnitValueBtn">Set</button>
                        </div>
                    </div>

                    <div id="patternBettingSystemDetails" class="mt-4 text-left">
                        <p class="text-center text-gray-400">Choose a betting system to manage your wagers.</p>
                    </div>
                    <div id="patternBettingInputArea" class="hidden mt-6">
                        <p class="mt-4 text-light flex justify-center items-baseline">
                            <span class="highlight-bet-label">Next Recommended Bet:</span>
                            <span id="patternNextBetAmount" class="highlight-bet-amount">0 units</span>
                        </p>
                        <p class="text-sm text-gray-400">Current Theoretical Bankroll: <span id="patternCurrentTheoreticalBankroll">$10,000</span></p>
                        <p class="text-sm text-gray-400">Current Base Bet: <span id="patternCurrentBaseBet"></span></p>
                        <button class="btn-secondary mt-4" id="patternResetBettingBtn">
                            <i class="fas fa-sync-alt"></i> Reset System
                        </button>
                    </div>
                </div>
                <!-- Chart Container for Theoretical Bankroll Evolution -->
                <div id="patternChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title">Theoretical Bankroll Evolution</h4>
                    <canvas id="patternAnalysisChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // Create particle background
            function createParticles() {
                const particlesContainer = document.getElementById('particles');
                const particleCount = 30;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    
                    // Random size between 2px and 6px
                    const size = Math.random() * 4 + 2;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    
                    // Random position
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = `${Math.random() * 100}%`;
                    
                    // Random animation duration and delay
                    const duration = Math.random() * 20 + 10;
                    const delay = Math.random() * 5;
                    particle.style.animationDuration = `${duration}s`;
                    particle.style.animationDelay = `${delay}s`;
                    
                    particlesContainer.appendChild(particle);
                }
            }
            
            createParticles();

            // =============================================
            // Authentication System
            // =============================================
            const authOverlay = document.getElementById('authOverlay');
            const mainContent = document.getElementById('mainContent');
            const authKeyInput = document.getElementById('authKeyInput');
            const authSubmitBtn = document.getElementById('authSubmitBtn');
            const authError = document.getElementById('authError');
            const authSuccess = document.getElementById('authSuccess');
            const timeRemaining = document.getElementById('timeRemaining');
            const timeContainer = document.getElementById('timeContainer');

            // Predefined valid keys with expiration periods (in minutes)
            const validKeys = {
                "BAC-AI-2024-K1X7": { expiresIn: 525600 }, // 1 year
                "a": { expiresIn: 60 },    // 60 minutes (1 hour)
                "DEMO-KEY-2": { expiresIn: 1440 },  // 1440 minutes (24 hours)
                "BAC-AI-GOATED-918X": { expiresIn: 50000 },  // Approx 14 days
                "ULTRA-KEY-B": { expiresIn: 24480 } // Approx 17 days
            };

            // Check if a key is expired
            function isKeyExpired(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return true;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);

                return new Date() > expirationDate;
            }

            // Format time as HH:MM:SS
            function formatTime(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            // Calculate remaining time in seconds
            function getRemainingTime(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return 0;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                const now = new Date();

                return Math.max(0, Math.floor((expirationDate - now) / 1000));
            }

            // Enhanced device fingerprinting for security
            async function getDeviceFingerprint() {
                const components = [
                    navigator.userAgent,
                    navigator.platform,
                    navigator.hardwareConcurrency || 'unknown',
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    navigator.languages.join(','),
                    !!navigator.pdfViewerEnabled,
                    navigator.maxTouchPoints || 'unknown'
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('BaccaratAI', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('BaccaratAI', 4, 17);
                const canvasData = canvas.toDataURL();

                let webglData = 'unsupported';
                try {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        webglData = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBG_L) + '|' +
                                   gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBLG);
                    }
                } catch (e) { /* console.error("WebGL fingerprinting failed:", e); */ }

                const combined = components.join('|') + '|' + canvasData + '|' + webglData;
                const msgBuffer = new TextEncoder().encode(combined);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                return 'fp-' + hashHex;
            }

            // Authentication handler with expiration check
            authSubmitBtn.addEventListener('click', async function() {
                const enteredKey = authKeyInput.value.trim();

                if (!validKeys.hasOwnProperty(enteredKey)) {
                    authError.textContent = "Invalid access key";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                    return;
                }

                let keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const deviceFingerprint = await getDeviceFingerprint();

                if (!keyRegistry[enteredKey]) { // Key is being used for the first time
                    const newKeyInfo = {
                        fingerprint: deviceFingerprint,
                        firstUsed: new Date().toISOString(),
                        lastUsed: new Date().toISOString(),
                        expiresIn: validKeys[enteredKey].expiresIn
                    };
                    keyRegistry[enteredKey] = newKeyInfo;
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else if (keyRegistry[enteredKey].fingerprint === deviceFingerprint) { // Key registered to this device
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyRegistry[enteredKey])) {
                        authError.textContent = "This key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.classList.add('animate__shakeX');
                        setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                        return;
                    }
                    keyRegistry[enteredKey].lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else { // Key is registered to a different device
                    authError.textContent = "This key is already in use on another device";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__shakeX');
                    setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                    return;
                }

                // Store successful authentication
                localStorage.setItem('baccaratAuthKey', enteredKey);
                localStorage.setItem('baccaratAuthFingerprint', deviceFingerprint);

                // Show success and remaining time
                const keyInfo = keyRegistry[enteredKey];
                const remainingTimeSeconds = getRemainingTime(keyInfo);

                timeRemaining.textContent = `Expires in: ${formatTime(remainingTimeSeconds)}`;
                timeRemaining.style.display = 'block';

                authError.style.display = 'none';
                authSuccess.style.display = 'block';
                this.disabled = true;
                this.classList.add('animate__animated', 'animate__pulse');

                // Animate out the auth overlay and show main content
                setTimeout(() => {
                    authOverlay.style.opacity = '0';
                    setTimeout(() => {
                        authOverlay.style.display = 'none';
                        mainContent.style.display = 'block';
                        mainContent.classList.add('animate__animated', 'animate__fadeIn');
                        initApp(enteredKey);
                    }, 500);
                }, 1500);
            });

            // Check for existing auth on page load
            async function checkExistingAuth() {
                const savedKey = localStorage.getItem('baccaratAuthKey');
                const savedFingerprint = localStorage.getItem('baccaratAuthFingerprint');

                if (!savedKey || !savedFingerprint) {
                    authKeyInput.focus();
                    return false;
                }

                const currentFingerprint = await getDeviceFingerprint();
                if (savedFingerprint !== currentFingerprint) {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');
                    authError.textContent = "Authentication required: Device mismatch.";
                    authError.style.display = 'block';
                    authKeyInput.focus();
                    return false;
                }

                const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const keyInfo = keyRegistry[savedKey];

                if (keyInfo && keyInfo.fingerprint === currentFingerprint) {
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyInfo)) {
                        localStorage.removeItem('baccaratAuthKey');
                        localStorage.removeItem('baccaratAuthFingerprint');
                        authError.textContent = "Your access key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.value = savedKey;
                        authKeyInput.focus();
                        return false;
                    }

                    keyInfo.lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));

                    authOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                    mainContent.classList.add('animate__animated', 'animate__fadeIn');
                    initApp(savedKey);
                    return true;
                }

                authKeyInput.focus();
                return false;
            }

            // =============================================
            // Baccarat Core Application Functionality
            // =============================================
            function initApp(activeKey) {
                const gameState = {
                    entries: [], // Stores the raw card values entered (e.g., 'A', '2', '10') for Card Counting
                    predictionHistory: [], // Stores the results of predictions for Card Counting
                    chart: null, // Chart.js instance for Card Counting
                    activeKey: activeKey,
                    timer: null,
                    totalDecks: 8, // Assuming 8 decks in a Baccarat shoe
                    cardsDealt: 0, // Track total cards dealt to estimate decks remaining
                    
                    patternBetting: {
                        currentSystem: null,
                        bettingUnitValue: 10, // Default unit value in dollars for theoretical bankroll
                        martingaleBet: 1, // units
                        dalembertBet: 1, // units
                        fibonacciSequence: [1, 1],
                        fibonacciIndex: 0,
                        flatBetAmount: 1, // units
                        theoreticalBankroll: 10000, // ONLY for Pattern Recognition betting simulation
                        isEnabled: false // New state for betting progression toggle
                    },

                    // Pattern Recognition State
                    currentPatternStrategy: null,
                    patternHistory: [], // Stores 'player', 'banker', 'tie' outcomes
                    currentPatternRecommendation: null, // What the pattern strategy suggests to bet on
                    outcomeCounts: { player: 0, banker: 0, tie: 0 }, // For "Pattern Method" prediction
                    masanielloState: {
                        grid: [], // 2D array for the Masaniello chart
                        gridRows: 10, // Max row based on screenshot
                        gridCols: 10, // Max col based on screenshot
                        currentRow: 0, // Current position Y
                        currentCol: 0, // Current position X
                        unitIncrement: 10 // How much each unit represents in betting (e.g., 1 unit = $10)
                    },
                    patternAnalysisChartInstance: null, // Existing Chart.js instance for theoretical bankroll
                    bankrollTimeline: [], // Stores {outcomeIndex: number, bankroll: number, actualOutcome: string}
                };

                // Hardcoded Masaniello grid values and suggested bet types based on the screenshot
                // Format: { value: number, bet: 'player' | 'banker' | 'sit-out' }
                const masanielloGridConfig = [
                    // Row 0 (Losses up to 9)
                    [{value: 0, bet: 'sit-out'}, {value: 1, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 1, bet: 'banker'}, {value: 0, bet: 'banker'}],
                    // Row 1
                    [{value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 1, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}],
                    // Row 2
                    [{value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 2, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 6, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}],
                    // Row 3
                    [{value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 6, bet: 'player'}, {value: 4, bet: 'player'}],
                    // Row 4
                    [{value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 7, bet: 'player'}, {value: 9, bet: 'player'}, {value: 11, bet: 'player'}, {value: 8, bet: 'player'}],
                    // Row 5
                    [{value: 5, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 3, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}], // This row seems special on the screenshot
                    // Row 6
                    [{value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}], // Adjusted based on screenshot layout
                    // Row 7
                    [{value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 9, bet: 'player'}, {value: 8, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    // Row 8
                    [{value: 1, bet: 'player'}, {value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 8, bet: 'player'}, {value: 11, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}], // Adjusted for screenshot accuracy
                    // Row 9 (Last row, assuming 10 rows for example)
                    [{value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 1, bet: 'sit-out'}, {value: 2, bet: 'sit-out'}, {value: 4, bet: 'sit-out'}, {value: 8, bet: 'sit-out'}, {value: 15, bet: 'sit-out'}, {value: 30, bet: 'sit-out'}, {value: 61, bet: 'sit-out'}]
                ];

                const elements = {
                    // General UI
                    roadmap: document.getElementById('roadmap'),
                    chartArea: document.getElementById('chartArea'),
                    messageBox: document.getElementById('messageBox'),
                    strategyTabs: document.getElementById('strategyTabs'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    timeValue: document.getElementById('timeValue'),

                    // Card Counting Tab Elements
                    betRecommendation: document.getElementById('betRecommendation'),
                    betAmount: document.getElementById('betAmount'),
                    countResultValue: document.getElementById('countResultValue'),
                    countDesc: document.getElementById('countDesc'),
                    playerBets: document.getElementById('playerBets'),
                    bankerBets: document.getElementById('bankerBets'),
                    tieBets: document.getElementById('tieBets'),
                    totalEntries: document.getElementById('totalEntries'),
                    entriesNeeded: document.getElementById('entriesNeeded'),
                    decksRemaining: document.getElementById('decksRemaining'),
                    cardButtons: document.querySelectorAll('.card-btn'),
                    clearBtn: document.getElementById('clearBtn'),
                    historyList: document.getElementById('historyList'),

                    // Pattern Recognition Tab Elements
                    patternDropdownBtn: document.getElementById('patternDropdownBtn'),
                    selectedPatternText: document.getElementById('selectedPatternText'),
                    patternDropdownMenu: document.getElementById('patternDropdownMenu'),
                    patternStrategyDetails: document.getElementById('patternStrategyDetails'),
                    patternInputArea: document.getElementById('patternInputArea'),
                    patternOutcomeButtons: document.querySelectorAll('#patternInputArea .strategy-btn'),
                    clearPatternBtn: document.getElementById('clearPatternBtn'),
                    patternAnalysisResult: document.getElementById('patternAnalysisResult'),
                    patternBettingControls: document.getElementById('patternBettingControls'),
                    enableBettingProgressionToggle: document.getElementById('enableBettingProgressionToggle'),
                    patternCurrentTheoreticalBankroll: document.getElementById('patternCurrentTheoreticalBankroll'),

                    // Betting Progression within Pattern Recognition
                    bettingProgressionDropdownBtn: document.getElementById('bettingProgressionDropdownBtn'),
                    selectedBettingProgressionText: document.getElementById('selectedBettingProgressionText'),
                    bettingProgressionDropdownMenu: document.getElementById('bettingProgressionDropdownMenu'),
                    patternBettingSystemDetails: document.getElementById('patternBettingSystemDetails'),
                    patternBettingInputArea: document.getElementById('patternBettingInputArea'),
                    patternNextBetAmount: document.getElementById('patternNextBetAmount'),
                    patternCurrentBaseBet: document.getElementById('patternCurrentBaseBet'),
                    patternResetBettingBtn: document.getElementById('patternResetBettingBtn'),
                    betUnitValueInput: document.getElementById('betUnitValueInput'),
                    setBetUnitValueBtn: document.getElementById('setBetUnitValueBtn'),
                    patternAnalysisChartCanvas: document.getElementById('patternAnalysisChart'),
                    patternChartContainer: document.getElementById('patternChartContainer'),
                };

                // Display a temporary message
                function displayMessage(message, type) {
                    elements.messageBox.textContent = message;
                    elements.messageBox.className = `message-box show ${type} animate__animated animate__fadeInRight`;
                    
                    // Hide the message after 3 seconds with fade out
                    setTimeout(() => {
                        elements.messageBox.classList.remove('show');
                        setTimeout(() => {
                            elements.messageBox.textContent = '';
                        }, 500);
                    }, 3000);
                }

                // Start the countdown timer
                function startTimer() {
                    if (gameState.timer) clearInterval(gameState.timer);

                    updateTimerDisplay(); // Initial update

                    gameState.timer = setInterval(() => {
                        const remaining = updateTimerDisplay();
                        if (remaining <= 0) {
                            clearInterval(gameState.timer);
                            handleKeyExpiration();
                        }
                    }, 1000);
                }

                // Update the timer display and return remaining seconds
                function updateTimerDisplay() {
                    const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                    const keyInfo = keyRegistry[gameState.activeKey];
                    if (!keyInfo) return 0;

                    const expirationDate = new Date(keyInfo.firstUsed);
                    expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);
                    const now = new Date();
                    const remaining = Math.max(0, Math.floor((expirationDate - now) / 1000));
                    
                    elements.timeValue.textContent = formatTime(remaining);

                    if (remaining <= 300) { // 5 minutes or less
                        elements.timeValue.style.color = 'var(--danger)';
                        timeContainer.classList.add('animate__animated', 'animate__pulse');
                    } else if (remaining <= 900) { // 15 minutes or less
                        elements.timeValue.style.color = 'var(--warning)';
                        timeContainer.classList.remove('animate__pulse');
                    } else {
                        elements.timeValue.style.color = 'var(--info)';
                        timeContainer.classList.remove('animate__pulse');
                    }
                    return remaining;
                }

                // Handle key expiration
                function handleKeyExpiration() {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');

                    mainContent.style.display = 'none';
                    authOverlay.style.display = 'flex';
                    authOverlay.style.opacity = '1';
                    authError.textContent = "Your access key has expired. Please renew your subscription.";
                    authError.style.display = 'block';
                    authKeyInput.value = gameState.activeKey;
                    timeRemaining.style.display = 'none';
                    authSubmitBtn.disabled = false;
                    displayMessage('Your session has expired. Please authenticate again.', 'error');
                }

                // Card counting logic (Updated from provided script)
                function getNumericalCardValue(cardValue) {
                    if (cardValue === 'A') return 1;
                    if (cardValue === '10' || cardValue === 'J' || cardValue === 'Q' || cardValue === 'K') return 0;
                    return parseInt(cardValue);
                }

                function getCardCountContribution(cardValue) {
                    // This function is for the High-Low card counting system
                    switch (cardValue) {
                        case 'A': return -1;
                        case '2':
                        case '3': return -1;
                        case '4':
                        case '5': return -5;
                        case '6':
                        case '7': return +5;
                        case '8':
                        case '9': return +1;
                        case '10':
                        case 'J':
                        case 'Q':
                        case 'K': return 0; // 10s and face cards have a value of 0 in High-Low count
                        default: return 0;
                    }
                }

                function calculateRunningCount() {
                    let totalCount = 0;
                    gameState.entries.forEach(card => {
                        totalCount += getCardCountContribution(card);
                    });
                    return totalCount;
                }

                function getPrediction() {
                    const currentCount = calculateRunningCount();
                    let prediction = "no prediction";
                    // Prediction logic based on the provided working script
                    if (currentCount > 5) {
                        prediction = "player";
                    } else if (currentCount < -5) {
                        prediction = "banker";
                    } else if (currentCount >= -5 && currentCount <= 5 && gameState.entries.length > 0) {
                        prediction = "tie";
                    } else {
                        prediction = "no prediction";
                    }
                    return { prediction: prediction, countResult: currentCount };
                }

                // Chart and UI updates for Card Counting
                function initChart() {
                    elements.chartArea.innerHTML = '<canvas id="myChart"></canvas>';
                    const ctx = document.getElementById('myChart');

                    const style = getComputedStyle(document.documentElement);
                    const secondaryColor = style.getPropertyValue('--secondary').trim();
                    const secondaryColorRgba = `rgba(${parseInt(secondaryColor.slice(1,3), 16)}, ${parseInt(secondaryColor.slice(3,5), 16)}, ${parseInt(secondaryColor.slice(5,7), 16)}, 0.1)`;

                    gameState.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Running Count',
                                data: [],
                                borderColor: secondaryColor,
                                backgroundColor: secondaryColorRgba,
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: secondaryColor
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--light)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return `Count: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--light)' }
                                },
                                y: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--light)' }
                                }
                            },
                            animation: {
                                duration: 1200,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updateChart() {
                    const labels = [];
                    const countData = [];
                    let tempCount = 0;
                    gameState.entries.forEach((card, index) => {
                        labels.push(`Card ${index + 1}`);
                        tempCount += getCardCountContribution(card);
                        countData.push(tempCount);
                    });

                    gameState.chart.data.labels = labels;
                    gameState.chart.data.datasets[0].data = countData;
                    gameState.chart.update();
                }

                function updateRoadmap() {
                    elements.roadmap.innerHTML = '';
                    gameState.entries.forEach((card, index) => {
                        const cell = document.createElement('div');
                        cell.className = `cell animate__animated animate__fadeIn`;
                        cell.style.animationDelay = `${index * 0.05}s`;
                        cell.textContent = card === '10' ? '10/F' : card; // Display '10/F' for 10s and Faces

                        // Only apply prediction styling to the most recently added card's cell
                        if (index === gameState.entries.length - 1) {
                            const predictionResult = getPrediction();
                            if (predictionResult && predictionResult.prediction !== "no prediction") {
                                const prediction = predictionResult.prediction;
                                if (prediction === 'player') {
                                    cell.classList.add('predicted-player');
                                } else if (prediction === 'banker') {
                                    cell.classList.add('predicted-banker');
                                } else if (prediction === 'tie') {
                                    cell.classList.add('predicted-tie');
                                }
                                cell.title = `Card ${card} (Current Prediction: ${prediction.toUpperCase()})`;
                            }
                        } else {
                            cell.title = `Card: ${card}`;
                        }
                        elements.roadmap.appendChild(cell);
                    });
                     // Scroll to the end to show the latest entry
                     elements.roadmap.scrollLeft = elements.roadmap.scrollWidth;
                }

                function updateStats() {
                    const playerBets = gameState.predictionHistory.filter(p => p.prediction === 'player').length;
                    const bankerBets = gameState.predictionHistory.filter(p => p.prediction === 'banker').length;
                    const tieBets = gameState.predictionHistory.filter(p => p.prediction === 'tie').length;

                    elements.playerBets.textContent = playerBets;
                    elements.bankerBets.textContent = bankerBets;
                    elements.tieBets.textContent = tieBets;
                    elements.totalEntries.textContent = gameState.entries.length;

                    const totalCardsInShoe = gameState.totalDecks * 52;
                    const cardsRemaining = totalCardsInShoe - gameState.entries.length;
                    const decksRemaining = (cardsRemaining / 52).toFixed(2);
                    elements.decksRemaining.textContent = Math.max(0, parseFloat(decksRemaining));

                    // Show number of entries if there are entries, otherwise 'N/A'
                    elements.entriesNeeded.textContent = gameState.entries.length > 0 ? gameState.entries.length : 'N/A';
                    elements.countResultValue.textContent = calculateRunningCount();
                }

                function updateHistory() {
                    elements.historyList.innerHTML = '';
                    // Display in reverse chronological order
                    gameState.predictionHistory.slice().reverse().forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item animate__animated animate__fadeIn';
                        // Adjust animation delay for better visual flow
                        historyItem.style.animationDelay = `${index * 0.05}s`; 

                        const predictionNum = document.createElement('span');
                        // Calculate hand number based on total history length
                        predictionNum.textContent = `Hand ${gameState.predictionHistory.length - index}`;

                        const result = document.createElement('span');
                        result.className = `history-outcome ${item.prediction}`;
                        let outcomeText = item.prediction.charAt(0).toUpperCase() + item.prediction.slice(1);
                        if (item.countResult !== null) {
                            outcomeText += ` (Count: ${item.countResult})`;
                        }
                        result.textContent = outcomeText;

                        historyItem.appendChild(predictionNum);
                        historyItem.appendChild(result);
                        elements.historyList.appendChild(historyItem);
                    });
                    // Scroll to the top to show the latest history item
                    elements.historyList.scrollTop = 0;
                }

                function updateRecommendation() {
                    const recommendationTextElement = elements.betRecommendation.querySelector('.recommendation-text');
                    const betAmountElement = elements.betAmount;
                    const countResultValueElement = elements.countResultValue;
                    const countDescElement = elements.countDesc;

                    if (gameState.entries.length === 0) {
                        recommendationTextElement.textContent = "Enter cards to see prediction";
                        recommendationTextElement.className = "recommendation-text no-bet";
                        betAmountElement.textContent = "";
                        countResultValueElement.textContent = "0";
                        countDescElement.textContent = "This is the numerical result from the counting system.";
                        elements.betRecommendation.classList.remove('animate-glow');
                        return;
                    }

                    const predictionResult = getPrediction();
                    const countResult = predictionResult.countResult;
                    const absCount = Math.abs(countResult);

                    let betMessage = `Bet ${predictionResult.prediction.charAt(0).toUpperCase() + predictionResult.prediction.slice(1)}`;
                    if (predictionResult.prediction !== "no prediction") {
                        betMessage += ` (Count: ${countResult})`;
                    } else {
                        betMessage = `No clear prediction yet. (Count: ${countResult})`;
                    }


                    recommendationTextElement.textContent = betMessage;
                    if (predictionResult.prediction === "no prediction") {
                        recommendationTextElement.className = "recommendation-text no-bet";
                    } else {
                        recommendationTextElement.className = "recommendation-text bet-suggestion";
                    }

                    // Fixed recommended bet for card counter section
                    const recommendedBet = 500; // This value is fixed as per requirement
                    betAmountElement.textContent = `Suggested Bet: $${recommendedBet.toLocaleString()}`;


                    countResultValueElement.textContent = countResult;

                    let description = "This is the numerical result from the counting system.";
                    if (countResult === 0) {
                        description = "Count is 0: Consider betting Tie, or wait for a clearer edge.";
                    } else if (absCount === 1) {
                        description = "Count is 1 (or -1): Slight edge, proceed with caution.";
                    } else if (absCount >= 2 && absCount <= 5) {
                        description = "Count is 2-5 (or -2 to -5): Moderate edge, increased bet suggested.";
                    } else if (absCount >= 6 && absCount <= 9) {
                        description = "Count is 6-9 (or -6 to -9): Significant edge, higher bets recommended.";
                    } else if (absCount >= 10 && absCount <= 14) {
                        description = "Count is 10-14 (or -10 to -14): Strong edge, significant bets advisable.";
                    } else if (absCount >= 15) {
                        description = "Count is 15+ (or -15+): Very strong edge, maximum bets recommended!";
                    }
                    countDescElement.textContent = description;

                    elements.betRecommendation.classList.add('animate-glow');
                    setTimeout(() => {
                        elements.betRecommendation.classList.remove('animate-glow');
                    }, 2000);

                    // Only add to history if there's a valid prediction (not "no prediction")
                    if (predictionResult.prediction !== "no prediction") {
                        gameState.predictionHistory.push({
                            prediction: predictionResult.prediction,
                            countResult: predictionResult.countResult,
                            timestamp: new Date().toLocaleTimeString()
                        });
                        updateHistory();
                    }
                    updateChart();
                }

                // Add new card entry
                function addCardEntry(cardValue) {
                    gameState.entries.push(cardValue);
                    updateStats();
                    updateRoadmap();
                    updateRecommendation();
                    displayMessage(`Card '${cardValue}' added.`, 'success');
                }

                // Clear all history and reset state for Card Counting
                function clearAllCardCounting() {
                    gameState.entries = [];
                    gameState.predictionHistory = [];
                    gameState.cardsDealt = 0;

                    updateRoadmap();
                    updateChart();
                    updateStats();
                    updateHistory();

                    elements.betRecommendation.querySelector('.recommendation-text').textContent = "Enter cards to see prediction";
                    elements.betRecommendation.querySelector('.recommendation-text').className = "recommendation-text no-bet";
                    elements.betAmount.textContent = "";
                    elements.countResultValue.textContent = "0";
                    elements.countDesc.textContent = "This is the numerical result from the counting system.";

                    elements.roadmap.classList.add('animate__fadeOut');
                    elements.chartArea.classList.add('animate__fadeOut');
                    setTimeout(() => {
                        elements.roadmap.classList.remove('animate__fadeOut');
                        elements.chartArea.classList.remove('animate__fadeOut');
                        elements.roadmap.classList.add('animate__fadeIn');
                        elements.chartArea.classList.add('animate__fadeIn');
                        setTimeout(() => {
                            elements.roadmap.classList.remove('animate__fadeIn');
                            elements.chartArea.classList.remove('animate__fadeIn');
                        }, 500);
                    }, 500);
                    displayMessage('Card Counting data cleared.', 'success');
                }

                // Event Listeners for Card Counting
                elements.cardButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const cardValue = this.dataset.cardValue;
                        addCardEntry(cardValue);
                        this.classList.add('animate__rubberBand');
                        setTimeout(() => {
                            this.classList.remove('animate__rubberBand');
                        }, 1000);
                    });
                });

                elements.clearBtn.addEventListener('click', function() {
                    clearAllCardCounting();
                    this.classList.add('animate__shakeX');
                    setTimeout(() => {
                        this.classList.remove('animate__shakeX');
                    }, 1000);
                });

                // =============================================
                // Tab Switching Logic
                // =============================================
                elements.strategyTabs.addEventListener('click', function(event) {
                    if (event.target.classList.contains('tab-btn')) {
                        const clickedTab = event.target;
                        const targetTabId = clickedTab.dataset.tab;

                        // Remove 'active' from all tab buttons and content
                        elements.strategyTabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                        elements.tabContents.forEach(content => content.classList.remove('active'));

                        // Add 'active' to the clicked tab button and its content
                        clickedTab.classList.add('active');
                        document.getElementById(targetTabId).classList.add('active');

                        // Reinitialize charts if tab is switched to them
                        if (targetTabId === 'cardCounting' && (!gameState.chart || !elements.chartArea.querySelector('canvas'))) {
                            initChart();
                            updateChart();
                            updateRoadmap();
                            updateStats();
                            updateHistory();
                            updateRecommendation();
                        } else if (targetTabId === 'patternRecognition') {
                            // Ensure chart is initialized when switching to pattern recognition if needed
                            if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem) {
                                elements.patternChartContainer.classList.remove('hidden');
                                if (!gameState.patternAnalysisChartInstance) {
                                    initPatternAnalysisChart();
                                }
                                updatePatternAnalysisChart();
                            } else {
                                elements.patternChartContainer.classList.add('hidden');
                            }
                        }
                    }
                });

                // Initialize the card counting chart on app start
                initChart();
                updateRecommendation(); // Initial state of recommendation

                // =============================================
                // Pattern Recognition Tab Functionality (Updated from provided script)
                // =============================================

                const patternStrategies = {
                    patternMethod: {
                        name: "General Pattern Method",
                        description: "This method tracks the overall win/loss ratio of Player and Banker outcomes. It suggests betting on the side with a higher historical probability or on a trend identified by majority wins. Ties are generally ignored for pattern analysis but affect theoretical bankroll.",
                        getRecommendation: () => {
                            const recentHistory = gameState.patternHistory.slice(-15);
                            if (recentHistory.length === 0) return 'sit-out';

                            const counts = { player: 0, banker: 0, tie: 0 };
                            recentHistory.forEach(outcome => {
                                counts[outcome]++;
                            });

                            if (counts.player > counts.banker) {
                                return 'player';
                            } else if (counts.banker > counts.player) {
                                return 'banker';
                            } else {
                                // If equal or no clear majority, default to banker or sit-out
                                return 'banker'; 
                            }
                        }
                    },
                    pbpbpbPattern: {
                        name: "PBPBPB Pattern (Alternating)",
                        description: "This strategy looks for an alternating pattern (Player, Banker, Player, Banker...). If the last two outcomes were different (e.g., P then B), it predicts the next one will continue the alternation. If they were the same, it suggests a break in pattern and thus a 'sit-out' or 'no clear pattern'.",
                        getRecommendation: () => {
                            const historyLength = gameState.patternHistory.length;
                            if (historyLength < 2) return 'sit-out'; // Not enough history for a pattern

                            const lastOutcome = gameState.patternHistory[historyLength - 1];
                            const secondLastOutcome = gameState.patternHistory[historyLength - 2];

                            // If they are different (P, B) or (B, P), predict the opposite of the last one
                            if (lastOutcome !== secondLastOutcome) {
                                return lastOutcome === 'player' ? 'banker' : 'player';
                            }
                            // If they are the same (P, P) or (B, B), the alternating pattern is broken
                            return 'sit-out';
                        }
                    },
                    dragonPattern: {
                        name: "Dragon Pattern (Streaks)",
                        description: "The Dragon Pattern focuses on streaks. If there have been 3 or more consecutive Player wins (Dragon Tail) or Banker wins (Banker Dragon), it suggests betting on that same side to continue the streak. Otherwise, it suggests 'sit-out'.",
                        getRecommendation: () => {
                            const history = gameState.patternHistory;
                            const historyLength = history.length;
                            if (historyLength < 3) return 'sit-out'; // Not enough history for a streak of 3

                            const lastOutcome = history[historyLength - 1];
                            const secondLastOutcome = history[historyLength - 2];
                            const thirdLastOutcome = history[historyLength - 3];

                            // Check for a streak of 3 or more of the same outcome (excluding ties for streak counting)
                            if (lastOutcome !== 'tie' && lastOutcome === secondLastOutcome && secondLastOutcome === thirdLastOutcome) {
                                return lastOutcome; // Recommend continuing the streak
                            }
                            return 'sit-out'; // No clear dragon pattern
                        }
                    },
                    twosPattern: {
                        name: "Two-in-a-row Pattern",
                        description: "This strategy looks for outcomes occurring in pairs. If two of the same outcomes are followed by a switch (e.g., PPB or BBP), it anticipates a continuation of the *single* outcome (e.g., B for PPB, P for BBP). Otherwise, it suggests 'sit-out'.",
                        getRecommendation: () => {
                            const history = gameState.patternHistory;
                            const historyLength = history.length;
                            if (historyLength < 3) return 'sit-out'; // Need at least 3 outcomes for PPB or BBP

                            const lastOutcome = history[historyLength - 1];
                            const secondLastOutcome = history[historyLength - 2];
                            const thirdLastOutcome = history[historyLength - 3];

                            // Pattern: Third-last and second-last are the same (P P or B B), but different from last (B or P).
                            // Example: P P B. Here, third=P, second=P, last=B. The pattern suggests next is B.
                            if (thirdLastOutcome !== 'tie' && secondLastOutcome !== 'tie' && lastOutcome !== 'tie' &&
                                thirdLastOutcome === secondLastOutcome && thirdLastOutcome !== lastOutcome) {
                                return lastOutcome; // Recommend continuing the single outcome after the pair
                            }
                            return 'sit-out';
                        }
                    },
                    masaniello: {
                        name: "Masaniello Progression",
                        description: `Masaniello is a complex money management system that aims to maximize profits while limiting losses over a series of bets. It requires setting an initial bankroll, a target profit, and the number of anticipated successful events. The chart guides your bet unit based on your current position (wins/losses).`,
                        getRecommendation: () => {
                            const state = gameState.masanielloState;
                            if (state.grid.length === 0) return { bet: null, reason: "Masaniello grid not initialized. Please configure." };

                            const currentCell = masanielloGridConfig[state.currentRow][state.currentCol]; // Always use the base config for data
                            if (!currentCell) return { bet: 'sit-out', reason: "Invalid Masaniello grid position. Reset needed." }; // Default to sit-out if position is invalid
                            
                            const betType = currentCell.bet;
                            const betValue = currentCell.value * state.unitIncrement;

                            if (betType === 'sit-out') {
                                return { bet: 'sit-out', reason: `Masaniello recommends sitting out. Next bet: $${betValue}.` };
                            } else {
                                return { bet: betType, reason: `Masaniello recommends betting ${betType.toUpperCase()}. Next bet: $${betValue}.` };
                            }
                        }
                    }
                };

                const bettingSystems = {
                    flatBetting: {
                        name: "Flat Betting",
                        description: "In Flat Betting, you wager the same amount (your base unit) on every hand, regardless of previous wins or losses. It's the simplest and lowest-risk system.",
                        getNextBet: () => gameState.patternBetting.flatBetAmount,
                        handleOutcome: (outcome, betTarget) => {
                            // Flat betting doesn't change next bet amount, only theoretical bankroll
                            // No state change needed here for flat betting
                        },
                        reset: () => {
                            gameState.patternBetting.flatBetAmount = 1;
                        }
                    },
                    martingale: {
                        name: "Martingale",
                        description: "The Martingale system involves doubling your bet after every loss, aiming to recover all previous losses with a single win. After a win, you return to your original base bet. This system requires a large bankroll and can be risky.",
                        getNextBet: () => gameState.patternBetting.martingaleBet, // returns units
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.martingaleBet = 1; // Reset to base bet
                            } else if (outcome !== 'tie') { // Loss (and not a tie)
                                gameState.patternBetting.martingaleBet *= 2; // Double bet on loss
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.martingaleBet = 1;
                        }
                    },
                    dalembert: {
                        name: "D'Alembert",
                        description: "The D'Alembert system is a negative progression strategy where you increase your bet by one unit after a loss and decrease it by one unit after a win. It's less aggressive than Martingale.",
                        getNextBet: () => Math.max(1, gameState.patternBetting.dalembertBet), // returns units, minimum 1
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.dalembertBet = Math.max(1, gameState.patternBetting.dalembertBet - 1); // Decrease on win, minimum 1
                            } else if (outcome !== 'tie') { // Loss (and not a tie)
                                gameState.patternBetting.dalembertBet += 1; // Increase on loss
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.dalembertBet = 1;
                        }
                    },
                    fibonacci: {
                        name: "Fibonacci",
                        description: "The Fibonacci system uses the Fibonacci sequence (1, 1, 2, 3, 5, 8...) to determine bet amounts. After a loss, you move to the next number in the sequence. After a win, you move back two numbers. It's a less aggressive negative progression than Martingale.",
                        getNextBet: () => gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex], // returns units
                        handleOutcome: (outcome, betTarget) => {
                            if (outcome === betTarget) {
                                gameState.patternBetting.fibonacciIndex = Math.max(0, gameState.patternBetting.fibonacciIndex - 2);
                            } else if (outcome !== 'tie') { // Loss (and not a tie)
                                gameState.patternBetting.fibonacciIndex++;
                                if (gameState.patternBetting.fibonacciIndex >= gameState.patternBetting.fibonacciSequence.length) {
                                    const nextFib = gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex - 1] +
                                                    gameState.patternBetting.fibonacciSequence[gameState.patternBetting.fibonacciIndex - 2];
                                    gameState.patternBetting.fibonacciSequence.push(nextFib);
                                }
                            }
                        },
                        reset: () => {
                            gameState.patternBetting.fibonacciSequence = [1, 1];
                            gameState.patternBetting.fibonacciIndex = 0;
                        }
                    }
                };

                // Pattern Recognition Dropdown Logic
                elements.patternDropdownBtn.addEventListener('click', () => {
                    elements.patternDropdownMenu.classList.toggle('show');
                });

                elements.patternDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        const strategyKey = event.target.dataset.strategy;
                        gameState.currentPatternStrategy = strategyKey;
                        elements.selectedPatternText.textContent = patternStrategies[strategyKey].name;
                        elements.patternDropdownMenu.classList.remove('show');
                        
                        // Update strategy details
                        updatePatternDetails();

                        elements.patternInputArea.classList.remove('hidden'); // Show outcome recording buttons
                        elements.patternAnalysisResult.classList.add('hidden'); // Hide previous result
                        
                        // Initialize pattern specific states
                        gameState.patternHistory = []; // Reset history for new strategy
                        gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                        if (strategyKey === 'masaniello') {
                            initMasanielloGrid(); // Initialize Masaniello grid state
                            drawMasanielloGrid(); // Draw the Masaniello grid
                        } else {
                            // Remove Masaniello grid if it exists and a non-Masaniello strategy is selected
                            const existingMasanielloGridContainer = document.getElementById('masanielloChartContainer');
                            if(existingMasanielloGridContainer) {
                                existingMasanielloGridContainer.remove();
                            }
                        }
                        updatePatternCharts(); // Update chart visibility
                    }
                });

                // Close dropdown if clicked outside
                window.addEventListener('click', (event) => {
                    if (!elements.patternDropdownBtn.contains(event.target) && !elements.patternDropdownMenu.contains(event.target)) {
                        elements.patternDropdownMenu.classList.remove('show');
                    }
                    if (!elements.bettingProgressionDropdownBtn.contains(event.target) && !elements.bettingProgressionDropdownMenu.contains(event.target)) {
                        elements.bettingProgressionDropdownMenu.classList.remove('show');
                    }
                });

                // Record Pattern Outcome - FIX APPLIED HERE
                elements.patternOutcomeButtons.forEach(button => {
                    button.addEventListener('click', function() { // Changed to a regular function
                        const outcome = this.dataset.outcome; // 'this' correctly refers to the button
                        recordPatternOutcome(outcome);
                        this.classList.add('animate__pulse');
                        setTimeout(() => this.classList.remove('animate__pulse'), 500);
                    });
                });

                // Clear Pattern History
                elements.clearPatternBtn.addEventListener('click', () => {
                    clearPatternHistory();
                });

                // Update pattern strategy details section content (copied from provided script)
                function updatePatternDetails() {
                    let detailsHtml = '';
                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            detailsHtml = `<p>This "General Pattern Method" provides an intuitive suggestion for your next bet. It adapts to the flow of the game to guide your decisions by tracking the overall win/loss ratio of Player and Banker outcomes.</p>`;
                            break;
                        case 'pbpbpbPattern':
                            detailsHtml = `<p>This strategy looks for a repeating Player-Banker-Player-Banker (PBPBPB) sequence. If identified, it suggests betting on the continuation of this alternating pattern. If the pattern is broken, it recommends a "sit-out".</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="pbpbpbHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'dragonPattern':
                            detailsHtml = `<p>The Dragon Pattern strategy identifies streaks of three or more consecutive Player or Banker wins. It recommends betting on the continuation of the current streak. If no clear streak is found, it suggests a "sit-out".</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="dragonHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'twosPattern':
                            detailsHtml = `<p>The Two-in-a-row Pattern strategy looks for sequences where an outcome appears twice, then switches (e.g., P P B, B B P). It anticipates a continuation of the *single* outcome (e.g., B for PPB, P for BBP). Otherwise, it suggests 'sit-out'.</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="twosHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'masaniello':
                            detailsHtml = `<p>The Masaniello staking plan aims to maximize profit and manage risk within a series of bets. It requires setting an initial bankroll, a target profit, and the number of anticipated successful events. The chart guides your bet unit based on your current position (wins/losses).</p>
                                           <h4 class="font-semibold mt-4 text-medium">Masaniello Chart</h4>
                                           <p class="text-sm text-gray-500 mt-1">Current Position: [Col <span id="masanielloCurrentCol">${gameState.masanielloState.currentCol}</span>, Row <span id="masanielloCurrentRow">${gameState.masanielloState.currentRow}</span>]</p>
                                           <div class="masaniello-chart-container">
                                               <div id="masanielloGrid" class="masaniello-grid"></div>
                                               <div class="masaniello-legend">
                                                   <div class="legend-item"><span class="legend-color-box player-bg"></span> Player Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box banker-bg"></span> Banker Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box sit-out-bg"></span> Sit Out</div>
                                               </div>
                                           </div>`;
                            break;
                        default:
                            detailsHtml = `<p class="text-center text-gray-400">Choose a pattern strategy from the dropdown above to see its description and controls.</p>`;
                    }
                    elements.patternStrategyDetails.innerHTML = detailsHtml;
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        drawMasanielloGrid();
                    }
                    updatePatternAnalysis();
                }

                // Masaniello Grid Initialization and Drawing (Copied from provided script)
                function initMasanielloGrid() {
                    gameState.masanielloState.grid = JSON.parse(JSON.stringify(masanielloGridConfig)); // Deep copy
                    gameState.masanielloState.currentRow = masanielloGridConfig.length - 1; // Start at bottom row
                    gameState.masanielloState.currentCol = 0; // Start at first column
                }

                function drawMasanielloGrid() {
                    const gridElement = document.getElementById('masanielloGrid');
                    if (!gridElement) return;

                    gridElement.innerHTML = '';
                    // Iterate rows in reverse to draw from bottom up as in screenshot
                    for (let r = gameState.masanielloState.gridRows - 1; r >= 0; r--) {
                        for (let c = 0; c < gameState.masanielloState.gridCols; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'masaniello-cell';
                            const cellData = masanielloGridConfig[r][c]; // Use fixed config for cell data

                            cell.innerHTML = `<span class="value">${cellData.value}</span><span class="bet-type">${cellData.bet.replace('-', ' ').toUpperCase()}</span>`;

                            // Add background color class based on bet type
                            if (cellData.bet === 'player') {
                                cell.classList.add('player-bg');
                            } else if (cellData.bet === 'banker') {
                                cell.classList.add('banker-bg');
                            } else if (cellData.bet === 'sit-out') {
                                cell.classList.add('sit-out-bg');
                            }

                            if (r === gameState.masanielloState.currentRow && c === gameState.masanielloState.currentCol) {
                                cell.classList.add('active-position');
                            }
                            gridElement.appendChild(cell);
                        }
                    }
                    const masanielloCurrentCol = document.getElementById('masanielloCurrentCol');
                    const masanielloCurrentRow = document.getElementById('masanielloCurrentRow');
                    if (masanielloCurrentCol) masanielloCurrentCol.textContent = gameState.masanielloState.currentCol;
                    if (masanielloCurrentRow) masanielloCurrentRow.textContent = gameState.masanielloState.currentRow;
                }

                function updateMasanielloPosition(outcome) {
                    let { currentRow, currentCol, gridRows, gridCols } = gameState.masanielloState;
                    const currentCell = masanielloGridConfig[currentRow][currentCol]; // Get data from fixed config

                    // Determine if the actual outcome resulted in a win, loss, or push for the current Masaniello bet type
                    let resultForMasaniello = 'push'; // Default to push for ties or sit-out
                    if (currentCell.bet === outcome) {
                        resultForMasaniello = 'win';
                    } else if (currentCell.bet !== 'sit-out' && outcome !== 'tie' && currentCell.bet !== outcome) {
                        // This is a loss if we bet Player/Banker and the other side won (or Tie didn't happen)
                        resultForMasaniello = 'loss';
                    }
                    
                    if (resultForMasaniello === 'win') {
                        currentRow = Math.max(0, currentRow - 1); // Move up on win
                    } else if (resultForMasaniello === 'loss') {
                        currentCol = Math.min(gridCols - 1, currentCol + 1); // Move right on loss
                    }
                    
                    // Clamp values to ensure they stay within grid boundaries
                    currentRow = Math.max(0, Math.min(gridRows - 1, currentRow));
                    currentCol = Math.max(0, Math.min(gridCols - 1, currentCol));

                    gameState.masanielloState.currentRow = currentRow;
                    gameState.masanielloState.currentCol = currentCol;
                    drawMasanielloGrid();
                }


                function recordPatternOutcome(outcome) {
                    gameState.patternHistory.push(outcome);
                    gameState.outcomeCounts[outcome]++;
                    displayMessage(`Outcome: ${outcome.toUpperCase()} recorded.`, 'info');

                    let bettingOutcomeType = null; // Will be 'win', 'loss', or 'push' for theoretical bankroll update
                    let impliedBetTarget = null; // What the pattern strategy suggested to bet on for this round

                    // Determine impliedBetTarget based on current strategy
                    const currentStrategy = patternStrategies[gameState.currentPatternStrategy];
                    const recommendationResult = currentStrategy.getRecommendation();
                    
                    // If a pattern strategy returns a string (like 'player', 'banker', 'sit-out', or 'no_clear_pattern')
                    if (typeof recommendationResult === 'string') {
                        impliedBetTarget = (recommendationResult === 'no_clear_pattern') ? 'sit-out' : recommendationResult;
                    } else if (typeof recommendationResult === 'object' && recommendationResult !== null && recommendationResult.bet) {
                        // For Masaniello which returns an object {bet, reason}
                        impliedBetTarget = recommendationResult.bet;
                    } else {
                        impliedBetTarget = 'sit-out'; // Default to sit-out if no valid recommendation
                    }
                    
                    gameState.currentPatternRecommendation = impliedBetTarget; // Store for theoretical bankroll update

                    // Determine win/loss/push for theoretical bankroll based on implied bet target
                    if (impliedBetTarget === 'sit-out') {
                        bettingOutcomeType = 'push'; // Always a push if strategy recommends sitting out
                    } else if (outcome === 'tie') {
                        bettingOutcomeType = 'push'; // Player/Banker bets are a push on a Tie
                    } else if (impliedBetTarget === outcome) {
                        bettingOutcomeType = 'win';
                    } else {
                        bettingOutcomeType = 'loss';
                    }

                    // For Masaniello, explicitly update its position before theoretical bankroll is updated
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        // Pass the actual outcome to updateMasanielloPosition
                        updateMasanielloPosition(outcome);
                    }

                    updatePatternAnalysis();
                    
                    if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem && impliedBetTarget !== null) {
                        // Pass the betOutcomeType and impliedBetTarget to updateTheoreticalBankroll
                        updateTheoreticalBankroll(bettingOutcomeType, impliedBetTarget, outcome);
                    } else if (gameState.patternBetting.isEnabled && (gameState.currentPatternStrategy === 'patternMethod' || gameState.currentPatternStrategy === 'masaniello' || gameState.currentPatternStrategy === 'dragonPattern' || gameState.currentPatternStrategy === 'twosPattern' || gameState.currentPatternStrategy === 'pbpbpbPattern') && !gameState.patternBetting.currentSystem) {
                        displayMessage('Select a betting progression system to apply it automatically!', 'warning');
                    }
                }

                function updatePatternAnalysis() {
                    const resultDiv = elements.patternAnalysisResult;
                    resultDiv.classList.remove('hidden');
                    resultDiv.innerHTML = '';

                    let recommendationText = '';
                    if (gameState.patternHistory.length === 0) {
                        resultDiv.innerHTML = `<p class="text-gray-400">No outcomes recorded yet. Enter Banker, Player, or Tie to start.</p>`;
                        return;
                    }

                    const currentStrategy = patternStrategies[gameState.currentPatternStrategy];
                    const recommendationResult = currentStrategy.getRecommendation();
                    
                    let actualRecommendation = '';
                    if (typeof recommendationResult === 'string') {
                        actualRecommendation = recommendationResult;
                    } else if (typeof recommendationResult === 'object' && recommendationResult !== null && recommendationResult.bet) {
                        actualRecommendation = recommendationResult.bet;
                    }

                    if (actualRecommendation === 'no_clear_pattern' || actualRecommendation === 'sit-out' || actualRecommendation === null) {
                        recommendationText = `Recommendation: <span class="text-gray-400 font-bold">NO CLEAR PATTERN / SIT OUT</span>`;
                    } else {
                        recommendationText = `Next recommended bet: <span class="text-success font-bold">${actualRecommendation.toUpperCase()}</span>`;
                    }
                    
                    resultDiv.innerHTML = `<p class="text-info mt-2">${recommendationText}</p>
                                           <p class="text-sm text-gray-500 mt-2">${currentStrategy.description}</p>`;

                    // Update dynamic history displays for relevant strategies
                    if (gameState.currentPatternStrategy === 'pbpbpbPattern') {
                        const pbpbHistorySpan = document.getElementById('pbpbpbHistory');
                        if (pbpbHistorySpan) pbpbHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (gameState.currentPatternStrategy === 'dragonPattern') {
                        const dragonHistorySpan = document.getElementById('dragonHistory');
                        if (dragonHistorySpan) dragonHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    } else if (gameState.currentPatternStrategy === 'twosPattern') {
                        const twosHistorySpan = document.getElementById('twosHistory');
                        if (twosHistorySpan) twosHistorySpan.textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                    }
                    
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        drawMasanielloGrid(); // Ensure grid is always updated
                        const currentCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                        let suggestedBetDisplay = currentCell.bet === 'sit-out' ? 'SIT OUT' : currentCell.bet.toUpperCase();
                        resultDiv.innerHTML = `<p class="text-light">Masaniello Chart displays your current staking position.</p>
                                            <p class="text-warning font-bold mt-2">Suggested Bet Unit: ${currentCell.value}</p>
                                            <p class="text-info font-bold mt-2">Suggested Bet Type: ${suggestedBetDisplay}</p>
                                            <p class="text-sm text-gray-500">Track your progress on the grid above.</p>`;
                    }

                    // Only update the betting display if progression is enabled
                    if (gameState.patternBetting.isEnabled) {
                        updatePatternNextBetDisplay();
                    }
                    updatePatternCharts();
                }

                function clearPatternHistory() {
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;
                    displayMessage('Pattern history cleared.', 'success');
                    
                    initMasanielloGrid(); // Reset Masaniello state
                    updatePatternDetails(); // Re-render initial details
                    
                    resetPatternBettingSystem(); // Reset betting progression state
                }

                // Betting Progression Logic
                elements.enableBettingProgressionToggle.addEventListener('change', (event) => {
                    gameState.patternBetting.isEnabled = event.target.checked;
                    if (gameState.patternBetting.isEnabled) {
                        elements.patternBettingControls.classList.remove('hidden');
                        if (gameState.patternBetting.currentSystem) {
                            elements.patternBettingInputArea.classList.remove('hidden');
                            elements.patternChartContainer.classList.remove('hidden');
                            // Initial update when enabled, ensures chart and next bet display correctly
                            updatePatternNextBetDisplay(); 
                            updatePatternAnalysisChart();
                        }
                    } else {
                        elements.patternBettingControls.classList.add('hidden');
                        elements.patternBettingInputArea.classList.add('hidden');
                        elements.patternChartContainer.classList.add('hidden');
                    }
                    updatePatternCharts(); // Update chart visibility
                });

                elements.setBetUnitValueBtn.addEventListener('click', () => {
                    const newValue = parseInt(elements.betUnitValueInput.value);
                    if (!isNaN(newValue) && newValue > 0) {
                        gameState.patternBetting.bettingUnitValue = newValue;
                        displayMessage(`Betting unit set to $${newValue}.`, 'success');
                        updatePatternNextBetDisplay();
                    } else {
                        displayMessage('Betting unit must be a positive number.', 'error');
                    }
                });

                elements.bettingProgressionDropdownBtn.addEventListener('click', () => {
                    elements.bettingProgressionDropdownMenu.classList.toggle('show');
                });

                elements.bettingProgressionDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        const systemKey = event.target.dataset.system;
                        gameState.patternBetting.currentSystem = systemKey;
                        elements.selectedBettingProgressionText.textContent = bettingSystems[systemKey].name;
                        elements.bettingProgressionDropdownMenu.classList.remove('show');

                        // Update betting system details
                        updatePatternBettingSystemDetails();

                        elements.patternBettingInputArea.classList.remove('hidden');
                        elements.patternChartContainer.classList.remove('hidden');
                        
                        resetPatternBettingSystem(); // Reset when switching systems
                        updatePatternNextBetDisplay();
                        updatePatternCharts();
                    }
                });

                elements.patternResetBettingBtn.addEventListener('click', () => {
                    resetPatternBettingSystem();
                    updatePatternCharts();
                    displayMessage('Betting system reset.', 'info');
                });

                function resetPatternBettingSystem() {
                    // Reset properties to their initial values
                    gameState.patternBetting.martingaleBet = 1;
                    gameState.patternBetting.dalembertBet = 1;
                    gameState.patternBetting.fibonacciSequence = [1, 1];
                    gameState.patternBetting.fibonacciIndex = 0;
                    gameState.patternBetting.flatBetAmount = 1; // Assuming 1 is default
                    gameState.patternBetting.theoreticalBankroll = 10000;
                    gameState.bankrollTimeline = [];

                    // Reset Masaniello state if it was the selected strategy
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        gameState.masanielloState.currentRow = masanielloGridConfig.length - 1; // Start at bottom row
                        gameState.masanielloState.currentCol = 0;
                        drawMasanielloGrid(); // Redraw grid to reset active position
                    }
                    
                    updatePatternNextBetDisplay();
                    updatePatternAnalysisChart(); // Clear/reset chart
                }
                
                // Function to update theoretical bankroll
                function updateTheoreticalBankroll(bettingOutcomeType, impliedBetTarget, actualOutcome) {
                    let betUnits = 0;
                    const pb = gameState.patternBetting;

                    // If the implied bet target was 'sit-out', no actual bet was made for theoretical bankroll purposes
                    if (impliedBetTarget === 'sit-out') {
                        displayMessage('Theoretical push (strategy recommended sit out). Bankroll unchanged.', 'info');
                        // Still record the point for the chart, but with no change in bankroll
                        gameState.bankrollTimeline.push({
                            outcomeIndex: gameState.patternHistory.length,
                            bankroll: pb.theoreticalBankroll, // No change
                            actualOutcome: actualOutcome,
                            betAmount: 0, // No bet made
                            betTarget: impliedBetTarget
                        });
                        updatePatternNextBetDisplay(); // Update display after state change
                        updatePatternAnalysisChart();
                        return;
                    }

                    // Get the number of units that *would have been* bet for the current progression step
                    // This is based on the system's *current state* before applying the outcome
                    switch (pb.currentSystem) {
                        case 'flatBetting': betUnits = pb.flatBetAmount; break;
                        case 'martingale': betUnits = pb.martingaleBet; break;
                        case 'dalembert': betUnits = pb.dalembertBet; break;
                        case 'fibonacci': betUnits = pb.fibonacciSequence[pb.fibonacciIndex]; break;
                        case 'masaniello':
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            betUnits = currentMasanielloCell ? currentMasanielloCell.value : 0; // Use value from masaniello grid
                            break;
                        default:
                            betUnits = 0; // Should not happen if a system is selected
                    }
                    
                    const betAmountDollars = betUnits * pb.bettingUnitValue;

                    // Pre-check for insufficient theoretical bankroll for loss
                    if (betAmountDollars > pb.theoreticalBankroll && bettingOutcomeType === 'loss') {
                        displayMessage(`Theoretical bankroll ($${pb.theoreticalBankroll.toLocaleString()}) insufficient for next ${betUnits} unit bet ($${betAmountDollars.toFixed(2)}). Resetting betting system.`, 'error');
                        resetPatternBettingSystem();
                        return;
                    }

                    let winLossAmount = 0;
                    if (bettingOutcomeType === 'win') {
                        // Apply commission for Banker wins or special Tie payout
                        if (impliedBetTarget === 'banker') {
                            winLossAmount = betAmountDollars * 0.95; // 5% commission on Banker wins
                        } else if (impliedBetTarget === 'tie') {
                            winLossAmount = betAmountDollars * 8; // Tie typically pays 8:1
                        }
                        else { // Player win, or any other non-tie, non-banker bet with 1:1
                            winLossAmount = betAmountDollars;
                        }
                        pb.theoreticalBankroll += winLossAmount;
                        displayMessage(`Theoretical WIN of $${winLossAmount.toFixed(2)}. Theoretical Bankroll: $${pb.theoreticalBankroll.toLocaleString()}.`, 'success');
                        
                        // Apply specific progression rules for a win (in units)
                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                            bettingSystems[pb.currentSystem].handleOutcome('win', impliedBetTarget);
                        }

                    } else if (bettingOutcomeType === 'loss') {
                        winLossAmount = -betAmountDollars;
                        pb.theoreticalBankroll += winLossAmount; // Subtract loss
                        displayMessage(`Theoretical LOSS of $${betAmountDollars.toFixed(2)}. Theoretical Bankroll: $${pb.theoreticalBankroll.toLocaleString()}.`, 'error');

                        // Apply specific progression rules for a loss (in units)
                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                            bettingSystems[pb.currentSystem].handleOutcome('loss', impliedBetTarget);
                        }
                    } else { // 'push' (actual outcome was tie, or strategy recommended sit-out)
                        displayMessage('Theoretical push. Bankroll unchanged.', 'info');
                        winLossAmount = 0; // No change for push
                        // Still call handleOutcome for progression systems that might have specific push logic (e.g., D'Alembert doesn't change on push)
                        if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].handleOutcome) {
                             bettingSystems[pb.currentSystem].handleOutcome('push', impliedBetTarget);
                        }
                    }

                    // Update bankroll timeline for charting
                    gameState.bankrollTimeline.push({
                        outcomeIndex: gameState.patternHistory.length,
                        bankroll: pb.theoreticalBankroll,
                        actualOutcome: actualOutcome, // Last recorded outcome
                        betAmount: betAmountDollars,
                        betTarget: impliedBetTarget // What was recommended to bet on
                    });
                    
                    updatePatternNextBetDisplay(); // Update display after state change
                    updatePatternAnalysisChart();
                }

                function updatePatternNextBetDisplay() {
                    let nextBetUnits = 0;
                    let currentBaseInfo = '';
                    const pb = gameState.patternBetting;

                    if (!pb.currentSystem) {
                        elements.patternNextBetAmount.textContent = '0 units';
                        elements.patternCurrentBaseBet.textContent = 'N/A';
                        return;
                    }

                    // Get the next recommended bet units from the current betting system
                    if (bettingSystems[pb.currentSystem] && bettingSystems[pb.currentSystem].getNextBet) {
                        nextBetUnits = bettingSystems[pb.currentSystem].getNextBet();
                    } else if (pb.currentSystem === 'masaniello') {
                        const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                        nextBetUnits = currentMasanielloCell ? currentMasanielloCell.value : 0;
                    }

                    switch (pb.currentSystem) {
                        case 'flatBetting':
                            currentBaseInfo = `Base: ${pb.flatBetAmount} units`;
                            break;
                        case 'martingale':
                            currentBaseInfo = `Current Bet: ${pb.martingaleBet} units`;
                            break;
                        case 'dalembert':
                            currentBaseInfo = `Current Bet: ${pb.dalembertBet} units`;
                            break;
                        case 'fibonacci':
                            currentBaseInfo = `Current Index: ${pb.fibonacciIndex}`;
                            break;
                        case 'masaniello':
                            currentBaseInfo = `Current Position: [Col ${gameState.masanielloState.currentCol}, Row ${gameState.masanielloState.currentRow}]`;
                            break;
                        default:
                            currentBaseInfo = 'N/A';
                    }
                    elements.patternNextBetAmount.textContent = `${nextBetUnits.toLocaleString()} units ($${(nextBetUnits * pb.bettingUnitValue).toLocaleString()})`;
                    elements.patternCurrentBaseBet.textContent = currentBaseInfo;
                    elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`;
                }

                // Update betting system details section content
                function updatePatternBettingSystemDetails() {
                    let detailsHtml = '';
                    const system = gameState.patternBetting.currentSystem;
                    if (system && bettingSystems[system]) {
                        detailsHtml = `<p>${bettingSystems[system].description}</p>`;
                    } else {
                        detailsHtml = `<p class="text-center text-gray-400">Choose a betting system to manage your wagers.</p>`;
                    }
                    elements.patternBettingSystemDetails.innerHTML = detailsHtml;
                }


                // Charting for Pattern Recognition Tab
                function initPatternAnalysisChart() {
                    if (gameState.patternAnalysisChartInstance) {
                        gameState.patternAnalysisChartInstance.destroy(); // Destroy previous instance
                    }
                    const ctx = elements.patternAnalysisChartCanvas.getContext('2d');
                    gameState.patternAnalysisChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [], // Hand numbers
                            datasets: [{
                                label: 'Theoretical Bankroll ($)',
                                data: [],
                                borderColor: 'var(--success)',
                                backgroundColor: 'rgba(0, 230, 118, 0.1)',
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 5,
                                pointBackgroundColor: (context) => {
                                    const dataPoint = context.raw;
                                    const actualOutcome = dataPoint.actualOutcome;
                                    const betTarget = dataPoint.betTarget;
                                    
                                    // Determine point color based on win/loss/tie
                                    if (betTarget && actualOutcome) {
                                        if (betTarget === 'sit-out') return 'var(--medium-gray)'; // Sit-out (implied bet)
                                        if (actualOutcome === betTarget) return 'var(--success)'; // Win
                                        if (actualOutcome === 'tie') return 'var(--warning)'; // Actual outcome was tie (push for Player/Banker bets)
                                        if (actualOutcome !== betTarget) return 'var(--danger)'; // Loss
                                    }
                                    return 'var(--info)'; // Default or if no bet made / no clear outcome
                                },
                                pointBorderColor: 'var(--light)',
                                pointHoverRadius: 7,
                                pointHoverBackgroundColor: 'var(--light)'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--light)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            const dataPoint = context.raw;
                                            return [
                                                `Bankroll: $${dataPoint.bankroll.toLocaleString()}`,
                                                `Actual Outcome: ${dataPoint.actualOutcome.toUpperCase() || 'N/A'}`,
                                                `Recommended Bet: ${dataPoint.betTarget ? dataPoint.betTarget.toUpperCase() : 'N/A'}`
                                            ];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Hands Played',
                                        color: 'var(--light)'
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--light)' }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Bankroll ($)',
                                        color: 'var(--light)'
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--light)' }
                                }
                            },
                            animation: {
                                duration: 1000,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updatePatternAnalysisChart() {
                    if (!gameState.patternAnalysisChartInstance) {
                        initPatternAnalysisChart();
                    }
                    const labels = gameState.bankrollTimeline.map((data, index) => `Hand ${index + 1}`);
                    const dataPoints = gameState.bankrollTimeline.map(data => ({
                        y: data.bankroll,
                        actualOutcome: data.actualOutcome,
                        betTarget: data.betTarget
                    }));

                    gameState.patternAnalysisChartInstance.data.labels = labels;
                    gameState.patternAnalysisChartInstance.data.datasets[0].data = dataPoints;
                    gameState.patternAnalysisChartInstance.update();
                }

                function updatePatternCharts() {
                     // Always hide pattern charts if betting progression is disabled or no system is selected
                    if (!gameState.patternBetting.isEnabled || !gameState.patternBetting.currentSystem) {
                        elements.patternChartContainer.classList.add('hidden');
                    } else {
                        elements.patternChartContainer.classList.remove('hidden');
                        updatePatternAnalysisChart();
                    }
                }

                // Initial pattern setup
                updatePatternDetails(); // Call this to set initial text and potentially Masaniello grid
                updatePatternBettingSystemDetails(); // Call this to set initial betting system details

                // Initial setup when app loads
                startTimer();
            }

            // Initial check for authentication
            checkExistingAuth();
        });
    </script>
</body>
</html>
