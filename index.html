<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat AI - Strategic Advisor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <style>
        :root {
            --primary: #5E35B1; /* Deep Purple */
            --secondary: #4527A0; /* Even Deeper Purple */
            --accent: #E91E63; /* Ruby Pink */
            --dark: #0A0A0E; /* Almost Black */
            --light: #E0E0E0; /* Light Gray */
            --success: #4CAF50; /* Vibrant Green */
            --danger: #F44336; /* Bright Red */
            --warning: #FFC107; /* Amber Yellow */
            --info: #2196F3; /* Bright Blue */
            --bg-gradient-start: #000000; /* Absolute Black */
            --bg-gradient-end: #1A1A2E; /* Dark Blue-Grey */

            /* New colors for enhanced UI */
            --card-bg: rgba(255, 255, 255, 0.08); /* More subtle card bg */
            --panel-bg: rgba(18, 18, 26, 0.98); /* Darker panel */
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.8); /* Darker shadows */
            --text-light-subtle: #A0A0A0;
            --text-medium: #C0C0C0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            transition: background-color 0.5s ease;
        }

        /* Utility classes for animations */
        .animate-pop-in {
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .animate-fade-slide-up {
            animation: fadeSlideUp 0.6s ease-out forwards;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes fadeSlideUp {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Auth Overlay Styles */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(18px); /* Even stronger blur */
            opacity: 1;
            transition: opacity 0.8s cubic-bezier(0.65, 0.05, 0.36, 1);
        }

        .auth-container {
            background: linear-gradient(145deg, #101015, #202028); /* Darker shades */
            padding: 3.5rem;
            border-radius: 35px; /* More rounded */
            width: 90%;
            max-width: 650px; /* Wider */
            box-shadow: 0 30px 70px rgba(0, 0, 0, 0.9); /* Super pronounced shadow */
            border: 3px solid rgba(255, 255, 255, 0.3); /* Thicker border */
            text-align: center;
            animation: fadeInUp 1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .auth-title {
            font-size: 3.8rem; /* Even larger */
            margin-bottom: 3rem;
            color: var(--accent);
            font-weight: 900;
            letter-spacing: 3px;
            text-shadow: 0 0 30px rgba(233, 30, 99, 0.8); /* Stronger glow */
        }

        .auth-input {
            width: 100%;
            padding: 1.6rem; /* Larger padding */
            margin-bottom: 2.5rem;
            border: none;
            border-radius: 20px; /* More rounded */
            background: rgba(255, 255, 255, 0.15); /* Slightly more solid */
            color: white;
            font-size: 1.4rem; /* Larger font */
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            outline: none;
            box-shadow: inset 0 4px 10px rgba(0,0,0,0.5);
        }

        .auth-input:focus {
            background: rgba(255, 255, 255, 0.22);
            box-shadow: 0 0 0 6px var(--primary), inset 0 4px 10px rgba(0,0,0,0.5); /* Primary glow on focus */
        }

        .auth-btn {
            background: linear-gradient(45deg, var(--primary), var(--accent)); /* Gradient button */
            color: white;
            border: none;
            padding: 1.6rem 4rem; /* Larger padding */
            border-radius: 20px;
            font-size: 1.4rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            width: 100%;
            margin-bottom: 1.8rem;
            box-shadow: 0 12px 35px rgba(94, 53, 177, 0.7); /* Stronger shadow */
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .auth-btn:hover {
            background: linear-gradient(45deg, var(--accent), var(--primary)); /* Reverse gradient on hover */
            transform: translateY(-10px); /* More pronounced lift */
            box-shadow: 0 18px 45px rgba(233, 30, 99, 0.9); /* Even stronger shadow */
        }

        .auth-error, .auth-success {
            margin-top: 2rem;
            font-size: 1.3rem;
            font-weight: 700;
            display: none;
            animation: fadeIn 0.8s ease-out;
            padding: 1.2rem;
            border-radius: 15px;
            border: 3px solid; /* Thicker border */
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        }

        .auth-error {
            color: var(--danger);
            background-color: rgba(244, 67, 54, 0.25);
            border-color: var(--danger);
        }

        .auth-success {
            color: var(--success);
            background-color: rgba(76, 175, 80, 0.25);
            border-color: var(--success);
        }

        .key-info {
            margin-top: 3rem;
            font-size: 1.15rem;
            opacity: 0.95;
            line-height: 2;
            color: var(--text-light-subtle);
        }

        .time-remaining {
            margin-top: 2rem;
            color: var(--warning);
            font-weight: 900;
            display: none;
            font-size: 1.3rem;
            animation: pulse 1.8s infinite cubic-bezier(0.4, 0, 0.6, 1);
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.6);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.98; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Main App Container */
        .container {
            max-width: 1700px; /* Even wider */
            margin: 3rem auto;
            padding: 3.5rem; /* More padding */
            display: none;
            background: var(--panel-bg);
            border-radius: 35px; /* More rounded */
            box-shadow: 0 25px 60px var(--shadow-color);
            border: 3px solid var(--border-color);
            position: relative; /* For absolute positioning of elements inside */
            z-index: 1;
            overflow: hidden; /* Ensure nothing spills out of rounded corners */
        }

        /* Background blur for main content (subtle) */
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            filter: blur(5px); /* Less aggressive blur */
            z-index: -1;
            margin: -20px; /* Extend blur beyond container edges */
            border-radius: 40px; /* Match container border-radius */
            opacity: 0.8;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4rem;
            padding-bottom: 3rem;
            border-bottom: 2px solid rgba(255,255,255,0.3); /* Thicker border */
            position: relative;
            z-index: 2;
        }

        .logo {
            font-size: 4.5rem; /* Even larger */
            font-weight: 900;
            color: var(--accent);
            display: flex;
            align-items: center;
            letter-spacing: -4px;
            text-shadow: 0 0 20px rgba(233, 30, 99, 0.6);
            transition: all 0.3s ease-in-out;
        }
        .logo:hover {
            transform: scale(1.02) rotate(-1deg);
            text-shadow: 0 0 25px var(--accent);
        }

        .logo span {
            color: var(--primary);
            margin-left: 12px;
            text-shadow: 0 0 20px rgba(94, 53, 177, 0.6);
        }

        /* Only time info remains in header */
        .time-info {
            background: rgba(255,255,255,0.2); /* More solid */
            padding: 1.2rem 2.5rem; /* More padding */
            border-radius: 50px;
            display: flex;
            align-items: center;
            box-shadow: 0 6px 25px rgba(0,0,0,0.5); /* Stronger shadow */
            font-size: 1.25rem; /* Larger font */
            font-weight: 700;
            animation: fadeIn 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            transition: all 0.3s ease-in-out;
        }
        .time-info:hover {
            transform: translateY(-5px) scale(1.01);
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }

        .time-label {
            opacity: 0.9;
            margin-right: 1.2rem;
            color: var(--text-medium);
        }

        .time-value { color: var(--info); }

        /* Tabs Navigation */
        .tabs-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 3.5rem;
            gap: 1.8rem; /* More space between tabs */
            flex-wrap: wrap;
            position: relative;
            z-index: 2;
        }

        .tab-btn {
            background: rgba(255,255,255,0.25); /* More solid */
            color: var(--light);
            padding: 1.4rem 2.8rem; /* Larger padding */
            border-radius: 20px; /* More rounded */
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 4px solid transparent; /* Thicker border */
            font-size: 1.3rem; /* Larger font */
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: all 0.5s ease;
        }

        .tab-btn:hover::before {
            left: 100%;
        }

        .tab-btn:hover {
            background: rgba(255,255,255,0.35); /* More solid on hover */
            transform: translateY(-7px); /* More pronounced lift */
            box-shadow: 0 12px 30px rgba(0,0,0,0.6);
        }

        .tab-btn.active {
            background: linear-gradient(90deg, var(--primary), var(--accent)); /* Gradient active tab */
            border-color: var(--light);
            box-shadow: 0 10px 35px rgba(94, 53, 177, 0.9); /* Stronger glow */
            transform: translateY(-5px);
            text-shadow: 0 0 12px rgba(255,255,255,0.7);
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            z-index: 2;
        }

        .tab-content.active {
            display: block;
        }

        /* General Panel Styles */
        .panel {
            background: var(--panel-bg);
            border-radius: 30px;
            padding: 3.5rem;
            box-shadow: 0 20px 60px var(--shadow-color);
            backdrop-filter: blur(15px); /* Stronger blur */
            border: 3px solid var(--border-color);
            margin-bottom: 3.5rem;
            position: relative;
            overflow: hidden;
            transition: all 0.5s ease-in-out;
        }
        .panel:hover {
            transform: translateY(-3px) scale(1.005);
            box-shadow: 0 25px 70px var(--shadow-color);
        }

        .panel-title {
            font-size: 3.2rem;
            font-weight: 900;
            color: var(--accent);
            margin-bottom: 3rem;
            text-align: center;
            letter-spacing: 1.8px;
            text-shadow: 0 0 15px rgba(233, 30, 99, 0.7);
        }

        /* Card Counting Specific Styles (main-content grid adapted) */
        .card-counting-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 4rem; /* More gap */
        }

        .chart-container {
            position: relative;
            overflow: hidden;
            min-height: 550px; /* Taller */
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2.5rem;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .chart-title {
            font-size: 2.5rem; /* Larger */
            font-weight: 800;
            color: var(--light);
            letter-spacing: 1.2px;
        }

        .chart-controls {
            display: flex;
            gap: 1.2rem;
        }

        .control-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            padding: 1rem 1.8rem;
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 1.2rem;
            font-weight: 700;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        .control-btn:hover {
            background: var(--secondary);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(94, 53, 177, 0.7);
        }

        .chart-area {
            height: 450px;
            position: relative;
            width: 100%;
        }

        .roadmap {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(55px, 1fr)); /* Larger cells */
            gap: 15px; /* More gap */
            margin-top: 3rem;
            padding: 25px;
            background: rgba(0,0,0,0.25); /* Darker background */
            border-radius: 25px;
            overflow-x: auto;
            max-height: 280px;
            overflow-y: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.4);
            scrollbar-width: thin;
            scrollbar-color: var(--secondary) rgba(255,255,255,0.15);
        }

        .roadmap::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .roadmap::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
        }

        .roadmap::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 12px;
        }

        .cell {
            width: 55px; /* Larger */
            height: 55px; /* Larger */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.2rem;
            background-color: rgba(255,255,255,0.3);
            color: white;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .cell.predicted-player {
            background-color: var(--info);
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.9);
            border: 4px solid rgba(255,255,255,0.6);
        }

        .cell.predicted-banker {
            background-color: var(--danger);
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.9);
            border: 4px solid rgba(255,255,255,0.6);
        }

        .cell.predicted-tie {
            background-color: var(--warning);
            color: var(--dark);
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.9);
            border: 4px solid rgba(255,255,255,0.6);
        }

        .cell:hover {
            transform: scale(1.35);
            z-index: 10;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
        }

        /* Analysis Panel */
        .analysis-panel {
            display: flex;
            flex-direction: column;
        }

        .bet-recommendation {
            background: rgba(0,0,0,0.35);
            padding: 3rem;
            border-radius: 25px;
            margin-bottom: 3rem;
            text-align: center;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.3);
            border: 3px solid rgba(255,255,255,0.2);
        }

        .recommendation-text {
            font-size: 2.8rem;
            font-weight: 900;
            margin-bottom: 1.5rem;
            animation: fadeIn 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .no-bet {
            color: var(--danger);
            opacity: 0.9;
        }

        .bet-suggestion {
            color: var(--success);
            animation: pulse-glow 2.8s infinite;
        }

        @keyframes pulse-glow {
            0% { opacity: 0.9; text-shadow: 0 0 12px rgba(76, 175, 80, 0.6); }
            50% { opacity: 1; text-shadow: 0 0 35px rgba(76, 175, 80, 1); }
            100% { opacity: 0.9; text-shadow: 0 0 12px rgba(76, 175, 80, 0.6); }
        }

        .bet-amount {
            font-size: 1.8rem;
            color: var(--warning);
            font-weight: 800;
            opacity: 0.98;
        }

        .count-info {
            background: rgba(0,0,0,0.35);
            padding: 3rem;
            border-radius: 25px;
            margin-bottom: 3rem;
            border: 3px solid rgba(255,255,255,0.2);
        }

        .count-title {
            font-size: 1.8rem;
            font-weight: 900;
            margin-bottom: 1.5rem;
            color: var(--primary);
        }

        .count-result-value {
            font-size: 4rem;
            font-weight: 900;
            color: var(--light);
            margin-bottom: 1.2rem;
            animation: bounceIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
        }

        @keyframes bounceIn {
            0% { transform: scale(0.2); opacity: 0; }
            50% { transform: scale(1.15); opacity: 1; }
            70% { transform: scale(0.98); }
            100% { transform: scale(1); }
        }

        .count-desc {
            font-size: 1.2rem;
            opacity: 0.98;
            line-height: 1.8;
            color: var(--text-medium);
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2.2rem;
            margin-bottom: 3rem;
        }

        .stat-box {
            background: rgba(0,0,0,0.35);
            padding: 2.2rem;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.12);
        }

        .stat-value {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 1rem;
            animation: fadeIn 1s ease-out;
        }

        .stat-label {
            font-size: 1.1rem;
            opacity: 0.85;
            color: var(--text-light-subtle);
        }

        .player-stat .stat-value { color: var(--info); }
        .banker-stat .stat-value { color: var(--danger); }
        .tie-stat .stat-value { color: var(--warning); }

        .input-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }

        .card-btn {
            padding: 1.5rem 0.8rem;
            border-radius: 20px;
            border: none;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.3);
            color: white;
            font-size: 1.4rem;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            text-shadow: 0 0 8px rgba(0,0,0,0.4);
        }

        .card-btn:hover {
            background: var(--primary);
            transform: translateY(-10px);
            box-shadow: 0 12px 30px rgba(94, 53, 177, 0.8);
        }

        .clear-btn-container {
            text-align: center;
            margin-top: 2.5rem;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.25);
            color: white;
            padding: 1.4rem 2.8rem;
            border-radius: 20px;
            border: none;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 1.3rem;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            text-shadow: 0 0 8px rgba(0,0,0,0.4);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.35);
            transform: translateY(-6px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

        .history-container {
            margin-top: auto;
            padding-top: 3rem;
            border-top: 2px solid rgba(255,255,255,0.25);
        }

        .history-title {
            font-size: 1.8rem;
            font-weight: 900;
            margin-bottom: 1.5rem;
            color: var(--primary);
        }

        .history-list {
            max-height: 250px;
            overflow-y: auto;
            padding-right: 1.2rem;
            scrollbar-width: thin;
            scrollbar-color: var(--secondary) rgba(255,255,255,0.15);
        }

        .history-list::-webkit-scrollbar {
            width: 12px;
        }

        .history-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
        }

        .history-list::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 12px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.2rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.18);
            font-size: 1.2rem;
            animation: fadeIn 0.8s ease-out;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-outcome.player { color: var(--info); font-weight: 800; }
        .history-outcome.banker { color: var(--danger); font-weight: 800; }
        .history-outcome.tie { color: var(--warning); font-weight: 800; }

        /* Message Box */
        .message-container {
            position: fixed;
            top: 50px;
            right: 50px;
            width: 500px;
            z-index: 1000;
            pointer-events: none;
        }

        .message-box {
            padding: 1.8rem 2rem;
            border-radius: 20px;
            margin-bottom: 1.8rem;
            text-align: center;
            font-weight: 700;
            display: none;
            opacity: 0;
            transition: opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: auto;
            box-shadow: 0 12px 35px rgba(0,0,0,0.6);
            border: 4px solid;
            transform: translateY(-50px);
        }

        .message-box.error {
            background-color: rgba(244, 67, 54, 0.3);
            color: var(--danger);
            border-color: var(--danger);
        }

        .message-box.success {
            background-color: rgba(76, 175, 80, 0.3);
            color: var(--success);
            border-color: var(--success);
        }

        .message-box.info { /* Added for informational messages */
            background-color: rgba(9, 132, 227, 0.3);
            color: var(--info);
            border-color: var(--info);
        }

        .message-box.warning { /* Added for warning messages */
            background-color: rgba(253, 203, 110, 0.3);
            color: var(--warning);
            border-color: var(--warning);
        }

        .message-box.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Additional Strategy Tab Styles */
        .strategy-content {
            padding: 3rem;
            text-align: center;
        }

        .strategy-content h3 {
            font-size: 2.8rem;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 2.5rem;
        }

        .strategy-content p {
            font-size: 1.3rem;
            line-height: 1.9;
            color: var(--text-medium);
            margin-bottom: 2.5rem;
        }

        .strategy-input-group {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            max-width: 500px;
            margin: 0 auto 3rem;
        }

        .strategy-input {
            padding: 1.2rem;
            border-radius: 18px;
            border: 2px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.45);
            color: var(--light);
            font-size: 1.2rem;
            outline: none;
            transition: border-color 0.5s ease, box-shadow 0.5s ease;
            box-shadow: inset 0 3px 8px rgba(0,0,0,0.4);
        }

        .strategy-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 4px var(--accent), inset 0 3px 8px rgba(0,0,0,0.4);
        }

        .strategy-btn {
            background: linear-gradient(45deg, var(--accent), var(--primary));
            color: white;
            padding: 1.4rem 2.2rem;
            border-radius: 18px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.5);
            text-transform: uppercase;
        }

        .strategy-btn:hover {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            transform: translateY(-6px);
            box-shadow: 0 10px 25px rgba(233, 30, 99, 0.7);
        }

        .strategy-result {
            margin-top: 3rem;
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--success);
            animation: fadeIn 1.2s ease-out;
            text-shadow: 0 0 12px rgba(76, 175, 80, 0.6);
        }

        /* Specific for Betting Systems and Pattern Recognition */
        .dropdown-container {
            margin-bottom: 2.5rem;
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 350px;
        }

        .dropdown-button {
            background: rgba(255,255,255,0.25);
            color: var(--light);
            padding: 1.2rem 2rem;
            border-radius: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            box-shadow: 0 5px 18px rgba(0,0,0,0.4);
        }

        .dropdown-button:hover {
            background: rgba(255,255,255,0.35);
            transform: translateY(-4px);
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 15px);
            left: 0;
            background: var(--dark);
            border-radius: 20px;
            box-shadow: 0 12px 30px rgba(0,0,0,0.6);
            z-index: 10;
            min-width: 100%;
            opacity: 0;
            transform: translateY(25px);
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            padding: 1rem 0;
            border: 2px solid var(--border-color);
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            padding: 1.2rem 2rem;
            color: var(--text-medium);
            cursor: pointer;
            transition: background-color 0.25s ease, color 0.25s ease;
            text-align: left;
            font-size: 1.15rem;
            font-weight: 500;
        }

        .dropdown-item:hover {
            background-color: var(--secondary);
            color: white;
        }

        /* Betting Simulation Controls within Pattern Recognition */
        .betting-simulation-controls {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px dashed rgba(255,255,255,0.1);
            text-align: center;
        }
        .betting-simulation-controls h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 1.5rem;
        }

        /* Styles for the highlighted next bet amount */
        .highlight-bet-label {
            font-size: 1.8rem; /* Larger font for the label */
            font-weight: 800; /* Bolder label */
            color: var(--text-medium); /* Keep consistent color */
        }

        .highlight-bet-amount {
            font-size: 2.5rem; /* Significantly larger */
            font-weight: 900; /* Extra bold */
            color: var(--warning); /* Vibrant color */
            text-shadow: 0 0 15px rgba(255, 193, 7, 0.8), 0 0 25px rgba(255, 193, 7, 0.5); /* Stronger glow */
            animation: pulse-light 1.5s infinite alternate ease-in-out; /* Subtle pulse animation */
            padding-left: 0.5rem; /* Small padding to separate from label */
        }

        @keyframes pulse-light {
            0% { text-shadow: 0 0 10px rgba(255, 193, 7, 0.8), 0 0 15px rgba(255, 193, 7, 0.5); transform: scale(1); }
            100% { text-shadow: 0 0 20px rgba(255, 193, 7, 1), 0 0 35px rgba(255, 193, 7, 0.7); transform: scale(1.03); }
        }


        /* Masaniello Chart */
        .masaniello-chart-container {
            margin-top: 2.5rem;
            padding: 2rem;
            background: rgba(0,0,0,0.4);
            border-radius: 20px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .masaniello-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 columns as per screenshot */
            gap: 5px;
            width: fit-content; /* Ensure grid does not stretch */
            margin: 0 auto; /* Center the grid */
        }

        .masaniello-cell {
            width: 50px; /* Adjusted size for grid, slightly larger to match screenshot roughly */
            height: 50px;
            background-color: rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column; /* To stack value and bet type */
            align-items: center;
            justify-content: center;
            font-size: 0.85rem; /* Smaller font for two lines */
            font-weight: 600;
            border-radius: 8px;
            color: var(--text-medium);
            transition: background-color 0.3s ease, transform 0.3s ease;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .masaniello-cell .value {
            font-weight: 800;
            font-size: 1rem;
            color: var(--light);
        }
        .masaniello-cell .bet-type {
            font-size: 0.75rem;
            opacity: 0.8;
        }


        .masaniello-cell.active-position {
            border: 3px solid var(--warning); /* Thicker highlight */
            box-shadow: 0 0 20px var(--warning); /* Stronger glow */
            transform: scale(1.08); /* More pronounced scale */
            z-index: 2;
        }

        .masaniello-cell.player-bg { background-color: var(--info); color: white; }
        .masaniello-cell.banker-bg { background-color: var(--danger); color: white; }
        .masaniello-cell.sit-out-bg { background-color: var(--text-light-subtle); color: var(--dark); }

        .masaniello-legend {
            display: flex;
            justify-content: center;
            gap: 25px; /* More space */
            margin-top: 1.8rem;
            font-size: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color-box {
            width: 22px; /* Larger */
            height: 22px;
            border-radius: 5px;
            margin-right: 10px;
        }

        /* Toggle Switch for Betting Progression */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-medium);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Baccarat Mini-Game Specific Styles */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 2.5rem;
            align-items: center;
            justify-content: center;
        }

        .game-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.8rem;
            justify-content: center;
            margin-bottom: 2.5rem;
        }

        .bet-option-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 1.2rem 2.5rem;
            border-radius: 18px;
            border: none;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 1.2rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-transform: uppercase;
        }

        .bet-option-btn:hover {
            transform: translateY(-6px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }

        .bet-option-btn.player-bet:hover { background-color: var(--info); }
        .bet-option-btn.banker-bet:hover { background-color: var(--danger); }
        .bet-option-btn.tie-bet:hover { background-color: var(--warning); color: var(--dark); }

        .bet-option-btn.active-bet {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            border: 2px solid var(--light);
            box-shadow: 0 6px 20px rgba(94, 53, 177, 0.6);
            transform: translateY(-3px);
        }


        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .bet-input {
            width: 150px;
            padding: 1rem;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5);
            color: var(--light);
            font-size: 1.1rem;
            outline: none;
            text-align: center;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4);
        }

        .deal-btn {
            background: linear-gradient(90deg, var(--success), #388E3C);
            color: white;
            padding: 1.4rem 3rem;
            border-radius: 20px;
            border: none;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 1.4rem;
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.7);
            margin-top: 2.5rem;
            width: 100%;
            max-width: 350px;
            text-transform: uppercase;
        }

        .deal-btn:hover {
            background: linear-gradient(90deg, #388E3C, var(--success));
            transform: translateY(-8px);
            box-shadow: 0 15px 35px rgba(76, 175, 80, 0.9);
        }

        .cards-display {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 2rem;
            flex-wrap: wrap;
            margin-bottom: 2.5rem;
        }

        .player-hand, .banker-hand {
            background: rgba(0,0,0,0.4);
            padding: 2rem;
            border-radius: 25px;
            width: 48%;
            min-width: 300px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .player-hand h3, .banker-hand h3 {
            font-size: 1.8rem;
            font-weight: 900;
            margin-bottom: 1.2rem;
            color: var(--primary);
        }

        .player-hand h3 { color: var(--info); }
        .banker-hand h3 { color: var(--danger); }

        .card-list {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            min-height: 60px;
        }

        .card-item {
            background: var(--card-bg);
            padding: 0.8rem 1.2rem;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: 800;
            color: var(--light);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.25);
            animation: fadeIn 0.6s ease-out forwards;
        }

        .hand-score {
            font-size: 3rem;
            font-weight: 900;
            color: var(--accent);
            margin-top: 1.5rem;
            animation: bounceIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 15px rgba(233, 30, 99, 0.7);
        }

        .game-outcome-display {
            margin-top: 2.5rem;
            display: none;
            text-align: center;
        }

        .game-result {
            font-size: 3.2rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255,255,255,0.7);
            animation: fadeIn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .result-player { color: var(--info); }
        .result-banker { color: var(--danger); }
        .result-tie { color: var(--warning); }
        
        .game-outcome-display p {
            font-size: 1.3rem;
            margin-top: 1rem;
            color: var(--text-medium);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .container { padding: 2.5rem; }
            .logo { font-size: 3.5rem; }
            .tabs-nav { gap: 1.2rem; }
            .tab-btn { padding: 1.1rem 2.2rem; font-size: 1.1rem; }
            .card-counting-layout { gap: 3rem; }
            .chart-title { font-size: 2rem; }
            .roadmap { grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; padding: 20px; max-height: 220px; }
            .cell { width: 50px; height: 50px; font-size: 1.1rem; }
            .bet-recommendation .recommendation-text { font-size: 2.2rem; }
            .count-result-value { font-size: 3.5rem; }
            .player-hand, .banker-hand { width: 100%; } /* Stack hands on smaller wide screens */
            .panel-title { font-size: 2.5rem; }
        }

        @media (max-width: 768px) {
            body { padding: 0.8rem; }
            .auth-container { padding: 1.8rem; border-radius: 25px; }
            .auth-title { font-size: 2.8rem; margin-bottom: 1.8rem; letter-spacing: 1.5px; }
            .auth-input { padding: 1.1rem; font-size: 1.1rem; margin-bottom: 1.5rem; }
            .auth-btn { padding: 1.1rem 2.2rem; font-size: 1.1rem; }

            .container {
                margin: 0.8rem auto;
                padding: 1.5rem;
                border-radius: 25px;
            }
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.6rem;
                margin-bottom: 1.5rem;
                padding-bottom: 1rem;
            }
            .logo { font-size: 3.2rem; letter-spacing: -2px; }
            .time-info {
                width: 100%;
                justify-content: center;
                margin-right: 0;
                padding: 0.7rem 1.2rem;
                font-size: 0.9rem;
            }
            .tabs-nav {
                flex-direction: column;
                gap: 0.5rem;
                margin-bottom: 1.5rem;
            }
            .tab-btn {
                width: 100%;
                padding: 0.8rem 1.2rem;
                font-size: 0.95rem;
                border-width: 2px;
            }
            .panel { padding: 1.8rem; border-radius: 20px; margin-bottom: 2rem; }
            .panel-title { font-size: 2.2rem; margin-bottom: 1.2rem; letter-spacing: 1px; }

            .card-counting-layout {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            .chart-title { font-size: 1.4rem; }
            .chart-controls { flex-wrap: wrap; justify-content: center; gap: 0.5rem; width: 100%; }
            .control-btn { flex: 1 1 auto; padding: 0.5rem 0.8rem; font-size: 0.85rem; border-radius: 12px; }
            .chart-area { height: 250px; }
            .roadmap {
                grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
                gap: 6px;
                padding: 10px;
                max-height: 150px;
            }
            .cell { width: 30px; height: 30px; font-size: 0.8rem; border-width: 2px; }
            .bet-recommendation { padding: 1.5rem; min-height: 100px; border-width: 2px; }
            .recommendation-text { font-size: 1.4rem; margin-bottom: 0.6rem; }
            .bet-amount { font-size: 1rem; }
            .count-info { padding: 1.5rem; border-width: 2px; }
            .count-title { font-size: 1.1rem; }
            .count-result-value { font-size: 2.5rem; }
            .stats-container { gap: 0.8rem; margin-bottom: 1.5rem; }
            .stat-box { padding: 1rem; border-radius: 15px; }
            .stat-value { font-size: 1.6rem; }
            .input-controls { grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); gap: 0.6rem; }
            .card-btn { padding: 0.8rem 0.4rem; font-size: 1.05rem; border-radius: 15px; } /* Slightly larger for visibility */
            .btn-secondary { padding: 0.8rem 1.5rem; font-size: 1.05rem; border-radius: 15px; }
            .history-list { max-height: 140px; padding-right: 0.5rem; }
            .history-item { padding: 0.6rem 0; font-size: 0.9rem; }

            .message-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 10px;
            }
            .message-box { padding: 0.8rem 1rem; font-size: 0.9rem; border-radius: 10px; border-width: 2px; }

            /* Strategy Tab Responsive */
            .strategy-content { padding: 1.8rem; }
            .strategy-content h3 { font-size: 1.6rem; margin-bottom: 1.5rem; }
            .strategy-content p { font-size: 1rem; margin-bottom: 1.5rem; }
            .dropdown-container { max-width: 250px; }
            .dropdown-button { padding: 0.9rem 1.2rem; font-size: 1rem; border-radius: 12px; }
            .dropdown-menu { border-radius: 12px; padding: 0.6rem 0; }
            .dropdown-item { padding: 0.8rem 1.2rem; font-size: 0.95rem; }
            .strategy-input { padding: 0.8rem; font-size: 1rem; border-radius: 12px; }
            .strategy-btn { padding: 1rem 1.5rem; font-size: 1.1rem; border-radius: 15px; }
            .strategy-result { font-size: 1.8rem; margin-top: 2rem; }

            /* Masaniello Responsive */
            .masaniello-cell { width: 35px; height: 35px; font-size: 0.8rem; }
            .masaniello-grid { gap: 3px; }
            .masaniello-legend { font-size: 0.8rem; gap: 10px; }

            /* Mini-Game Responsive */
            .game-controls { gap: 1rem; }
            .bet-option-btn { padding: 1rem 1.5rem; font-size: 1rem; border-radius: 15px; }
            .bet-input-group { flex-direction: column; gap: 0.5rem; }
            .bet-input { width: 100%; padding: 0.7rem; font-size: 1rem; }
            .deal-btn { padding: 1.1rem 2rem; font-size: 1.1rem; border-radius: 15px; }
            .player-hand, .banker-hand { padding: 1.2rem; border-radius: 18px; min-width: unset; }
            .player-hand h3, .banker-hand h3 { font-size: 1.4rem; margin-bottom: 0.8rem; }
            .card-item { padding: 0.5rem 0.7rem; font-size: 1.05rem; border-radius: 6px; } /* Slightly larger for visibility */
            .hand-score { font-size: 2.2rem; margin-top: 0.8rem; }
            .game-result { font-size: 2.2rem; margin-top: 1.5rem; }
        }
    </style>
</head>
<body>
    <!-- Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="auth-container">
            <h1 class="auth-title">BAC<span>AI</span> Access</h1>
            <input type="text" class="auth-input" id="authKeyInput" placeholder="Enter your access key">
            <button class="auth-btn" id="authSubmitBtn">Authenticate</button>
            <div class="auth-error" id="authError"></div>
            <div class="auth-success" id="authSuccess">Authentication successful! Loading...</div>
            <div class="time-remaining" id="timeRemaining"></div>
            <div class="key-info">
                <p>Unlock premium features with an access key. Each key is limited to one device.</p>
                <p>Your key's remaining time will be displayed after successful authentication.</p>
            </div>
        </div>
    </div>

    <!-- Message Box for notifications -->
    <div class="message-container">
        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- Main Application Content -->
    <div class="container" id="mainContent">
        <header>
            <div class="logo">
                BAC<span>AI</span>
            </div>
            <div class="time-info" id="timeContainer">
                <span class="time-label">Time Left:</span>
                <span class="time-value" id="timeValue">00:00:00</span>
            </div>
        </header>

        <!-- Strategy Tabs -->
        <nav class="tabs-nav" id="strategyTabs">
            <button class="tab-btn active" data-tab="cardCounting">Card Counting</button>
            <button class="tab-btn" data-tab="patternRecognition">Pattern Recognition</button>
            <button class="tab-btn" data-tab="miniGame">Mini-Game</button>
        </nav>

        <!-- Card Counting Tab Content -->
        <div id="cardCounting" class="tab-content active">
            <div class="card-counting-layout">
                <div class="panel chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Baccarat Card Sequence & Trend</div>
                        <div class="chart-controls">
                            <button class="control-btn" id="bigRoadBtn">Big Road</button>
                            <button class="control-btn" id="beadPlateBtn">Bead Plate</button>
                            <button class="control-btn" id="derivativeBtn">Derivative</button>
                        </div>
                    </div>
                    <div class="chart-area" id="chartArea"></div>
                    <div class="roadmap" id="roadmap"></div>
                </div>

                <div class="panel analysis-panel">
                    <h2 class="panel-title">Card Counting Analysis</h2>

                    <div class="bet-recommendation" id="betRecommendation">
                        <div class="recommendation-text no-bet">Enter cards to see prediction</div>
                        <div class="bet-amount" id="betAmount"></div>
                    </div>

                    <div class="count-info">
                        <div class="count-title">Current Running Count:</div>
                        <div class="count-result-value" id="countResultValue">0</div>
                        <div class="count-desc" id="countDesc">This is the numerical result from the counting system.</div>
                    </div>

                    <div class="stats-container">
                        <div class="stat-box player-stat">
                            <div class="stat-value" id="playerBets">0</div>
                            <div class="stat-label">Player Bets</div>
                        </div>
                        <div class="stat-box banker-stat">
                            <div class="stat-value" id="bankerBets">0</div>
                            <div class="stat-label">Banker Bets</div>
                        </div>
                        <div class="stat-box tie-stat">
                            <div class="stat-value" id="tieBets">0</div>
                            <div class="stat-label">Tie Bets</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="totalEntries">0</div>
                            <div class="stat-label">Total Cards Entered</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="entriesNeeded">N/A</div>
                            <div class="stat-label">Cards Needed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="decksRemaining">--</div>
                            <div class="stat-label">Decks Remaining (Est.)</div>
                        </div>
                    </div>

                    <div class="input-controls">
                        <button class="card-btn" data-card-value="A">A</button>
                        <button class="card-btn" data-card-value="2">2</button>
                        <button class="card-btn" data-card-value="3">3</button>
                        <button class="card-btn" data-card-value="4">4</button>
                        <button class="card-btn" data-card-value="5">5</button>
                        <button class="card-btn" data-card-value="6">6</button>
                        <button class="card-btn" data-card-value="7">7</button>
                        <button class="card-btn" data-card-value="8">8</button>
                        <button class="card-btn" data-card-value="9">9</button>
                        <button class="card-btn" data-card-value="10">10/F</button>
                    </div>
                    <div class="clear-btn-container">
                        <button class="btn btn-secondary" id="clearBtn">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>

                    <div class="history-container">
                        <div class="history-title">Prediction History</div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pattern Recognition Tab Content -->
        <div id="patternRecognition" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">Pattern Recognition & Betting Strategy</h2>
                <p>Analyze game outcomes and apply a betting progression based on patterns.</p>

                <div class="dropdown-container w-full max-w-xs mx-auto mb-6">
                    <button id="patternDropdownBtn" class="dropdown-button">
                        <span id="selectedPatternText">Select Pattern Method</span>
                        <i class="fas fa-caret-down ml-2"></i>
                    </button>
                    <div id="patternDropdownMenu" class="dropdown-menu">
                        <div class="dropdown-item" data-strategy="patternMethod">Pattern Method</div>
                        <div class="dropdown-item" data-strategy="pbpbpbPattern">PBPBPB Pattern</div>
                        <div class="dropdown-item" data-strategy="dragonPattern">Dragon Pattern (Streaks)</div>
                        <div class="dropdown-item" data-strategy="twosPattern">Two-in-a-row Pattern</div>
                        <div class="dropdown-item" data-strategy="masaniello">Masaniello</div>
                    </div>
                </div>

                <!-- Pattern Strategy Details and Input -->
                <div id="patternStrategyDetails" class="mt-4 text-left">
                    <p class="text-center text-gray-400">Choose a pattern strategy from the dropdown above to see its description and controls.</p>
                </div>

                <div id="patternInputArea" class="hidden mt-6">
                    <h3 class="text-xl font-bold mb-4 text-primary">Record Game Outcome</h3>
                    <div class="grid grid-cols-3 gap-4 max-w-sm mx-auto">
                        <button class="strategy-btn" data-outcome="banker">Banker Won</button>
                        <button class="strategy-btn" data-outcome="player">Player Won</button>
                        <button class="strategy-btn" data-outcome="tie">Tie</button>
                    </div>
                    <button class="btn-secondary mt-4" id="clearPatternBtn">Clear History</button>
                </div>
                
                <div id="patternAnalysisResult" class="strategy-result hidden">
                    <!-- Pattern specific analysis will be injected here -->
                </div>

                <!-- New Chart Container for Pattern Outcome Distribution -->
                <div id="patternOutcomeDistributionChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title" style="font-size: 1.8rem;">Pattern Outcome Distribution</h4>
                    <canvas id="patternOutcomeDistributionChart"></canvas>
                </div>

                <!-- Toggle for Betting Progression -->
                <div class="switch-container mt-6">
                    <label class="switch">
                        <input type="checkbox" id="enableBettingProgressionToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Enable Betting Progression</span>
                </div>

                <!-- Betting Progression Selection -->
                <div class="betting-simulation-controls hidden" id="patternBettingControls">
                    <h4>Apply Betting Progression</h4>
                    <div class="flex flex-col items-center gap-4 mb-6">
                        <div class="dropdown-container w-full max-w-xs">
                            <button id="bettingProgressionDropdownBtn" class="dropdown-button">
                                <span id="selectedBettingProgressionText">Select System</span>
                                <i class="fas fa-caret-down ml-2"></i>
                            </button>
                            <div id="bettingProgressionDropdownMenu" class="dropdown-menu">
                                <div class="dropdown-item" data-system="flatBetting">Flat Betting</div>
                                <div class="dropdown-item" data-system="martingale">Martingale</div>
                                <div class="dropdown-item" data-system="dalembert">D'Alembert</div>
                                <div class="dropdown-item" data-system="fibonacci">Fibonacci</div>
                            </div>
                        </div>
                        <div class="bet-unit-input-group flex items-center gap-2 max-w-xs w-full">
                            <label for="betUnitValueInput" class="text-light text-sm font-semibold">1 Unit = $</label>
                            <input type="number" id="betUnitValueInput" class="strategy-input flex-grow" value="10" min="1" step="10">
                            <button class="strategy-btn px-4 py-2 text-sm" id="setBetUnitValueBtn">Set</button>
                        </div>
                    </div>

                    <div id="patternBettingSystemDetails" class="mt-4 text-left">
                        <p class="text-center text-gray-400">Choose a betting system to manage your wagers.</p>
                    </div>
                    <div id="patternBettingInputArea" class="hidden mt-6">
                        <p class="mt-4 text-light flex justify-center items-baseline">
                            <span class="highlight-bet-label">Next Recommended Bet:</span>
                            <span id="patternNextBetAmount" class="highlight-bet-amount">0 units</span>
                        </p>
                        <p class="text-sm text-gray-400">Current Theoretical Bankroll: <span id="patternCurrentTheoreticalBankroll">$10,000</span></p>
                        <p class="text-sm text-gray-400">Current Base Bet: <span id="patternCurrentBaseBet"></span></p>
                        <button class="btn-secondary mt-4" id="patternResetBettingBtn">Reset System</button>
                    </div>
                </div>
                <!-- Existing Chart Container for Theoretical Bankroll Evolution (visible only with betting progression enabled) -->
                <div id="patternChartContainer" class="hidden mt-6 panel">
                    <h4 class="panel-title" style="font-size: 1.8rem;">Theoretical Bankroll Evolution</h4>
                    <canvas id="patternAnalysisChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Baccarat Mini-Game Tab Content -->
        <div id="miniGame" class="tab-content">
            <div class="panel strategy-content">
                <h2 class="panel-title">Baccarat Mini-Game</h2>
                <p>Place your bet and try your luck against the dealer!</p>

                <!-- Mini-Game Balance Display and Bet Input -->
                <div class="balance-info mb-6 mx-auto w-full max-w-md">
                    <span class="balance-label">Your Balance:</span>
                    <span class="balance-value" id="miniGameBalanceDisplay">$10,000</span>
                </div>

                <div class="game-area">
                    <div class="game-controls">
                        <button class="bet-option-btn player-bet" data-bet-target="player">Bet Player</button>
                        <button class="bet-option-btn banker-bet" data-bet-target="banker">Bet Banker</button>
                        <button class="bet-option-btn tie-bet" data-bet-target="tie">Bet Tie</button>
                        <div class="bet-input-group">
                            <label for="betAmountInput" class="text-light">Amount:</label>
                            <input type="number" id="betAmountInput" class="bet-input" value="100" min="10">
                        </div>
                    </div>

                    <button class="deal-btn" id="dealHandBtn">Deal Hand</button>

                    <div class="cards-display mt-6">
                        <div class="player-hand">
                            <h3>Player Hand</h3>
                            <div class="card-list" id="playerCardList"></div>
                            <div class="hand-score" id="playerScore">0</div>
                        </div>
                        <div class="banker-hand">
                            <h3>Banker Hand</h3>
                            <div class="card-list" id="bankerCardList"></div>
                            <div class="hand-score" id="bankerScore">0</div>
                        </div>
                    </div>

                    <div class="game-outcome-display mt-4 hidden" id="gameResultDisplay">
                        <h3 class="game-result" id="gameResultText"></h3>
                        <p class="text-lg mt-2">New Balance: <span id="gameNewBalance" class="font-bold text-warning"></span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // =============================================
            // STRICT One-Device-Per-Key Authentication with Minute-Based Expiration
            // =============================================
            const authOverlay = document.getElementById('authOverlay');
            const mainContent = document.getElementById('mainContent');
            const authKeyInput = document.getElementById('authKeyInput');
            const authSubmitBtn = document.getElementById('authSubmitBtn');
            const authError = document.getElementById('authError');
            const authSuccess = document.getElementById('authSuccess');
            const timeRemaining = document.getElementById('timeRemaining');
            const timeContainer = document.getElementById('timeContainer');

            // Predefined valid keys with expiration periods (in minutes)
            const validKeys = {
                "BAC-AI-2024-K1X7": { expiresIn: 525600 }, // 1 year
                "DEMO-KEY-1": { expiresIn: 60 },    // 60 minutes (1 hour)
                "DEMO-KEY-2": { expiresIn: 1440 },  // 1440 minutes (24 hours)
                "PRO-KEY-A": { expiresIn: 20480 },  // Approx 14 days
                "ULTRA-KEY-B": { expiresIn: 24480 } // Approx 17 days
            };

            // Check if a key is expired
            function isKeyExpired(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return true;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn);

                return new Date() > expirationDate;
            }

            // Format time as HH:MM:SS
            function formatTime(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            // Calculate remaining time in seconds
            function getRemainingTime(keyInfo) {
                if (!keyInfo || !keyInfo.firstUsed) return 0;

                const expirationDate = new Date(keyInfo.firstUsed);
                expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn); // Add expiresIn to firstUsed to get expiration point
                const now = new Date();

                return Math.max(0, Math.floor((expirationDate - now) / 1000));
            }

            // Enhanced device fingerprinting for security
            async function getDeviceFingerprint() {
                const components = [
                    navigator.userAgent,
                    navigator.platform,
                    navigator.hardwareConcurrency || 'unknown',
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    navigator.languages.join(','),
                    !!navigator.pdfViewerEnabled,
                    navigator.maxTouchPoints || 'unknown'
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('BaccaratAI', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('BaccaratAI', 4, 17);
                const canvasData = canvas.toDataURL();

                let webglData = 'unsupported';
                try {
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        webglData = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + '|' +
                                   gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    }
                } catch (e) { /* console.error("WebGL fingerprinting failed:", e); */ }

                const combined = components.join('|') + '|' + canvasData + '|' + webglData;
                const msgBuffer = new TextEncoder().encode(combined);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                return 'fp-' + hashHex;
            }

            // Authentication handler with expiration check
            authSubmitBtn.addEventListener('click', async function() {
                const enteredKey = authKeyInput.value.trim();

                if (!validKeys.hasOwnProperty(enteredKey)) {
                    authError.textContent = "Invalid access key";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__shakeX');
                    setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                    return;
                }

                let keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const deviceFingerprint = await getDeviceFingerprint();

                if (!keyRegistry[enteredKey]) { // Key is being used for the first time
                    const newKeyInfo = {
                        fingerprint: deviceFingerprint,
                        firstUsed: new Date().toISOString(), // Store as ISO string
                        lastUsed: new Date().toISOString(),
                        expiresIn: validKeys[enteredKey].expiresIn
                    };
                    keyRegistry[enteredKey] = newKeyInfo;
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else if (keyRegistry[enteredKey].fingerprint === deviceFingerprint) { // Key registered to this device
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyRegistry[enteredKey])) {
                        authError.textContent = "This key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.classList.add('animate__shakeX');
                        setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                        return;
                    }
                    keyRegistry[enteredKey].lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));
                } else { // Key is registered to a different device
                    authError.textContent = "This key is already in use on another device";
                    authError.style.display = 'block';
                    authKeyInput.classList.add('animate__shakeX');
                    setTimeout(() => authKeyInput.classList.remove('animate__shakeX'), 1000);
                    return;
                }

                // Store successful authentication
                localStorage.setItem('baccaratAuthKey', enteredKey);
                localStorage.setItem('baccaratAuthFingerprint', deviceFingerprint);

                // Show success and remaining time
                const keyInfo = keyRegistry[enteredKey]; // Get the updated keyInfo
                const remainingTimeSeconds = getRemainingTime(keyInfo);

                timeRemaining.textContent = `Expires in: ${formatTime(remainingTimeSeconds)}`;
                timeRemaining.style.display = 'block';

                authError.style.display = 'none';
                authSuccess.style.display = 'block';
                this.disabled = true;

                setTimeout(() => {
                    authOverlay.style.opacity = '0';
                    setTimeout(() => {
                        authOverlay.style.display = 'none';
                        mainContent.style.display = 'block';
                        mainContent.classList.add('animate-pop-in');
                        initApp(enteredKey);
                    }, 500);
                }, 1500);
            });

            // Check for existing auth on page load
            async function checkExistingAuth() {
                const savedKey = localStorage.getItem('baccaratAuthKey');
                const savedFingerprint = localStorage.getItem('baccaratAuthFingerprint');

                if (!savedKey || !savedFingerprint) {
                    authKeyInput.focus();
                    return false;
                }

                const currentFingerprint = await getDeviceFingerprint();
                if (savedFingerprint !== currentFingerprint) {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');
                    authError.textContent = "Authentication required: Device mismatch.";
                    authError.style.display = 'block';
                    authKeyInput.focus();
                    return false;
                }

                const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                const keyInfo = keyRegistry[savedKey];

                if (keyInfo && keyInfo.fingerprint === currentFingerprint) {
                    // Check if the key has genuinely expired from its first use + expiresIn
                    if (isKeyExpired(keyInfo)) {
                        localStorage.removeItem('baccaratAuthKey');
                        localStorage.removeItem('baccaratAuthFingerprint');
                        authError.textContent = "Your access key has expired. Please renew your subscription.";
                        authError.style.display = 'block';
                        authKeyInput.value = savedKey;
                        authKeyInput.focus();
                        return false;
                    }

                    keyInfo.lastUsed = new Date().toISOString(); // Update last used time
                    localStorage.setItem('baccaratKeyRegistry', JSON.stringify(keyRegistry));

                    authOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                    mainContent.classList.add('animate-pop-in');
                    initApp(savedKey);
                    return true;
                }

                authKeyInput.focus();
                return false;
            }

            // =============================================
            // Baccarat Core Application Functionality
            // =============================================
            function initApp(activeKey) {
                const gameState = {
                    entries: [], // Stores the raw card values entered (e.g., 'A', '2', '10') for Card Counting
                    predictionHistory: [], // Stores the results of predictions for Card Counting
                    miniGameBalance: 10000, // ONLY for Mini-Game
                    chart: null, // Chart.js instance for Card Counting
                    activeKey: activeKey,
                    timer: null,
                    totalDecks: 8, // Assuming 8 decks in a Baccarat shoe
                    cardsDealt: 0, // Track total cards dealt to estimate decks remaining
                    
                    patternBetting: {
                        currentSystem: null,
                        bettingUnitValue: 10, // Default unit value in dollars for theoretical bankroll
                        martingaleBet: 1, // units
                        dalembertBet: 1, // units
                        fibonacciSequence: [1, 1],
                        fibonacciIndex: 0,
                        flatBetAmount: 1, // units
                        theoreticalBankroll: 10000, // ONLY for Pattern Recognition betting simulation
                        isEnabled: false // New state for betting progression toggle
                    },

                    // Pattern Recognition State
                    currentPatternStrategy: null,
                    patternHistory: [], // Stores 'player', 'banker', 'tie' outcomes
                    currentPatternRecommendation: null, // What the pattern strategy suggests to bet on
                    outcomeCounts: { player: 0, banker: 0, tie: 0 }, // For "Pattern Method" prediction
                    masanielloState: {
                        grid: [], // 2D array for the Masaniello chart
                        gridRows: 10, // Max row based on screenshot
                        gridCols: 10, // Max col based on screenshot
                        currentRow: 0, // Current position Y
                        currentCol: 0, // Current position X
                        unitIncrement: 10 // How much each unit represents in betting (e.g., 1 unit = $10)
                    },
                    patternAnalysisChartInstance: null, // Existing Chart.js instance for theoretical bankroll
                    bankrollTimeline: [], // Stores {outcomeIndex: number, bankroll: number, actualOutcome: string}
                    patternOutcomeDistributionChartInstance: null, // NEW Chart.js instance for pattern outcome distribution
                    
                    // Mini-Game State
                    deck: [],
                    playerHand: [],
                    bankerHand: [],
                    currentBet: { type: null, amount: 0 }
                };

                // Hardcoded Masaniello grid values and suggested bet types based on the screenshot
                // Format: { value: number, bet: 'player' | 'banker' | 'sit-out' }
                // Note: The screenshot implies some complex rules for Tie and other values, simplified here.
                const masanielloGridConfig = [
                    // Row 0 (Losses up to 9)
                    [{value: 0, bet: 'sit-out'}, {value: 1, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 4, bet: 'banker'}, {value: 3, bet: 'banker'}, {value: 2, bet: 'banker'}, {value: 1, bet: 'banker'}, {value: 0, bet: 'banker'}],
                    // Row 1
                    [{value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 1, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}],
                    // Row 2
                    [{value: 2, bet: 'player'}, {value: 1, bet: 'player'}, {value: 0, bet: 'player'}, {value: 2, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 6, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}],
                    // Row 3
                    [{value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 6, bet: 'player'}, {value: 4, bet: 'player'}],
                    // Row 4
                    [{value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 4, bet: 'player'}, {value: 7, bet: 'player'}, {value: 9, bet: 'player'}, {value: 11, bet: 'player'}, {value: 8, bet: 'player'}],
                    // Row 5
                    [{value: 5, bet: 'player'}, {value: 4, bet: 'player'}, {value: 3, bet: 'player'}, {value: 3, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}], // This row seems special on the screenshot
                    // Row 6
                    [{value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 4, bet: 'player'}, {value: 5, bet: 'player'}, {value: 5, bet: 'player'}, {value: 3, bet: 'player'}, {value: 2, bet: 'player'}, {value: 0, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}], // Adjusted based on screenshot layout
                    // Row 7
                    [{value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 7, bet: 'player'}, {value: 8, bet: 'player'}, {value: 9, bet: 'player'}, {value: 8, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}],
                    // Row 8
                    [{value: 1, bet: 'player'}, {value: 1, bet: 'player'}, {value: 2, bet: 'player'}, {value: 3, bet: 'player'}, {value: 5, bet: 'player'}, {value: 8, bet: 'player'}, {value: 11, bet: 'player'}, {value: 15, bet: 'player'}, {value: 30, bet: 'player'}, {value: 61, bet: 'player'}], // Adjusted for screenshot accuracy
                    // Row 9 (Last row, assuming 10 rows for example)
                    [{value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 0, bet: 'sit-out'}, {value: 1, bet: 'sit-out'}, {value: 2, bet: 'sit-out'}, {value: 4, bet: 'sit-out'}, {value: 8, bet: 'sit-out'}, {value: 15, bet: 'sit-out'}, {value: 30, bet: 'sit-out'}, {value: 61, bet: 'sit-out'}]
                ];


                const elements = {
                    // General UI
                    roadmap: document.getElementById('roadmap'),
                    chartArea: document.getElementById('chartArea'),
                    messageBox: document.getElementById('messageBox'),
                    strategyTabs: document.getElementById('strategyTabs'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    timeValue: document.getElementById('timeValue'),

                    // Card Counting Tab Elements
                    betRecommendation: document.getElementById('betRecommendation'),
                    betAmount: document.getElementById('betAmount'),
                    countResultValue: document.getElementById('countResultValue'),
                    countDesc: document.getElementById('countDesc'),
                    playerBets: document.getElementById('playerBets'),
                    bankerBets: document.getElementById('bankerBets'),
                    tieBets: document.getElementById('tieBets'),
                    totalEntries: document.getElementById('totalEntries'),
                    entriesNeeded: document.getElementById('entriesNeeded'),
                    decksRemaining: document.getElementById('decksRemaining'),
                    cardButtons: document.querySelectorAll('.card-btn'),
                    clearBtn: document.getElementById('clearBtn'),
                    historyList: document.getElementById('historyList'),

                    // Pattern Recognition Tab Elements
                    patternDropdownBtn: document.getElementById('patternDropdownBtn'),
                    selectedPatternText: document.getElementById('selectedPatternText'),
                    patternDropdownMenu: document.getElementById('patternDropdownMenu'),
                    patternStrategyDetails: document.getElementById('patternStrategyDetails'),
                    patternInputArea: document.getElementById('patternInputArea'),
                    patternOutcomeButtons: document.querySelectorAll('#patternInputArea .strategy-btn'),
                    clearPatternBtn: document.getElementById('clearPatternBtn'),
                    patternAnalysisResult: document.getElementById('patternAnalysisResult'),
                    patternBettingControls: document.getElementById('patternBettingControls'),
                    enableBettingProgressionToggle: document.getElementById('enableBettingProgressionToggle'), // New toggle
                    patternCurrentTheoreticalBankroll: document.getElementById('patternCurrentTheoreticalBankroll'),


                    // Betting Progression within Pattern Recognition
                    bettingProgressionDropdownBtn: document.getElementById('bettingProgressionDropdownBtn'),
                    selectedBettingProgressionText: document.getElementById('selectedBettingProgressionText'),
                    bettingProgressionDropdownMenu: document.getElementById('bettingProgressionDropdownMenu'),
                    patternBettingSystemDetails: document.getElementById('patternBettingSystemDetails'),
                    patternBettingInputArea: document.getElementById('patternBettingInputArea'),
                    patternNextBetAmount: document.getElementById('patternNextBetAmount'),
                    patternCurrentBaseBet: document.getElementById('patternCurrentBaseBet'),
                    patternResetBettingBtn: document.getElementById('patternResetBettingBtn'),
                    betUnitValueInput: document.getElementById('betUnitValueInput'),
                    setBetUnitValueBtn: document.getElementById('setBetUnitValueBtn'),
                    patternAnalysisChartCanvas: document.getElementById('patternAnalysisChart'),
                    patternChartContainer: document.getElementById('patternChartContainer'),
                    patternOutcomeDistributionChartCanvas: document.getElementById('patternOutcomeDistributionChart'), // NEW element
                    patternOutcomeDistributionChartContainer: document.getElementById('patternOutcomeDistributionChartContainer'), // NEW container

                    // Mini-Game Tab Elements
                    miniGameBalanceDisplay: document.getElementById('miniGameBalanceDisplay'), // New element for Mini-Game balance
                    betOptionBtns: document.querySelectorAll('.bet-option-btn'),
                    betAmountInput: document.getElementById('betAmountInput'),
                    dealHandBtn: document.getElementById('dealHandBtn'),
                    playerCardList: document.getElementById('playerCardList'),
                    bankerCardList: document.getElementById('bankerCardList'),
                    playerScore: document.getElementById('playerScore'),
                    bankerScore: document.getElementById('bankerScore'),
                    gameResultDisplay: document.getElementById('gameResultDisplay'),
                    gameResultText: document.getElementById('gameResultText'),
                    gameNewBalance: document.getElementById('gameNewBalance')
                };

                // Initialize mini-game balance display
                elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;

                // Display a temporary message
                function displayMessage(message, type) {
                    elements.messageBox.textContent = message;
                    elements.messageBox.className = `message-box show ${type} animate-fade-slide-up`; // Added animation

                    // Hide the message after 3 seconds with fade out
                    setTimeout(() => {
                        elements.messageBox.classList.remove('show');
                        elements.messageBox.classList.add('animate__fadeOut'); // Animate.css fadeOut
                        setTimeout(() => {
                            elements.messageBox.textContent = ''; // Clear text after animation
                            elements.messageBox.classList.remove('animate__fadeOut');
                        }, 500); // Duration of fadeOut animation
                    }, 3000);
                }

                // Start the countdown timer
                function startTimer() {
                    if (gameState.timer) clearInterval(gameState.timer);

                    updateTimerDisplay(); // Initial update

                    gameState.timer = setInterval(() => {
                        const remaining = updateTimerDisplay();
                        if (remaining <= 0) {
                            clearInterval(gameState.timer);
                            handleKeyExpiration();
                        }
                    }, 1000);
                }

                // Update the timer display and return remaining seconds
                function updateTimerDisplay() {
                    const keyRegistry = JSON.parse(localStorage.getItem('baccaratKeyRegistry') || '{}');
                    const keyInfo = keyRegistry[gameState.activeKey];
                    if (!keyInfo) return 0;

                    const expirationDate = new Date(keyInfo.firstUsed);
                    expirationDate.setMinutes(expirationDate.getMinutes() + keyInfo.expiresIn); // Add expiresIn to firstUsed to get expiration point
                    const now = new Date();
                    const remaining = Math.max(0, Math.floor((expirationDate - now) / 1000));
                    
                    elements.timeValue.textContent = formatTime(remaining);

                    if (remaining <= 300) { // 5 minutes or less
                        elements.timeValue.style.color = 'var(--danger)';
                        timeContainer.classList.add('animate__pulse'); // Using pulse for glow
                    } else if (remaining <= 900) { // 15 minutes or less
                        elements.timeValue.style.color = 'var(--warning)';
                        timeContainer.classList.remove('animate__pulse');
                    } else {
                        elements.timeValue.style.color = 'var(--info)';
                        timeContainer.classList.remove('animate__pulse');
                    }
                    return remaining;
                }

                // Handle key expiration
                function handleKeyExpiration() {
                    localStorage.removeItem('baccaratAuthKey');
                    localStorage.removeItem('baccaratAuthFingerprint');

                    mainContent.style.display = 'none';
                    authOverlay.style.display = 'flex';
                    authOverlay.style.opacity = '1';
                    authError.textContent = "Your access key has expired. Please renew your subscription.";
                    authError.style.display = 'block';
                    authKeyInput.value = gameState.activeKey;
                    timeRemaining.style.display = 'none';
                    authSubmitBtn.disabled = false; // Re-enable auth button
                    displayMessage('Your session has expired. Please authenticate again.', 'error'); // Notify user
                }

                // Card counting logic
                /**
                 * Calculates the count contribution of a single card based on specific Baccarat counting rules.
                 * @param {string} cardValue The card value as a string (e.g., 'A', '2', '10', 'J', 'Q', 'K').
                 * @returns {number} The numerical count adjustment for the card.
                 */
                function getCardCountContribution(cardValue) {
                    switch (cardValue) {
                        case 'A': return -1;
                        case '2':
                        case '3': return -1;
                        case '4':
                        case '5': return -5;
                        case '6':
                        case '7': return +5;
                        case '8':
                        case '9': return +1;
                        case '10':
                        case 'J':
                        case 'Q':
                        case 'K': return 0; // 10 and Face cards contribute 0
                        default: return 0; // Fallback for unexpected values
                    }
                }

                /**
                 * Calculates the current running count based on all entered cards.
                 * @returns {number} The current running count.
                 */
                function calculateRunningCount() {
                    let totalCount = 0;
                    gameState.entries.forEach(card => {
                        totalCount += getCardCountContribution(card);
                    });
                    return totalCount;
                }

                /**
                 * Determines the prediction (Banker, Player, Tie, or No Prediction) based on the running count.
                 * This logic is based on the user's provided script's specific odd/even/zero count rules.
                 * @returns {{prediction: string, countResult: number}} The prediction and the count result.
                 */
                function getPrediction() {
                    const currentCount = calculateRunningCount();
                    if (gameState.entries.length === 0) {
                        // If no cards entered, show "No Prediction"
                        return { prediction: "no prediction", countResult: 0 };
                    }
                    let prediction = "";
                    if (currentCount === 0) {
                        prediction = "tie";
                    } else if (currentCount % 2 !== 0) { // Odd count
                        prediction = "banker";
                    } else { // Even count
                        prediction = "player";
                    }
                    return { prediction: prediction, countResult: currentCount };
                }

                // Chart and UI updates for Card Counting
                function initChart() {
                    elements.chartArea.innerHTML = '<canvas id="myChart"></canvas>';
                    const ctx = document.getElementById('myChart');

                    const style = getComputedStyle(document.documentElement);
                    const primaryColor = style.getPropertyValue('--primary').trim();
                    const primaryColorRgba = `rgba(${parseInt(primaryColor.slice(1,3), 16)}, ${parseInt(primaryColor.slice(3,5), 16)}, ${parseInt(primaryColor.slice(5,7), 16)}, 0.1)`;

                    gameState.chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Running Count',
                                data: [],
                                borderColor: primaryColor,
                                backgroundColor: primaryColorRgba,
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: primaryColor
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: '#fff',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return `Count: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: '#fff' }
                                },
                                y: {
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: '#fff' }
                                }
                            },
                            animation: {
                                duration: 1200,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updateChart() {
                    const labels = [];
                    const countData = [];
                    let tempCount = 0;
                    gameState.entries.forEach((card, index) => {
                        labels.push(`Card ${index + 1}`);
                        tempCount += getCardCountContribution(card);
                        countData.push(tempCount);
                    });

                    gameState.chart.data.labels = labels;
                    gameState.chart.data.datasets[0].data = countData;
                    gameState.chart.update();
                }

                function updateRoadmap() {
                    elements.roadmap.innerHTML = '';
                    gameState.entries.forEach((card, index) => {
                        const cell = document.createElement('div');
                        cell.className = `cell flex-shrink-0 animate-pop-in`;
                        cell.textContent = card === '10' ? '10/F' : card;
                        cell.style.animationDelay = `${index * 0.03}s`; // Staggered animation

                        // Only apply prediction styling to the most recently added card's cell
                        if (index === gameState.entries.length - 1) {
                            const predictionResult = getPrediction();
                            if (predictionResult && predictionResult.prediction !== "no prediction") {
                                const prediction = predictionResult.prediction;
                                if (prediction === 'player') {
                                    cell.classList.add('predicted-player');
                                } else if (prediction === 'banker') {
                                    cell.classList.add('predicted-banker');
                                } else if (prediction === 'tie') {
                                    cell.classList.add('predicted-tie');
                                }
                                cell.title = `Card ${index + 1}: ${card} (Current Prediction: ${prediction.toUpperCase()})`;
                            }
                        } else {
                            cell.title = `Card ${index + 1}: ${card}`;
                        }
                        elements.roadmap.appendChild(cell);
                    });
                }

                function updateStats() {
                    const playerBets = gameState.predictionHistory.filter(p => p.prediction === 'player').length;
                    const bankerBets = gameState.predictionHistory.filter(p => p.prediction === 'banker').length;
                    const tieBets = gameState.predictionHistory.filter(p => p.prediction === 'tie').length;

                    elements.playerBets.textContent = playerBets;
                    elements.bankerBets.textContent = bankerBets;
                    elements.tieBets.textContent = tieBets;
                    elements.totalEntries.textContent = gameState.entries.length;

                    const totalCardsInShoe = gameState.totalDecks * 52;
                    const cardsRemaining = totalCardsInShoe - gameState.entries.length;
                    const decksRemaining = (cardsRemaining / 52).toFixed(2);
                    elements.decksRemaining.textContent = Math.max(0, parseFloat(decksRemaining)); // Don't go negative

                    elements.entriesNeeded.textContent = gameState.entries.length > 0 ? gameState.entries.length : 'N/A';
                    elements.countResultValue.textContent = calculateRunningCount();
                }

                function updateHistory() {
                    elements.historyList.innerHTML = '';
                    gameState.predictionHistory.slice().reverse().forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item animate-fade-slide-up';
                        historyItem.style.animationDelay = `${index * 0.05}s`;

                        const predictionNum = document.createElement('span');
                        predictionNum.textContent = `Hand ${gameState.predictionHistory.length - index}`;

                        const result = document.createElement('span');
                        result.className = `history-outcome ${item.prediction}`;
                        let outcomeText = item.prediction.charAt(0).toUpperCase() + item.prediction.slice(1);
                        if (item.countResult !== null) {
                            outcomeText += ` (Count: ${item.countResult})`;
                        }
                        result.textContent = outcomeText;

                        historyItem.appendChild(predictionNum);
                        historyItem.appendChild(result);
                        elements.historyList.appendChild(historyItem);
                    });
                }

                function updateRecommendation() {
                    const recommendationTextElement = elements.betRecommendation.querySelector('.recommendation-text');
                    const betAmountElement = elements.betAmount;
                    const countResultValueElement = elements.countResultValue;
                    const countDescElement = elements.countDesc;

                    // Apply animations to these elements
                    recommendationTextElement.classList.remove('animate__animated', 'animate__fadeIn');
                    countResultValueElement.classList.remove('animate__animated', 'animate__bounceIn');
                    countDescElement.classList.remove('animate__animated', 'animate__fadeIn');
                    void recommendationTextElement.offsetWidth; // Trigger reflow
                    void countResultValueElement.offsetWidth; // Trigger reflow
                    void countDescElement.offsetWidth; // Trigger reflow
                    recommendationTextElement.classList.add('animate__animated', 'animate__fadeIn');
                    countResultValueElement.classList.add('animate__animated', 'animate__bounceIn');
                    countDescElement.classList.add('animate__animated', 'animate__fadeIn');


                    if (gameState.entries.length === 0) {
                        recommendationTextElement.textContent = "Enter cards to see prediction";
                        recommendationTextElement.className = "recommendation-text no-bet";
                        betAmountElement.textContent = "";
                        countResultValueElement.textContent = "0";
                        countDescElement.textContent = "This is the numerical result from the counting system.";
                        elements.betRecommendation.classList.remove('animate-glow');
                        return;
                    }

                    const predictionResult = getPrediction();
                    const countResult = predictionResult.countResult;
                    const absCount = Math.abs(countResult);

                    let betMessage = `Bet ${predictionResult.prediction.charAt(0).toUpperCase() + predictionResult.prediction.slice(1)}`;
                    if (predictionResult.prediction !== "no prediction") {
                        betMessage += ` (Count: ${countResult})`;
                    } else {
                        betMessage = `No clear prediction yet. (Count: ${countResult})`;
                    }

                    recommendationTextElement.textContent = betMessage;
                    if (predictionResult.prediction === "no prediction") {
                        recommendationTextElement.className = "recommendation-text no-bet";
                    } else {
                        recommendationTextElement.className = "recommendation-text bet-suggestion";
                    }

                    // Fixed recommended bet for card counter section
                    const recommendedBet = 500; // This value is fixed as per requirement
                    betAmountElement.textContent = `Suggested Bet: $${recommendedBet.toLocaleString()}`;

                    countResultValueElement.textContent = countResult;

                    let description = "This is the numerical result from the counting system.";
                    if (countResult === 0) {
                        description = "Count is 0: Consider betting Tie, or wait for a clearer edge.";
                    } else if (absCount === 1) {
                        description = "Count is 1 (or -1): Slight edge, proceed with caution.";
                    } else if (absCount >= 2 && absCount <= 5) {
                        description = "Count is 2-5 (or -2 to -5): Moderate edge, increased bet suggested.";
                    } else if (absCount >= 6 && absCount <= 9) {
                        description = "Count is 6-9 (or -6 to -9): Significant edge, higher bets recommended.";
                    } else if (absCount >= 10 && absCount <= 14) {
                        description = "Count is 10-14 (or -10 to -14): Strong edge, significant bets advisable.";
                    } else if (absCount >= 15) {
                        description = "Count is 15+ (or -15+): Very strong edge, maximum bets recommended!";
                    }
                    countDescElement.textContent = description;

                    elements.betRecommendation.classList.add('animate-glow');
                    setTimeout(() => {
                        elements.betRecommendation.classList.remove('animate-glow');
                    }, 2000);

                    // Only add to history if there's a valid prediction (not "no prediction") and it's a new final state
                    if (predictionResult.prediction !== "no prediction" &&
                        (gameState.predictionHistory.length === 0 || 
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].prediction !== predictionResult.prediction ||
                        gameState.predictionHistory[gameState.predictionHistory.length - 1].countResult !== predictionResult.countResult)) {
                        gameState.predictionHistory.push({
                            prediction: predictionResult.prediction,
                            countResult: predictionResult.countResult,
                            timestamp: new Date().toLocaleTimeString()
                        });
                        updateHistory();
                    }
                    updateChart();
                }

                // Add new card entry
                function addCardEntry(cardValue) {
                    gameState.entries.push(cardValue);
                    gameState.cardsDealt++; // Increment cards dealt for deck estimation
                    updateStats();
                    updateRoadmap();
                    updateRecommendation();
                    displayMessage(`Card '${cardValue}' added.`, 'success');
                }

                // Clear all history and reset state for Card Counting
                function clearAllCardCounting() {
                    gameState.entries = [];
                    gameState.predictionHistory = [];
                    gameState.cardsDealt = 0;

                    elements.roadmap.classList.add('animate__fadeOut');
                    elements.chartArea.classList.add('animate__fadeOut');
                    
                    setTimeout(() => {
                        updateRoadmap();
                        updateChart();
                        updateStats();
                        updateHistory();

                        elements.betRecommendation.querySelector('.recommendation-text').textContent = "Enter cards to see prediction";
                        elements.betRecommendation.querySelector('.recommendation-text').className = "recommendation-text no-bet";
                        elements.betAmount.textContent = "";
                        elements.countResultValue.textContent = "0";
                        elements.countDesc.textContent = "This is the numerical result from the counting system.";

                        elements.roadmap.classList.remove('animate__fadeOut');
                        elements.chartArea.classList.remove('animate__fadeOut');
                        elements.roadmap.classList.add('animate__fadeIn');
                        elements.chartArea.classList.add('animate__fadeIn');
                        setTimeout(() => {
                            elements.roadmap.classList.remove('animate__fadeIn');
                            elements.chartArea.classList.remove('animate__fadeIn');
                        }, 500);
                    }, 500); // Wait for fadeOut to complete
                    displayMessage('Card Counting data cleared.', 'info');
                }

                // =============================================
                // Pattern Recognition Functions
                // =============================================
                function toggleDropdown(dropdownMenu) {
                    dropdownMenu.classList.toggle('show');
                }

                function selectPatternStrategy(strategy) {
                    if (gameState.currentPatternStrategy === strategy) {
                        elements.patternDropdownMenu.classList.remove('show');
                        return; // Already selected
                    }

                    gameState.currentPatternStrategy = strategy;
                    elements.selectedPatternText.textContent = strategy.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace('Pbpbpb', 'PBPBPB').replace('Patternmethod', 'Pattern Method').replace('Dragonpattern', 'Dragon Pattern').replace('Twospattern', 'Two-in-a-row Pattern');
                    elements.patternDropdownMenu.classList.remove('show');
                    
                    elements.patternInputArea.classList.remove('hidden');
                    elements.patternAnalysisResult.classList.add('hidden'); // Hide result until new data
                    elements.patternAnalysisResult.innerHTML = ''; // Clear previous results
                    
                    gameState.patternHistory = []; // Reset pattern history on strategy change
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 }; // Reset for "Pattern Method"
                    gameState.currentPatternRecommendation = null; // Reset recommendation on strategy change

                    gameState.bankrollTimeline = []; // Clear timeline on strategy change
                    updatePatternAnalysisChart(); // Update bankroll chart to clear
                    elements.patternChartContainer.classList.add('hidden'); // Hide bankroll chart initially

                    initMasanielloGrid(); // Re-initialize Masaniello grid state (but not draw until needed)
                    updatePatternDetails(); // Update details area
                    
                    initPatternOutcomeDistributionChart(); // Initialize new chart
                    updatePatternOutcomeDistributionChart(); // Update new chart immediately
                    elements.patternOutcomeDistributionChartContainer.classList.remove('hidden'); // Show outcome chart

                    // Animate the pattern recognition section when a strategy is selected
                    document.getElementById('patternRecognition').classList.add('animate-fade-slide-up');
                    setTimeout(() => {
                        document.getElementById('patternRecognition').classList.remove('animate-fade-slide-up');
                    }, 600);
                    displayMessage(`Strategy '${elements.selectedPatternText.textContent}' selected.`, 'info');
                }

                function updatePatternDetails() {
                    let detailsHtml = '';
                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            detailsHtml = `<p class="text-medium">This "Pattern Method" provides an intuitive suggestion for your next bet. It adapts to the flow of the game to guide your decisions.</p>`;
                            break;
                        case 'pbpbpbPattern':
                            detailsHtml = `<p class="text-medium">This strategy looks for a repeating Player-Banker-Player-Banker (PBPBPB) sequence. If identified, it suggests betting on the continuation of this alternating pattern.</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="pbpbpbHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'dragonPattern':
                            detailsHtml = `<p class="text-medium">The Dragon Pattern strategy identifies streaks of three or more consecutive Player or Banker wins. It recommends betting on the continuation of the current streak.</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="dragonHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'twosPattern':
                            detailsHtml = `<p class="text-medium">The Two-in-a-row Pattern strategy looks for sequences where an outcome appears twice, then switches (e.g., P P B, B B P). It recommends betting on the next expected outcome in that sequence.</p>
                                           <p class="font-semibold mt-4 text-medium">Current Pattern History: <span id="twosHistory" class="font-normal text-gray-300"></span></p>`;
                            break;
                        case 'masaniello':
                            detailsHtml = `<p class="text-medium">The Masaniello staking plan aims to maximize profit and manage risk within a series of bets. This visualization tracks your progress through the plan based on game outcomes.</p>
                                           <h4 class="font-semibold mt-4 text-medium">Masaniello Chart</h4>
                                           <p class="text-sm text-gray-500 mt-1">Current Position: [Col <span id="masanielloCurrentCol">${gameState.masanielloState.currentCol}</span>, Row <span id="masanielloCurrentRow">${gameState.masanielloState.currentRow}</span>]</p>
                                           <div class="masaniello-chart-container">
                                               <div id="masanielloGrid" class="masaniello-grid"></div>
                                               <div class="masaniello-legend">
                                                   <div class="legend-item"><span class="legend-color-box player-bg"></span> Player Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box banker-bg"></span> Banker Bet</div>
                                                   <div class="legend-item"><span class="legend-color-box sit-out-bg"></span> Sit Out</div>
                                               </div>
                                           </div>`;
                            break;
                        default:
                            detailsHtml = `<p class="text-center text-gray-400">Choose a pattern strategy from the dropdown above to see its description and controls.</p>`;
                    }
                    elements.patternStrategyDetails.innerHTML = detailsHtml;
                    if (gameState.currentPatternStrategy === 'masaniello') {
                        drawMasanielloGrid();
                        elements.patternOutcomeDistributionChartContainer.classList.add('hidden'); // Hide outcome distribution chart for Masaniello
                        elements.patternChartContainer.classList.add('hidden'); // Hide bankroll chart for Masaniello
                    } else {
                         elements.patternOutcomeDistributionChartContainer.classList.remove('hidden'); // Show outcome distribution chart for other strategies
                         updatePatternOutcomeDistributionChart();
                         if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem) {
                            elements.patternChartContainer.classList.remove('hidden'); // Show bankroll chart if progression enabled
                            updatePatternAnalysisChart();
                         } else {
                            elements.patternChartContainer.classList.add('hidden'); // Hide bankroll chart
                         }
                    }
                    updatePatternAnalysis(); // Update prediction after details are loaded
                }

                // Masaniello Grid Initialization and Drawing
                function initMasanielloGrid() {
                    gameState.masanielloState.grid = JSON.parse(JSON.stringify(masanielloGridConfig)); // Deep copy
                    gameState.masanielloState.currentRow = masanielloGridConfig.length - 1; // Start at bottom row (row 9)
                    gameState.masanielloState.currentCol = 0; // Start at first column
                }

                function drawMasanielloGrid() {
                    const gridElement = document.getElementById('masanielloGrid');
                    if (!gridElement) return;

                    gridElement.innerHTML = '';
                    // Iterate rows in reverse to draw from bottom up as in screenshot
                    for (let r = gameState.masanielloState.gridRows - 1; r >= 0; r--) {
                        for (let c = 0; c < gameState.masanielloState.gridCols; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'masaniello-cell';
                            const cellData = masanielloGridConfig[r][c]; // Use fixed config for cell data

                            cell.innerHTML = `<span class="value">${cellData.value}</span><span class="bet-type">${cellData.bet.replace('-', ' ').toUpperCase()}</span>`;

                            // Add background color class based on bet type
                            if (cellData.bet === 'player') {
                                cell.classList.add('player-bg');
                            } else if (cellData.bet === 'banker') {
                                cell.classList.add('banker-bg');
                            } else if (cellData.bet === 'sit-out') {
                                cell.classList.add('sit-out-bg');
                            }

                            if (r === gameState.masanielloState.currentRow && c === gameState.masanielloState.currentCol) {
                                cell.classList.add('active-position');
                            }
                            gridElement.appendChild(cell);
                        }
                    }
                    // Update current position display in text
                    const currentColSpan = document.getElementById('masanielloCurrentCol');
                    const currentRowSpan = document.getElementById('masanielloCurrentRow');
                    if (currentColSpan) currentColSpan.textContent = gameState.masanielloState.currentCol;
                    if (currentRowSpan) currentRowSpan.textContent = gameState.masanielloState.currentRow;
                }

                function updateMasanielloPosition(outcome) {
                    let { currentRow, currentCol, gridRows, gridCols } = gameState.masanielloState;
                    const currentCell = masanielloGridConfig[currentRow][currentCol]; // Get data from fixed config

                    // Determine if the recorded outcome matches the suggested bet for Masaniello progression
                    let isWinForMasaniello = null; // null for no change, true for win, false for loss
                    if (currentCell.bet === 'player' && outcome === 'player') {
                        isWinForMasaniello = true;
                    } else if (currentCell.bet === 'banker' && outcome === 'banker') {
                        isWinForMasaniello = true;
                    } else if (currentCell.bet === 'player' && outcome === 'banker') {
                        isWinForMasaniello = false;
                    } else if (currentCell.bet === 'banker' && outcome === 'player') {
                        isWinForMasaniello = false;
                    }
                    // If currentCell.bet is 'sit-out' or outcome is 'tie', isWinForMasaniello remains null, no position change

                    if (isWinForMasaniello === true) {
                        // Win: move up one row, stay in current column
                        currentRow = Math.max(0, currentRow - 1); // Row 0 is the top
                    } else if (isWinForMasaniello === false) {
                        // Loss: move right one column, stay in current row
                        currentCol = Math.min(gridCols - 1, currentCol + 1); // Column 9 is the rightmost
                    }
                    // Else: isWinForMasaniello is null (tie/sit-out/unmatched bet), no position change

                    // Ensure positions stay within grid boundaries
                    currentRow = Math.max(0, Math.min(gridRows - 1, currentRow));
                    currentCol = Math.max(0, Math.min(gridCols - 1, currentCol));

                    gameState.masanielloState.currentRow = currentRow;
                    gameState.masanielloState.currentCol = currentCol;
                    drawMasanielloGrid(); // Redraw grid with new active position
                }


                function recordPatternOutcome(outcome) {
                    gameState.patternHistory.push(outcome);
                    gameState.outcomeCounts[outcome]++; // Update counts for "Pattern Method"
                    displayMessage(`Outcome: ${outcome.toUpperCase()} recorded.`, 'info');
                    updatePatternOutcomeDistributionChart(); // Update new chart on every outcome


                    let impliedBetTarget = null; // What the strategy suggests to bet on for this round

                    // Determine impliedBetTarget based on the selected pattern strategy
                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            impliedBetTarget = getPatternMethodPrediction();
                            break;
                        case 'pbpbpbPattern':
                            impliedBetTarget = getPBPBPBRecommendation();
                            break;
                        case 'dragonPattern':
                            impliedBetTarget = getDragonRecommendation();
                            break;
                        case 'twosPattern':
                            impliedBetTarget = getTwosPatternRecommendation();
                            break;
                        case 'masaniello':
                            updateMasanielloPosition(outcome); // Update Masaniello grid position
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            impliedBetTarget = currentMasanielloCell.bet; // Recommendation from Masaniello chart
                            break;
                    }
                    // Crucial fix: Update the global pattern recommendation state
                    gameState.currentPatternRecommendation = impliedBetTarget;
                    
                    let bettingOutcome = null; // Will be 'win', 'loss', or 'push' for betting progression
                    
                    // Determine win/loss/push for betting progression based on implied bet target
                    if (outcome === 'tie') { // Actual outcome was a Tie
                        bettingOutcome = 'push'; // A tie usually results in a push for Player/Banker bets
                    } else if (impliedBetTarget === 'sit-out' || impliedBetTarget === 'no_clear_pattern') {
                        // If strategy suggested 'sit-out' or there was no clear pattern, it's a push for betting purposes.
                        bettingOutcome = 'push';
                    } else if (impliedBetTarget === outcome) {
                        bettingOutcome = 'win';
                    } else {
                        bettingOutcome = 'loss';
                    }

                    updatePatternAnalysis(); // Update pattern-specific analysis display

                    // Automatically apply betting progression ONLY if enabled and a system is selected
                    if (gameState.patternBetting.isEnabled && gameState.patternBetting.currentSystem && bettingOutcome) {
                         // Only update bankroll if it's a definite win or loss, not a push
                        if (bettingOutcome === 'win' || bettingOutcome === 'loss') {
                            updateTheoreticalBankroll(bettingOutcome, impliedBetTarget);
                            // Store data for chart after bankroll update
                            gameState.bankrollTimeline.push({
                                outcomeIndex: gameState.patternHistory.length, // Current number of outcomes
                                bankroll: gameState.patternBetting.theoreticalBankroll,
                                actualOutcome: outcome
                            });
                            updatePatternAnalysisChart();
                        } else {
                            displayMessage('Betting progression: Push (no change).', 'info');
                            // Still store push to timeline to reflect time progression
                            gameState.bankrollTimeline.push({
                                outcomeIndex: gameState.patternHistory.length,
                                bankroll: gameState.patternBetting.theoreticalBankroll, // Bankroll doesn't change on push
                                actualOutcome: outcome
                            });
                            updatePatternAnalysisChart();
                            updatePatternNextBetDisplay(); // Ensure next bet is updated even on push
                        }
                    } else if (gameState.patternBetting.isEnabled && !gameState.patternBetting.currentSystem) {
                        displayMessage('Select a betting progression system to apply it automatically!', 'warning');
                    }
                }
                
                // Logic for "Pattern Method" prediction based on last 15 outcomes.
                function getPatternMethodPrediction() {
                    const recentHistory = gameState.patternHistory.slice(-15); // Look at last 15 outcomes
                    if (recentHistory.length === 0) return 'no_clear_pattern'; // No history, sit out

                    const counts = { player: 0, banker: 0, tie: 0 };
                    recentHistory.forEach(outcome => {
                        counts[outcome]++;
                    });

                    // Determine the most frequent outcome among Player and Banker
                    if (counts.player > counts.banker) {
                        return 'player';
                    } else if (counts.banker > counts.player) {
                        return 'banker';
                    } else {
                        // If equal, prefer Banker (common casino practice), or Tie if it's dominant.
                        // For simplicity, if Player and Banker are tied, default to banker.
                        return 'banker';
                    }
                }


                function getPBPBPBRecommendation() {
                    const historyLength = gameState.patternHistory.length;
                    if (historyLength < 2) return 'no_clear_pattern';

                    const lastOutcome = gameState.patternHistory[historyLength - 1];
                    const secondLastOutcome = gameState.patternHistory[historyLength - 2];

                    if (lastOutcome !== secondLastOutcome && lastOutcome !== 'tie' && secondLastOutcome !== 'tie') { // Alternating pattern (excluding ties for clarity)
                        return lastOutcome === 'player' ? 'banker' : 'player'; // Suggest opposite of last
                    }
                    return 'no_clear_pattern';
                }

                function getDragonRecommendation() {
                    const history = gameState.patternHistory;
                    const historyLength = history.length;
                    if (historyLength < 3) return 'no_clear_pattern'; // Need at least 3 for a streak

                    const lastOutcome = history[historyLength - 1];
                    const secondLastOutcome = history[historyLength - 2];
                    const thirdLastOutcome = history[historyLength - 3];

                    // Check for a streak of 3 or more of the same outcome (excluding ties)
                    if (lastOutcome === secondLastOutcome && secondLastOutcome === thirdLastOutcome && (lastOutcome === 'player' || lastOutcome === 'banker')) {
                        return lastOutcome; // Recommend continuing the streak
                    }
                    return 'no_clear_pattern';
                }

                function getTwosPatternRecommendation() {
                    const history = gameState.patternHistory;
                    const historyLength = history.length;
                    if (historyLength < 3) return 'no_clear_pattern'; // Need at least 3 for "X X Y"

                    const lastOutcome = history[historyLength - 1];
                    const secondLastOutcome = history[historyLength - 2];
                    const thirdLastOutcome = history[historyLength - 3];

                    // Check for A A B pattern (e.g., Player-Player-Banker)
                    if (secondLastOutcome === thirdLastOutcome && secondLastOutcome !== lastOutcome && (secondLastOutcome === 'player' || secondLastOutcome === 'banker')) {
                        return secondLastOutcome; // Recommend Player for P P B (expect P next), or Banker for B B P (expect B next)
                    }
                    return 'no_clear_pattern';
                }


                function updatePatternAnalysis() {
                    const resultDiv = elements.patternAnalysisResult;
                    resultDiv.classList.remove('hidden');
                    resultDiv.classList.add('animate__animated', 'animate__fadeIn'); // Animate result in
                    setTimeout(() => resultDiv.classList.remove('animate__fadeIn'), 800); // Remove animation class

                    resultDiv.innerHTML = ''; // Clear previous content

                    let recommendationText = '';
                    if (gameState.patternHistory.length === 0) {
                        resultDiv.innerHTML = `<p class="text-gray-400">No outcomes recorded yet. Enter Banker, Player, or Tie to start.</p>`;
                        return;
                    }

                    let currentRecommendation = gameState.currentPatternRecommendation;

                    switch (gameState.currentPatternStrategy) {
                        case 'patternMethod':
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span>`;
                            } else {
                                recommendationText = `Recommendation: <span class="text-danger font-bold">NO CLEAR BET</span>`;
                            }
                            resultDiv.innerHTML = `<p class="text-info mt-2">${recommendationText}</p>
                                                   <p class="text-sm text-gray-500 mt-2">Based on analysis of recent trends.</p>`;
                            break;
                        case 'pbpbpbPattern':
                            if(document.getElementById('pbpbpbHistory')) document.getElementById('pbpbpbHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following PBPBPB)`;
                            } else {
                                recommendationText = `No clear PBPBPB pattern observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-chart-line text-5xl text-gray-600 opacity-70"></i>
                                                <p class="text-sm text-gray-500 mt-2">Visual trend analysis can be added here.</p>
                                            </div>`;
                            break;
                        case 'dragonPattern':
                            if(document.getElementById('dragonHistory')) document.getElementById('dragonHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following Dragon)`;
                            } else {
                                recommendationText = `No clear Dragon pattern (streak of 3+) observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-fire text-5xl text-gray-600 opacity-70"></i>
                                                <p class="text-sm text-gray-500 mt-2">Looks for long streaks.</p>
                                            </div>`;
                            break;
                        case 'twosPattern':
                            if(document.getElementById('twosHistory')) document.getElementById('twosHistory').textContent = gameState.patternHistory.map(h => h.toUpperCase()).join(', ');
                            if (currentRecommendation && currentRecommendation !== 'no_clear_pattern') {
                                recommendationText = `Next recommended bet: <span class="text-success font-bold">${currentRecommendation.toUpperCase()}</span> (following Two-in-a-row)`;
                            } else {
                                recommendationText = `No clear Two-in-a-row pattern observed yet.`;
                            }
                            resultDiv.innerHTML = `<p class="text-lg">${recommendationText}</p>
                                            <div class="mt-4 animate__animated animate__fadeInUp">
                                                <i class="fas fa-arrows-alt-h text-5xl text-gray-600 opacity-70"></i>
                                                <p class="text-sm text-gray-500 mt-2">Looks for paired outcomes.</p>
                                            </div>`;
                            break;
                        case 'masaniello':
                            drawMasanielloGrid(); // Ensure grid is drawn/updated
                            const currentCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            let suggestedBetDisplay = currentCell.bet === 'sit-out' ? 'SIT OUT' : currentCell.bet.toUpperCase();
                            resultDiv.innerHTML = `<p class="text-light">Masaniello Chart displays your current staking position.</p>
                                            <p class="text-warning font-bold mt-2">Suggested Bet Unit: ${currentCell.value}</p>
                                            <p class="text-info font-bold mt-2">Suggested Bet Type: ${suggestedBetDisplay}</p>
                                            <p class="text-sm text-gray-500">Track your progress on the grid above.</p>`;
                            break;
                        default:
                            resultDiv.innerHTML = `<p class="text-gray-400">Select a strategy to begin analysis.</p>`;
                    }

                    // Only update the betting display if progression is enabled
                    if (gameState.patternBetting.isEnabled) {
                        updatePatternNextBetDisplay();
                    }
                }

                function clearPatternHistory() {
                    gameState.patternHistory = [];
                    gameState.outcomeCounts = { player: 0, banker: 0, tie: 0 };
                    gameState.currentPatternRecommendation = null;
                    displayMessage('Pattern history cleared.', 'success');
                    
                    initMasanielloGrid(); // Reset Masaniello state to start
                    updatePatternDetails(); // Re-render details to reflect cleared state
                    updatePatternOutcomeDistributionChart(); // Clear outcome distribution chart

                    elements.patternAnalysisResult.classList.add('hidden'); // Hide result until new data
                    elements.patternAnalysisResult.innerHTML = ''; // Clear previous results
                    
                    resetPatternBettingSystem(); // Reset betting progression state
                    elements.clearPatternBtn.classList.add('animate__shakeX');
                    setTimeout(() => {
                        elements.clearPatternBtn.classList.remove('animate__shakeX');
                    }, 1000);
                }


                // =============================================
                // Betting Systems Functions (moved to Pattern Recognition context)
                // =============================================
                function selectPatternBettingSystem(system) {
                    if (gameState.patternBetting.currentSystem === system) {
                        elements.bettingProgressionDropdownMenu.classList.remove('show');
                        return; // Already selected
                    }
                    gameState.patternBetting.currentSystem = system;
                    elements.selectedBettingProgressionText.textContent = system.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    elements.bettingProgressionDropdownMenu.classList.remove('show');
                    
                    elements.patternBettingInputArea.classList.remove('hidden');
                    updatePatternBettingSystemDetails();
                    resetPatternBettingSystem(false); // Reset state but don't reset selected system
                    displayMessage(`Betting system '${elements.selectedBettingProgressionText.textContent}' selected.`, 'info');
                }

                function updatePatternBettingSystemDetails() {
                    let detailsHtml = '';
                    switch (gameState.patternBetting.currentSystem) {
                        case 'flatBetting':
                            detailsHtml = `<p class="text-medium">Flat betting involves placing the same amount of units on every wager, regardless of wins or losses. It's a low-risk strategy focused on consistency.</p>
                                           <p class="mt-2">Set your base bet in units:</p>
                                           <input type="number" id="patternFlatBetInput" class="strategy-input mt-2" value="${gameState.patternBetting.flatBetAmount}" min="1">
                                           <button class="strategy-btn mt-4" id="setPatternFlatBetBtn">Set Flat Bet (Units)</button>`;
                            break;
                        case 'martingale':
                            detailsHtml = `<p class="text-medium">The Martingale system involves doubling your bet units after every loss, aiming to recover all previous losses with a single win. Risky, requires large bankroll.</p>
                                           <p class="text-warning mt-2">Starting bet: ${gameState.patternBetting.martingaleBet} units. Next bet will adjust based on outcome.</p>`;
                            break;
                        case 'dalembert':
                            detailsHtml = `<p class="text-medium">D'Alembert system involves increasing your bet by one unit after a loss and decreasing by one unit after a win. Less aggressive than Martingale.</p>
                                           <p class="text-warning mt-2">Starting bet: ${gameState.patternBetting.dalembertBet} units. Next bet will adjust based on outcome.</p>`;
                            break;
                        case 'fibonacci':
                            detailsHtml = `<p class="text-medium">Fibonacci system uses the Fibonacci sequence (1, 1, 2, 3, 5, 8...) where the next bet is the sum of the previous two. Move up the sequence on loss, back two on win.</p>
                                           <p class="text-warning mt-2">Current Fibonacci Index: ${gameState.patternBetting.fibonacciIndex}. Next bet will adjust based on outcome.</p>`;
                            break;
                        default:
                            detailsHtml = `<p class="text-center text-gray-400">Choose a betting system from the dropdown above to see its description and controls.</p>`;
                    }
                    elements.patternBettingSystemDetails.innerHTML = detailsHtml;

                    if (gameState.patternBetting.currentSystem === 'flatBetting') {
                        document.getElementById('setPatternFlatBetBtn').onclick = () => {
                            const newBet = parseInt(document.getElementById('patternFlatBetInput').value);
                            if (!isNaN(newBet) && newBet >= 1) {
                                gameState.patternBetting.flatBetAmount = newBet;
                                displayMessage(`Flat bet set to ${newBet} units.`, 'success');
                                updatePatternNextBetDisplay();
                            } else {
                                displayMessage('Please enter a valid flat bet amount (at least 1 unit).', 'error');
                            }
                        };
                    }
                    updatePatternNextBetDisplay();
                }

                function updateTheoreticalBankroll(outcomeWinLoss, impliedBetTarget) { // outcomeWinLoss will be 'win', 'loss'
                    let betUnits = 0;
                    const pb = gameState.patternBetting; // Shorthand for patternBetting

                    // Get the number of units that *would have been* bet for the current progression step
                    let currentBetUnitsForCalc = 0;
                     switch (pb.currentSystem) {
                        case 'flatBetting': currentBetUnitsForCalc = pb.flatBetAmount; break;
                        case 'martingale': currentBetUnitsForCalc = pb.martingaleBet; break;
                        case 'dalembert': currentBetUnitsForCalc = pb.dalembertBet; break;
                        case 'fibonacci': currentBetUnitsForCalc = pb.fibonacciSequence[pb.fibonacciIndex]; break;
                        case 'masaniello':
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            currentBetUnitsForCalc = currentMasanielloCell.value;
                            break;
                        default:
                            currentBetUnitsForCalc = 0;
                    }
                    
                    // Convert units to dollars for actual balance calculation
                    const betAmountDollars = currentBetUnitsForCalc * pb.bettingUnitValue;

                    // Prevent negative bankroll if a loss would exceed it
                    if (pb.theoreticalBankroll - betAmountDollars < 0 && outcomeWinLoss === 'loss') {
                        displayMessage(`Theoretical bankroll ($${pb.theoreticalBankroll.toLocaleString()}) insufficient for next $${betAmountDollars.toFixed(2)} bet. Resetting betting system.`, 'error');
                        resetPatternBettingSystem(true); // Reset all, including selected system
                        return;
                    }

                    if (outcomeWinLoss === 'win') {
                        let winAmountDollars = betAmountDollars;
                        // Apply commission for Banker wins when betting on Banker (theoretical)
                        if (impliedBetTarget === 'banker') {
                            winAmountDollars = winAmountDollars * 0.95; // 5% commission on Banker wins
                        } else if (impliedBetTarget === 'tie') { // Tie pays higher, usually 8:1
                            winAmountDollars = betAmountDollars * 8;
                        }
                        pb.theoreticalBankroll += winAmountDollars;
                        displayMessage(`Theoretical WIN of $${winAmountDollars.toFixed(2)}.`, 'success');
                        
                        // Apply specific progression rules for a win (in units)
                        switch (pb.currentSystem) {
                            case 'martingale': pb.martingaleBet = 1; break; // Reset to base 1 unit
                            case 'dalembert': pb.dalembertBet = Math.max(1, pb.dalembertBet - 1); break; // Minimum 1 unit
                            case 'fibonacci': pb.fibonacciIndex = Math.max(0, pb.fibonacciIndex - 2); break;
                        }

                    } else { // outcomeWinLoss is 'loss'
                        pb.theoreticalBankroll -= betAmountDollars; // Lose the full dollar amount
                        displayMessage(`Theoretical LOSS of $${betAmountDollars.toFixed(2)}.`, 'error');

                        // Apply specific progression rules for a loss (in units)
                        switch (pb.currentSystem) {
                            case 'martingale': pb.martingaleBet *= 2; break;
                            case 'dalembert': pb.dalembertBet += 1; break;
                            case 'fibonacci': 
                                pb.fibonacciIndex++;
                                if (pb.fibonacciIndex >= pb.fibonacciSequence.length) {
                                    const nextFib = pb.fibonacciSequence[pb.fibonacciIndex - 1] + pb.fibonacciSequence[pb.fibonacciIndex - 2];
                                    pb.fibonacciSequence.push(nextFib);
                                }
                                break;
                        }
                    }
                    updatePatternNextBetDisplay(); // Update display after state change
                }

                function updatePatternNextBetDisplay() {
                    let nextBetUnits = 0;
                    let currentBaseInfo = '';
                    const pb = gameState.patternBetting;

                    if (!pb.currentSystem) { // Check if a system is selected
                        elements.patternNextBetAmount.textContent = '0 units';
                        elements.patternCurrentBaseBet.textContent = 'N/A';
                        elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`;
                        return;
                    }

                    switch (pb.currentSystem) {
                        case 'flatBetting':
                            nextBetUnits = pb.flatBetAmount;
                            currentBaseInfo = `Base: ${pb.flatBetAmount} units`;
                            break;
                        case 'martingale':
                            nextBetUnits = pb.martingaleBet;
                            currentBaseInfo = `Current Bet: ${pb.martingaleBet} units`;
                            break;
                        case 'dalembert':
                            nextBetUnits = pb.dalembertBet;
                            currentBaseInfo = `Current Bet: ${pb.dalembertBet} units`;
                            break;
                        case 'fibonacci':
                            nextBetUnits = pb.fibonacciSequence[pb.fibonacciIndex];
                            currentBaseInfo = `Current Index: ${pb.fibonacciIndex}`;
                            break;
                        case 'masaniello': // Masaniello uses its own current position for suggested bet units
                            const currentMasanielloCell = masanielloGridConfig[gameState.masanielloState.currentRow][gameState.masanielloState.currentCol];
                            nextBetUnits = currentMasanielloCell.value;
                            currentBaseInfo = `Unit Value: $${gameState.masanielloState.unitIncrement}`; // Masaniello units directly map to its own config
                            break;
                        default:
                            nextBetUnits = 0;
                            currentBaseInfo = 'N/A';
                    }
                    elements.patternNextBetAmount.textContent = `${nextBetUnits.toLocaleString()} units`;
                    elements.patternCurrentBaseBet.textContent = currentBaseInfo;
                    elements.patternCurrentTheoreticalBankroll.textContent = `$${pb.theoreticalBankroll.toLocaleString()}`; // Always update bankroll display
                }

                function resetPatternBettingSystem(resetSelectedSystem = true) {
                    if (resetSelectedSystem) {
                        gameState.patternBetting.currentSystem = null; // Also reset selected system in dropdown
                        elements.selectedBettingProgressionText.textContent = 'Select System';
                    }

                    gameState.patternBetting.martingaleBet = 1; // Reset to 1 unit
                    gameState.patternBetting.dalembertBet = 1; // Reset to 1 unit
                    gameState.patternBetting.fibonacciSequence = [1, 1];
                    gameState.patternBetting.fibonacciIndex = 0;
                    gameState.patternBetting.flatBetAmount = 1; // Reset to 1 unit
                    gameState.patternBetting.theoreticalBankroll = 10000; // Reset theoretical bankroll

                    gameState.bankrollTimeline = []; // Clear chart data
                    updatePatternAnalysisChart(); // Update chart to clear it visually
                    elements.patternChartContainer.classList.add('hidden'); // Hide chart if no data

                    // Update the flat bet input if it's currently visible
                    const flatBetInput = document.getElementById('patternFlatBetInput');
                    if (flatBetInput) {
                        flatBetInput.value = gameState.patternBetting.flatBetAmount;
                    }

                    elements.patternBettingInputArea.classList.add('hidden'); // Hide the bet info
                    elements.patternBettingSystemDetails.innerHTML = `<p class="text-center text-gray-400">Choose a betting system to manage your wagers.</p>`; // Reset details

                    updatePatternNextBetDisplay(); // Update display with new unit value (will show 0 units)
                    displayMessage('Betting system reset to base units. Theoretical bankroll reset.', 'info');
                }

                function initPatternAnalysisChart() {
                    if (gameState.patternAnalysisChartInstance) {
                        gameState.patternAnalysisChartInstance.destroy();
                    }
                    // Ensure the canvas context is properly retrieved
                    // Recreate the canvas to ensure a clean slate if it was previously destroyed
                    if (!elements.patternAnalysisChartCanvas.parentNode) { // Check if it's detached
                        const parent = document.getElementById('patternChartContainer');
                        if (parent) {
                            parent.innerHTML = '<h4 class="panel-title" style="font-size: 1.8rem;">Theoretical Bankroll Evolution</h4><canvas id="patternAnalysisChart"></canvas>';
                            elements.patternAnalysisChartCanvas = document.getElementById('patternAnalysisChart');
                        }
                    } else if (elements.patternAnalysisChartCanvas.tagName !== 'CANVAS') { // If it's something else after innerHTML manipulation
                         elements.patternAnalysisChartCanvas.remove();
                         const parent = document.getElementById('patternChartContainer');
                         if (parent) {
                             parent.innerHTML = '<h4 class="panel-title" style="font-size: 1.8rem;">Theoretical Bankroll Evolution</h4><canvas id="patternAnalysisChart"></canvas>';
                             elements.patternAnalysisChartCanvas = document.getElementById('patternAnalysisChart');
                         }
                    }

                    const ctx = elements.patternAnalysisChartCanvas.getContext('2d');
                    if (!ctx) return; // Exit if context is not available

                    const style = getComputedStyle(document.documentElement);
                    const successColor = style.getPropertyValue('--success').trim();
                    const dangerColor = style.getPropertyValue('--danger').trim();
                    const warningColor = style.getPropertyValue('--warning').trim(); 

                    gameState.patternAnalysisChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [], // Outcome index
                            datasets: [{
                                label: 'Theoretical Bankroll',
                                data: [],
                                borderColor: successColor, // Initial color
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 5,
                                pointBackgroundColor: successColor,
                                pointBorderColor: '#fff',
                                pointHoverRadius: 7,
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: 'var(--light)',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        title: function(context) {
                                            return `Outcome #${context[0].dataIndex + 1}`;
                                        },
                                        label: function(context) {
                                            const dataPoint = gameState.bankrollTimeline[context.dataIndex];
                                            return `Bankroll: $${dataPoint.bankroll.toLocaleString()} (Outcome: ${dataPoint.actualOutcome.toUpperCase()})`;
                                        },
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(255, 255, 255, 0.08)' },
                                    ticks: { color: 'var(--text-medium)' },
                                    title: {
                                        display: true,
                                        text: 'Outcome Number',
                                        color: 'var(--text-medium)',
                                        font: { size: 16 }
                                    }
                                },
                                y: {
                                    grid: { color: 'rgba(255, 255, 255, 0.08)' },
                                    ticks: { color: 'var(--text-medium)' },
                                    title: {
                                        display: true,
                                        text: 'Bankroll ($)',
                                        color: 'var(--text-medium)',
                                        font: { size: 16 }
                                    }
                                }
                            }
                        }
                    });
                }

                function updatePatternAnalysisChart() {
                    if (!gameState.patternAnalysisChartInstance) {
                        initPatternAnalysisChart(); // Initialize if not already
                    }
                    if (!gameState.patternAnalysisChartInstance) return; // Still return if init fails

                    const labels = gameState.bankrollTimeline.map((_, i) => `${i + 1}`);
                    const data = gameState.bankrollTimeline.map(point => point.bankroll);

                    gameState.patternAnalysisChartInstance.data.labels = labels;
                    gameState.patternAnalysisChartInstance.data.datasets[0].data = data;

                    if (gameState.bankrollTimeline.length > 0) {
                        const lastBankroll = gameState.bankrollTimeline[gameState.bankrollTimeline.length - 1].bankroll;
                        const initialBankroll = gameState.bankrollTimeline[0] ? gameState.bankrollTimeline[0].bankroll : 10000;

                        const style = getComputedStyle(document.documentElement);
                        const successColor = style.getPropertyValue('--success').trim();
                        const dangerColor = style.getPropertyValue('--danger').trim();
                        const warningColor = style.getPropertyValue('--warning').trim();

                        if (lastBankroll > initialBankroll) {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = successColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = successColor;
                        } else if (lastBankroll < initialBankroll) {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = dangerColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = dangerColor;
                        } else {
                            gameState.patternAnalysisChartInstance.data.datasets[0].borderColor = warningColor;
                            gameState.patternAnalysisChartInstance.data.datasets[0].pointBackgroundColor = warningColor;
                        }
                    }

                    gameState.patternAnalysisChartInstance.update();
                    // elements.patternChartContainer.classList.remove('hidden'); // Managed by toggle now
                    // elements.patternChartContainer.classList.add('animate__animated', 'animate__fadeIn');
                    // setTimeout(() => elements.patternChartContainer.classList.remove('animate__fadeIn'), 1000);
                }

                // NEW: Pattern Outcome Distribution Chart
                function initPatternOutcomeDistributionChart() {
                    if (gameState.patternOutcomeDistributionChartInstance) {
                        gameState.patternOutcomeDistributionChartInstance.destroy();
                    }
                    
                    // Recreate the canvas to ensure a clean slate
                    if (!elements.patternOutcomeDistributionChartCanvas.parentNode) { // Check if it's detached
                        const parent = document.getElementById('patternOutcomeDistributionChartContainer');
                        if (parent) {
                            parent.innerHTML = '<h4 class="panel-title" style="font-size: 1.8rem;">Pattern Outcome Distribution</h4><canvas id="patternOutcomeDistributionChart"></canvas>';
                            elements.patternOutcomeDistributionChartCanvas = document.getElementById('patternOutcomeDistributionChart');
                        }
                    } else if (elements.patternOutcomeDistributionChartCanvas.tagName !== 'CANVAS') {
                         elements.patternOutcomeDistributionChartCanvas.remove();
                         const parent = document.getElementById('patternOutcomeDistributionChartContainer');
                         if (parent) {
                             parent.innerHTML = '<h4 class="panel-title" style="font-size: 1.8rem;">Pattern Outcome Distribution</h4><canvas id="patternOutcomeDistributionChart"></canvas>';
                             elements.patternOutcomeDistributionChartCanvas = document.getElementById('patternOutcomeDistributionChart');
                         }
                    }


                    const ctx = elements.patternOutcomeDistributionChartCanvas.getContext('2d');
                    if (!ctx) return; // Exit if context is not available

                    const style = getComputedStyle(document.documentElement);
                    const infoColor = style.getPropertyValue('--info').trim();
                    const dangerColor = style.getPropertyValue('--danger').trim();
                    const warningColor = style.getPropertyValue('--warning').trim();

                    gameState.patternOutcomeDistributionChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Player', 'Banker', 'Tie'],
                            datasets: [{
                                label: 'Outcome Count',
                                data: [0, 0, 0], // Initial data
                                backgroundColor: [infoColor, dangerColor, warningColor],
                                borderColor: ['#fff', '#fff', '#fff'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false // No legend needed for single dataset bar chart
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return `${context.label}: ${context.raw}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: { display: false },
                                    ticks: { color: 'var(--light)' }
                                },
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                    ticks: { color: 'var(--light)', precision: 0 }
                                }
                            },
                            animation: {
                                duration: 800,
                                easing: 'easeOutQuart'
                            }
                        }
                    });
                }

                function updatePatternOutcomeDistributionChart() {
                    if (!gameState.patternOutcomeDistributionChartInstance) {
                        initPatternOutcomeDistributionChart();
                    }
                    if (!gameState.patternOutcomeDistributionChartInstance) return; // Still return if init fails

                    const playerCounts = gameState.patternHistory.filter(o => o === 'player').length;
                    const bankerCounts = gameState.patternHistory.filter(o => o === 'banker').length;
                    const tieCounts = gameState.patternHistory.filter(o => o === 'tie').length;

                    gameState.patternOutcomeDistributionChartInstance.data.datasets[0].data = [playerCounts, bankerCounts, tieCounts];
                    gameState.patternOutcomeDistributionChartInstance.update();
                    
                    elements.patternOutcomeDistributionChartContainer.classList.remove('hidden');
                    elements.patternOutcomeDistributionChartContainer.classList.add('animate__animated', 'animate__fadeIn');
                    setTimeout(() => elements.patternOutcomeDistributionChartContainer.classList.remove('animate__fadeIn'), 1000);
                }


                // =============================================
                // Baccarat Mini-Game Functions
                // =============================================

                function createDeck() {
                    const suits = ['', '', '', ''];
                    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    let deck = [];
                    for (let i = 0; i < gameState.totalDecks; i++) {
                        suits.forEach(suit => {
                            ranks.forEach(rank => {
                                deck.push({ rank, suit });
                            });
                        });
                    }
                    return shuffleDeck(deck);
                }

                function shuffleDeck(deck) {
                    for (let i = deck.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [deck[i], deck[j]] = [deck[j], deck[i]];
                    }
                    return deck;
                }

                function getCardValueBaccarat(card) {
                    if (['10', 'J', 'Q', 'K'].includes(card.rank)) return 0;
                    if (card.rank === 'A') return 1;
                    return parseInt(card.rank);
                }

                function calculateHandScore(hand) {
                    let score = hand.reduce((sum, card) => sum + getCardValueBaccarat(card), 0);
                    return score % 10;
                }

                function displayHand(hand, elementId) {
                    const listElement = document.getElementById(elementId);
                    listElement.innerHTML = '';
                    hand.forEach((card, index) => {
                        const cardItem = document.createElement('div');
                        cardItem.className = 'card-item animate__animated animate__fadeInUp';
                        cardItem.textContent = `${card.rank}${card.suit}`;
                        cardItem.style.animationDelay = `${index * 0.2}s`; // Stagger animation
                        listElement.appendChild(cardItem);
                    });
                }

                function determineWinner(playerScore, bankerScore, playerHand, bankerHand) {
                    // Check for natural wins (8 or 9 on first two cards)
                    const playerNatural = playerHand.length === 2 && (playerScore === 8 || playerScore === 9);
                    const bankerNatural = bankerHand.length === 2 && (bankerScore === 8 || bankerScore === 9);

                    if (playerNatural && bankerNatural) {
                        if (playerScore === bankerScore) return 'tie';
                        return playerScore > bankerScore ? 'player' : 'banker';
                    }
                    if (playerNatural) return 'player';
                    if (bankerNatural) return 'banker';

                    if (playerScore === bankerScore) return 'tie';
                    return playerScore > bankerScore ? 'player' : 'banker';
                }

                // Baccarat third card rules
                function shouldPlayerDraw(playerScore) {
                    return playerScore <= 5;
                }

                function shouldBankerDraw(bankerScore, playerThirdCardValue) {
                    if (bankerScore <= 2) return true;
                    if (bankerScore === 3 && playerThirdCardValue !== 8) return true;
                    if (bankerScore === 4 && playerThirdCardValue >= 2 && playerThirdCardValue <= 7) return true;
                    if (bankerScore === 5 && playerThirdCardValue >= 4 && playerThirdCardValue <= 7) return true;
                    if (bankerScore === 6 && (playerThirdCardValue === 6 || playerThirdCardValue === 7)) return true;
                    return false;
                }

                function resetMiniGameUI() {
                    elements.playerCardList.innerHTML = '';
                    elements.bankerCardList.innerHTML = '';
                    elements.playerScore.textContent = '0';
                    elements.bankerScore.textContent = '0';
                    elements.gameResultDisplay.classList.add('hidden');
                    elements.gameResultText.textContent = '';
                    elements.betOptionBtns.forEach(btn => btn.classList.remove('active-bet')); // Remove active bet highlight
                    gameState.currentBet.type = null; // Clear selected bet type
                    // gameState.currentBet.amount is kept as last entered for convenience
                }

                function dealHand() {
                    const betAmount = parseInt(elements.betAmountInput.value);
                    const betTarget = gameState.currentBet.type;

                    if (!betTarget) {
                        displayMessage('Please select a bet target (Player, Banker, or Tie).', 'error');
                        return;
                    }
                    if (isNaN(betAmount) || betAmount <= 0) {
                        displayMessage('Please enter a valid bet amount.', 'error');
                        return;
                    }
                    if (betAmount > gameState.miniGameBalance) { // Check against mini-game balance
                        displayMessage('You do not have enough balance for this bet!', 'error');
                        return;
                    }

                    resetMiniGameUI();
                    displayMessage(`Betting $${betAmount} on ${betTarget.toUpperCase()}. Dealing cards...`, 'info');
                    gameState.currentBet.amount = betAmount; // Store actual bet amount for this round

                    gameState.deck = createDeck();
                    gameState.playerHand = [];
                    gameState.bankerHand = [];

                    // Deal initial 2 cards to Player and Banker
                    gameState.playerHand.push(gameState.deck.pop());
                    gameState.bankerHand.push(gameState.deck.pop());
                    gameState.playerHand.push(gameState.deck.pop());
                    gameState.bankerHand.push(gameState.deck.pop());

                    displayHand(gameState.playerHand, 'playerCardList');
                    displayHand(gameState.bankerHand, 'bankerCardList');

                    let playerScore = calculateHandScore(gameState.playerHand);
                    let bankerScore = calculateHandScore(gameState.bankerHand);
                    elements.playerScore.textContent = playerScore;
                    elements.bankerScore.textContent = bankerScore;

                    // Delay for natural win check and potential third card draw
                    setTimeout(() => {
                        let playerThirdCard = null;

                        // Check for natural wins immediately after initial deal
                        const playerNatural = gameState.playerHand.length === 2 && (playerScore === 8 || playerScore === 9);
                        const bankerNatural = gameState.bankerHand.length === 2 && (bankerScore === 8 || bankerScore === 9);

                        let needsThirdCardPhase = true;

                        if (playerNatural || bankerNatural) {
                            if (playerNatural && bankerNatural) {
                                // Both have naturals, determine winner directly
                                needsThirdCardPhase = false;
                            } else if (playerNatural) {
                                // Only player has natural
                                needsThirdCardPhase = false;
                            } else if (bankerNatural) {
                                // Only banker has natural
                                needsThirdCardPhase = false;
                            }
                        }

                        if (needsThirdCardPhase) {
                            // Player's third card rule
                            const playerDraws = shouldPlayerDraw(playerScore);
                            if (playerDraws) {
                                playerThirdCard = gameState.deck.pop();
                                gameState.playerHand.push(playerThirdCard);
                                displayHand(gameState.playerHand, 'playerCardList');
                                playerScore = calculateHandScore(gameState.playerHand);
                                elements.playerScore.textContent = playerScore;
                                displayMessage('Player drew a third card.', 'info');
                            }

                            // Banker's third card rule
                            const playerThirdCardValue = playerThirdCard ? getCardValueBaccarat(playerThirdCard) : null;
                            const bankerDraws = shouldBankerDraw(bankerScore, playerThirdCardValue);
                            if (bankerDraws) {
                                gameState.bankerHand.push(gameState.deck.pop());
                                displayHand(gameState.bankerHand, 'bankerCardList');
                                bankerScore = calculateHandScore(gameState.bankerHand);
                                elements.bankerScore.textContent = bankerScore;
                                displayMessage('Banker drew a third card.', 'info');
                            }
                        }


                        setTimeout(() => {
                            const winner = determineWinner(playerScore, bankerScore, gameState.playerHand, gameState.bankerHand);
                            let winLossAmount = 0;
                            let resultText = '';
                            let resultClass = '';

                            if (winner === betTarget) {
                                if (betTarget === 'banker') {
                                    winLossAmount = gameState.currentBet.amount * 0.95; // Banker wins pay 0.95 (5% commission)
                                } else if (betTarget === 'tie') {
                                    winLossAmount = gameState.currentBet.amount * 8; // Tie typically pays 8:1
                                } else {
                                    winLossAmount = gameState.currentBet.amount; // Player wins pay 1:1
                                }
                                gameState.miniGameBalance += winLossAmount; // Update mini-game balance
                                resultText = `You WON! ${winner.toUpperCase()} wins! (+ $${winLossAmount.toFixed(2)})`;
                                resultClass = 'result-player'; // Use player color for winning
                            } else {
                                winLossAmount = -gameState.currentBet.amount;
                                gameState.miniGameBalance -= gameState.currentBet.amount; // Update mini-game balance
                                resultText = `You LOST! ${winner.toUpperCase()} wins. (- $${Math.abs(winLossAmount).toFixed(2)})`;
                                resultClass = 'result-banker'; // Use banker color for losing
                            }

                            if (winner === 'tie' && betTarget !== 'tie') {
                                // If tie won, but you didn't bet on tie, it's a push for player/banker bets
                                resultText = `It's a TIE! Your ${betTarget.toUpperCase()} bet is a push.`;
                                resultClass = 'result-tie';
                                winLossAmount = 0; // No change in balance for push
                            }

                            elements.miniGameBalanceDisplay.textContent = `$${gameState.miniGameBalance.toLocaleString()}`; // Update mini-game balance display
                            elements.gameNewBalance.textContent = `$${gameState.miniGameBalance.toLocaleString()}`;
                            elements.gameResultText.textContent = resultText;
                            elements.gameResultText.className = `game-result ${resultClass}`;
                            elements.gameResultDisplay.classList.remove('hidden');

                            if (winLossAmount > 0) {
                                elements.gameResultText.classList.add('animate__animated', 'animate__bounceIn');
                            } else if (winLossAmount < 0) {
                                elements.gameResultText.classList.add('animate__animated', 'animate__shakeX');
                            } else { // push/tie
                                elements.gameResultText.classList.add('animate__animated', 'animate__fadeIn');
                            }

                        }, 1000); // Delay for third card reveal
                    }, 1000); // Delay for initial card reveal
                }


                // =============================================
                // Event Listeners
                // =============================================
                // Card Counting Buttons
                elements.cardButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const cardValue = this.dataset.cardValue;
                        addCardEntry(cardValue);
                        this.classList.add('animate__rubberBand');
                        setTimeout(() => {
                            this.classList.remove('animate__rubberBand');
                        }, 1000);
                    });
                });

                elements.clearBtn.addEventListener('click', function() {
                    clearAllCardCounting();
                    this.classList.add('animate__shakeX');
                    setTimeout(() => {
                        this.classList.remove('animate__shakeX');
                    }, 1000);
                });

                // Strategy Tabs
                elements.strategyTabs.addEventListener('click', function(event) {
                    if (event.target.classList.contains('tab-btn')) {
                        const tabId = event.target.dataset.tab;

                        elements.strategyTabs.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                        elements.tabContents.forEach(content => {
                            content.classList.remove('active');
                            content.classList.remove('animate__fadeIn'); // Ensure previous fade-in is removed
                        });

                        event.target.classList.add('active');
                        const activeTabContent = document.getElementById(tabId);
                        activeTabContent.classList.add('active', 'animate__animated', 'animate__fadeIn'); // Add fade-in animation
                        
                        // Re-initialize chart only for Card Counting tab if not already initialized or is missing
                        if (tabId === 'cardCounting' && (!gameState.chart || !elements.chartArea.querySelector('canvas'))) {
                            initChart();
                            updateChart();
                        } else if (tabId === 'cardCounting' && gameState.chart) {
                            // If chart exists, just ensure it's updated with current state
                            updateChart();
                            updateRoadmap();
                            updateStats();
                            updateHistory();
                            updateRecommendation();
                        } else if (tabId === 'patternRecognition') {
                            updatePatternDetails(); // Re-render details on tab switch
                            updatePatternAnalysis(); // Re-evaluate pattern recommendation
                            initPatternOutcomeDistributionChart(); // Ensure pattern outcome chart is initialized
                            updatePatternOutcomeDistributionChart(); // Update it
                        } else if (tabId === 'miniGame') {
                            resetMiniGameUI(); // Reset mini-game UI on tab switch
                        }

                        // Remove animation class after it completes to allow re-triggering
                        setTimeout(() => {
                            activeTabContent.classList.remove('animate__fadeIn');
                        }, 1200); // Chart fade-in duration
                    }
                });

                // Pattern Recognition Dropdown & Buttons
                elements.patternDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.patternDropdownMenu);
                });

                elements.patternDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        selectPatternStrategy(event.target.dataset.strategy);
                    }
                });

                elements.patternOutcomeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        if (gameState.currentPatternStrategy) {
                            recordPatternOutcome(this.dataset.outcome);
                            this.classList.add('animate__animated', 'animate__pulse'); // Use animate.css pulse
                            setTimeout(() => this.classList.remove('animate__pulse'), 500);
                        } else {
                            displayMessage('Please select a pattern strategy first!', 'error');
                        }
                    });
                });

                elements.clearPatternBtn.addEventListener('click', clearPatternHistory);

                // Betting Progression Toggle
                elements.enableBettingProgressionToggle.addEventListener('change', function() {
                    gameState.patternBetting.isEnabled = this.checked;
                    if (this.checked) {
                        elements.patternBettingControls.classList.remove('hidden');
                        elements.patternBettingControls.classList.add('animate__animated', 'animate__fadeInDown');
                        
                        if (!gameState.patternBetting.currentSystem) {
                            selectPatternBettingSystem('flatBetting'); // Defaults to flat if none selected
                        } else {
                            updatePatternNextBetDisplay(); // Update display if system already selected
                        }

                        // Show theoretical bankroll chart only if a betting system is selected AND it's not Masaniello
                        if (gameState.patternBetting.currentSystem && gameState.currentPatternStrategy !== 'masaniello') {
                            // Only show if there's actual bankroll history to display, or if it's a fresh start
                            if (gameState.bankrollTimeline.length > 0 || gameState.patternBetting.theoreticalBankroll === 10000) {
                                elements.patternChartContainer.classList.remove('hidden');
                                elements.patternChartContainer.classList.add('animate__animated', 'animate__fadeInUp');
                                updatePatternAnalysisChart(); // Initialize/update chart
                            }
                        } else {
                            elements.patternChartContainer.classList.add('hidden'); // Hide if Masaniello or no system
                        }
                        displayMessage('Betting progression enabled.', 'success');
                    } else {
                        elements.patternBettingControls.classList.add('hidden');
                        elements.patternBettingControls.classList.remove('animate__fadeInDown');
                        elements.patternChartContainer.classList.add('hidden'); // Hide chart when disabled
                        resetPatternBettingSystem(true); // Reset all, including selected system
                        displayMessage('Betting progression disabled and reset.', 'info');
                    }
                });


                // Betting Progression Dropdown & Buttons (within Pattern Recognition)
                elements.bettingProgressionDropdownBtn.addEventListener('click', () => {
                    toggleDropdown(elements.bettingProgressionDropdownMenu);
                });

                elements.bettingProgressionDropdownMenu.addEventListener('click', (event) => {
                    if (event.target.classList.contains('dropdown-item')) {
                        selectPatternBettingSystem(event.target.dataset.system);
                        // Show theoretical bankroll chart if betting is enabled and not Masaniello
                        if (gameState.patternBetting.isEnabled && gameState.currentPatternStrategy !== 'masaniello') {
                            elements.patternChartContainer.classList.remove('hidden');
                            elements.patternChartContainer.classList.add('animate__animated', 'animate__fadeInUp');
                            updatePatternAnalysisChart();
                        } else {
                            elements.patternChartContainer.classList.add('hidden');
                        }
                    }
                });

                elements.patternResetBettingBtn.addEventListener('click', () => resetPatternBettingSystem(false)); // Don't reset selected system

                // Set Unit Value for Betting Progressions
                elements.setBetUnitValueBtn.addEventListener('click', function() {
                    const newUnitValue = parseInt(elements.betUnitValueInput.value);
                    if (!isNaN(newUnitValue) && newUnitValue >= 1) {
                        gameState.patternBetting.bettingUnitValue = newUnitValue;
                        displayMessage(`Betting unit set to $${newUnitValue}.`, 'success');
                        updatePatternNextBetDisplay(); // Update display with new unit value
                        this.classList.add('animate__animated', 'animate__tada'); // Add animation
                        setTimeout(() => this.classList.remove('animate__tada'), 1000);
                    } else {
                        displayMessage('Please enter a valid unit value (minimum $1).', 'error');
                        this.classList.add('animate__animated', 'animate__shakeX'); // Add animation on error
                        setTimeout(() => this.classList.remove('animate__shakeX'), 1000);
                    }
                });


                // Mini-Game Buttons
                elements.betOptionBtns.forEach(button => {
                    button.addEventListener('click', function() {
                        elements.betOptionBtns.forEach(btn => btn.classList.remove('active-bet')); // Clear active state
                        this.classList.add('active-bet'); // Add active state to clicked button
                        gameState.currentBet.type = this.dataset.betTarget;
                        displayMessage(`Selected to bet on ${gameState.currentBet.type.toUpperCase()}.`, 'info');
                        this.classList.add('animate__animated', 'animate__rubberBand');
                        setTimeout(() => this.classList.remove('animate__rubberBand'), 1000);
                    });
                });

                elements.dealHandBtn.addEventListener('click', function() {
                    dealHand();
                    this.classList.add('animate__animated', 'animate__swing');
                    setTimeout(() => {
                        this.classList.remove('animate__swing');
                    }, 1000);
                });


                // Initial setup for the app (after successful authentication)
                function init() {
                    initChart(); // Initialize chart for card counting tab
                    startTimer(); // Start global timer
                    // No sample data added automatically on init for card counting
                    updateRoadmap();
                    updateChart();
                    updateStats();
                    updateHistory();
                    updateRecommendation();
                    initMasanielloGrid(); // Initialize Masaniello grid state
                    updatePatternDetails(); // Load initial pattern details and prediction
                    updatePatternNextBetDisplay(); // Initialize betting display
                    initPatternAnalysisChart(); // Initialize the new pattern analysis chart (theoretical bankroll)
                    initPatternOutcomeDistributionChart(); // Initialize the new pattern outcome distribution chart
                }

                init();
            }

            // Initial check for authentication status on page load
            checkExistingAuth();
        });
    </script>
</body>
</html>
